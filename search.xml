<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>K-Dtree学习笔记</title>
    <url>/2020/01/17/KDtree/</url>
    <content><![CDATA[<h3 id="什么是k-dtree">什么是K-Dtree</h3>
<blockquote>
<p>在计算机科学里，<strong>k-d树</strong>（ <strong>k-维树</strong>的缩写）是在<strong>k</strong>维欧几里德空间组织点的数据1结构。<strong>k-d</strong>树可以使用在多种应用场合，如多维键值搜索（例：范围搜寻及最邻近搜索）。<strong>k-d树</strong>是空间二分树（Binary space partitioning ）的一种特殊情况。</p>
</blockquote>
<hr />
<h3 id="如何构造k-dtree">如何构造K-Dtree</h3>
<h4 id="节点存储">节点存储</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,minx,miny,maxx,maxy;</span><br><span class="line">    node *ch[<span class="number">2</span>];</span><br><span class="line">    node (point a)</span><br><span class="line">    &#123;</span><br><span class="line">        x=minx=maxx=a.x;</span><br><span class="line">        y=miny=maxy=a.y;</span><br><span class="line">        ch[<span class="number">0</span>]=ch[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br></pre></td></tr></table></figure>
<p>可以看到代码是<strong>2-Dtree</strong>，没有使用一个数组存放每个维度的位置而是直接开了<strong>x</strong>和<strong>y</strong>两个变量。<strong>minx</strong>,<strong>miny</strong>,<strong>maxx</strong>,<strong>maxy</strong>存放了以这个节点为根的树中的点的覆盖范围，当维数增大时依然可以使用数组存放更加方便。<strong>ch[2]</strong>是儿子，这里使用了指针，也可使用数组。</p>
<h4 id="build函数">build函数</h4>
<p>参考当<span class="math inline">\(k=2\)</span>时的特殊数据结构——二叉查找树的构造方法，确定一个当前要排序的维度，对所有的数据以这一维排序，并递归到两边的数据继续这样的操作，直到只有一个点直接 return 。</p>
<p>如何确定当前划分维度？有三种方法：按顺序一维一维划分，rand()和按每维度方差。三种方法各有各的好处。</p>
<p>以下是一个rand划分的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dim)</span><span class="comment">//l和r为划分的点在序列中的位置，dim为当前划分的维度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        node* t=<span class="keyword">new</span> node(p[l]);<span class="comment">//这个点自己的信息</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    nth_element(p+l,p+mid,p+r,dim?cmpy:cmpx);<span class="comment">//找到区间内这一维的中位数，小于中位数的在左边，大于的在右边</span></span><br><span class="line">    node *t=<span class="keyword">new</span> node(p[mid]);</span><br><span class="line">    <span class="keyword">int</span> nxt=rand()%<span class="number">2</span>;<span class="comment">//rand划分</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;mid)t-&gt;ch[<span class="number">0</span>]=build(l,mid<span class="number">-1</span>,nxt);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)t-&gt;ch[<span class="number">1</span>]=build(mid+<span class="number">1</span>,r,nxt);</span><br><span class="line">    pushup(t);<span class="comment">//更新minx等数据</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造好的<strong>K-Dtree</strong>大概长这个样子：</p>
<p>待更新qwq</p>
]]></content>
      <tags>
        <tag>data_structure</tag>
      </tags>
  </entry>
  <entry>
    <title>pairingheap</title>
    <url>/2020/01/16/pairingheap/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>data_structure</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2014」力 - FFT</title>
    <url>/2019/12/29/ZJOI2014-%E5%8A%9B/</url>
    <content><![CDATA[<p>给出n个数<span class="math inline">\(q_i\)</span>，给出<span class="math inline">\(F_j\)</span>的定义如下： <span class="math display">\[
F_j = \sum_{i&lt;j}\frac{q_i q_j}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i q_j}{(i-j)^2 }
\]</span></p>
<p>令<span class="math inline">\(E_i=\frac{F_i}{q_i}\)</span>，求<span class="math inline">\(E_i\)</span> <span class="math display">\[
E_j=\sum_{i&lt;j}\frac{q_i}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i}{(i-j)^2 }
\]</span></p>
<p>设<span class="math inline">\(f[i]=q[i],g[i]=\frac{1}{i^2}\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i&lt;j}f[i]g[j-i]-\sum\limits_{i&gt;j}f[i]g[i-j]\\
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=j+1}^nf[i]g[i-j]
\]</span> 设<span class="math inline">\(f&#39;[i]=f[n-i+1]\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=1}^{n-j}f&#39;[i]g[j-i]
\]</span> 直接卷积就好</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> +(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r+y.r,x.i+y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> -(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r-y.r,x.i-y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> *(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r&#125;;&#125;</span><br><span class="line">&#125;q[<span class="number">400005</span>],qq[<span class="number">400005</span>],f[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp* f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        comp wn=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*pi/len),op*<span class="built_in">sin</span>(<span class="number">2</span>*pi/len)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            comp w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                comp d=f[j+q]*w;</span><br><span class="line">                f[j+q]=f[j]-d;</span><br><span class="line">                f[j]=f[j]+d;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;q[i].r),qq[n-i+<span class="number">1</span>].r=q[i].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i].r=(((<span class="keyword">double</span>)<span class="number">1.0</span>)/(<span class="keyword">double</span>)i/(<span class="keyword">double</span>)i);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    getrev(len);</span><br><span class="line">    fft(q,len,<span class="number">1</span>),fft(qq,len,<span class="number">1</span>),fft(f,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)q[i]=q[i]*f[i],qq[i]=qq[i]*f[i];</span><br><span class="line">    fft(q,len,<span class="number">-1</span>),fft(qq,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>,(q[i].r-qq[n-i+<span class="number">1</span>].r)/len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>csp2019游记</title>
    <url>/2019/12/29/csp2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>咕咕咕了一个多月的游记qwq</p>
<h3 id="day-8">Day-8</h3>
<p>期中考完了开始快乐的停课生活qwq</p>
<h3 id="day0">Day0</h3>
<p>如果没有记错的话下午到了秦皇岛，试完机后就去酒店放行李（其实就两个包），晚上和同机房的同学们一起去吃了酸菜鱼（味道还不错qwq），本来还想吃冰激淋的可是想到去年noip的惨痛经历就忍住了没吃。回到酒店开始颓Terraria。晚上本来和我一个房间的AlanSP去找家长住了，第一次一个人睡双人间。自我感觉良好。</p>
<h3 id="day1">Day1</h3>
<p>不喜欢吃酒店的早餐，简单吃了点找别人借了本李煜东看了会exgcd和exbsgs，然后就去燕大了。</p>
<p>到考场上丝毫不慌，反正我退役稳了，然后就一直盯着前面的表看时间。</p>
<p>终于开考了，一遍输对了密码（据说有人输了三遍才对）。先看一遍题，感觉不是很难的样子，于是就以正常顺序开题。T1不是**题嘛，花5分钟写好结果大样例过不去，调了10分钟才发现写的是1而不是1ull，在此之前还发现输出锅了，还好我记得unsigned long long 输出是%llu （其实也可以用cout的）。大概在开考后30分钟过了大样例然后造了一下64 2^64-1没有问题就封题了。</p>
<p>T2第一眼看眼前一亮，前两天模拟赛不是考过合法括号序列嘛，所以”很快“的码完了，但中间windows下爆栈了，不慌不忙开了虚拟机，果然在linux下就没啥问题，顺便也把T1又测了一下，过了114514后就封题了（我考场上竟然没看出来114514）。</p>
<p>还有将近两个小时，我过不了T3，这个T3长得这么水，我要是过不了，我当场！就把这个电脑屏幕吃掉！</p>
<p>1 hour left：woc我觉得不行，先把10分暴力打了，看看能不能把链和菊花图做了</p>
<p>45 mins left：我想到链怎么做了！开始码！</p>
<p>20 mins left： woc怎么一直RE，dev的调试功能是什么毒瘤（我之前看了gdb怎么用但是考场上一慌就忘了）。</p>
<p>10 mins left： 标准结局，自闭了。封题检查文件。</p>
<p>出考场问了问其他人，大概都是100+100+10？感觉是个大众分鸭，今年说不定能上400呢。</p>
<p>颓了一下午和一晚上，我昨天跟AlanSP说要打过亵渎天神，晚上又是我一个人睡的，不知道为什么感觉走廊有人走路，有点吓人。</p>
<h3 id="day2">Day2</h3>
<p>自闭日。</p>
<p>先看了一遍题，感觉T1最不可做？？？（出考场后发现读题出锅了）然后T3 送了40分就先码完了40。接着自闭了一个小时来回看三道题都觉得不可做。大概还剩1个小时10分钟想了下并码了T2的 <span class="math inline">\(N^3\)</span>，发现可以二分转移就优化到了<span class="math inline">\(N^2logn\)</span>，这个时候大概还剩25分钟，赶紧码了T1爆搜结果样例2过不去？？？调了10分钟没出来，然后就彻底自闭了。最后还剩下5分钟只得放弃，开始建文件夹。</p>
<p>出了考场发现其他人都比我高（，自闭了，Eta估分100+64+55，jiqimao神仙切了两道，然后就在遗憾中回了学校。</p>
<p>估分100+100+10+0+64+40</p>
<p>最后得分100+80+10+8+64+40，D1T2没来longlong见祖宗/(ㄒoㄒ)/~~，差了8分进WC，还好我这种菜鸡进了也是爆零，也没有太大遗憾。jiqimao神仙HE rank2 orz。</p>
<p>感觉这次败在了D2T1上，要多做做DP了（</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>bsgs</title>
    <url>/2019/12/26/bsgs-exbsgs/</url>
    <content><![CDATA[<h3 id="bsgs">BSGS</h3>
<p>求<span class="math inline">\(a^x\equiv b\space( \mod p)\)</span> 的解，保证<span class="math inline">\(p\)</span>为质数。</p>
<p>我们设<span class="math inline">\(x=i*m-j\)</span> ，其中<span class="math inline">\(0\leqslant j &lt;m\)</span> 。那么原式可转化为<span class="math inline">\(a^{im}\equiv b*a^j(\mod p)\)</span>的解。我们预处理出<span class="math inline">\(b*a^0,b*a^1,...,b*a^{m-1}\)</span>的值，将它们存入<span class="math inline">\(hash\)</span>表中，枚举<span class="math inline">\(i\)</span>的值，每次查看<span class="math inline">\(a^{im}\)</span>在表中是否出现。</p>
<p>由费马小定理可知，等号左边是有循环节<span class="math inline">\(p-1\)</span>的，所以只需要从<span class="math inline">\(1\)</span>到<span class="math inline">\(\frac{p}{m}\)</span>枚举<span class="math inline">\(i\)</span> ，则不包含哈希表的时间复杂度在当<span class="math inline">\(m=\lceil\sqrt{n}\rceil\)</span>时最优，为<span class="math inline">\(O(\sqrt{p})\)</span>，在实际中常使用std::map作为哈希表，时间复杂度为<span class="math inline">\(O(\sqrt p\log_2p)\)</span></p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(ll a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>((<span class="keyword">double</span>)p));</span><br><span class="line">    mp.clear();</span><br><span class="line">    ll now=<span class="number">1</span>,t=pw(a,m,p);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++)mp[b*now%p]=i,now*=a,now%=p;</span><br><span class="line">    now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now*=t,now%=p;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(now))&#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,i*m-mp[now]);<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exbsgs">EXBSGS</h3>
<p>待更新</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/2019/12/22/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="分治fft">分治FFT</h4>
<p>给定数组<span class="math inline">\(g[1],...,g[n-1]\)</span>，求<span class="math inline">\(f[0],...,f[n-1]\)</span>，其中 <span class="math display">\[
f[i]=\sum\limits_{j=1}^i{f[i-j]g[j]}\\f[0]=1
\]</span> 在模<span class="math inline">\(998244353\)</span>意义下进行</p>
<p>考虑分治，先计算左半边，再计算左对右贡献，最后计算右半边，复杂度<span class="math inline">\(O(Nlog^2N)\)</span></p>
<p>也可以求逆解决，设 <span class="math display">\[
F(x)=\sum\limits_{i=0}^{n-1}f[i]x^i\\G(x)=\sum\limits_{i=0}^{n-1}g[i]x^i
\]</span> 其中，<span class="math inline">\(g[0]=0\)</span></p>
<p>对其卷积（在<span class="math inline">\(\mod x^n\)</span>意义下进行） <span class="math display">\[
F(x)G(x)\sum\limits_{k=0}^{n-1}\sum\limits_{i+j=k}f[i]g[j]x^k\\
F(x)G(x)=\sum\limits_{k=0}^{n-1}f[k]x^k-f[0]\\
F(x)G(x)=F(x)-f[0]\\
F(x)(G(x)-1)=-f[0]\\
F(x)=\frac{f[0]}{1-G(x)}
\]</span> （第二行是因为<span class="math inline">\(g[0]=0\)</span>,所以<span class="math inline">\(f[0]g[0]=0\)</span>）由于<span class="math inline">\(f[0]=1\)</span>，求逆就好了，复杂度<span class="math inline">\(O(NlogN)\)</span></p>
<h4 id="多项式-ln">多项式 <span class="math inline">\(\ln\)</span></h4>
<p>求<span class="math inline">\(B(x)\)</span>使得 <span class="math display">\[
B(x)\equiv \ln A(x) \pmod {x^n}
\]</span> 设 <span class="math display">\[
G(x)=\ln(x)
\]</span></p>
<p><span class="math display">\[
B(x)\equiv G(A(x))\pmod {x^n}
\]</span></p>
<p>两边同时求导得 <span class="math display">\[
B&#39;(x)\equiv G&#39;(A(x))A&#39;(x)\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B&#39;(x)\equiv \frac{A&#39;(x)}{A(x)}\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B(x) \equiv \int \frac{A&#39;(x)}{A(x)}dx\pmod {x^n}
\]</span></p>
<p>多项式求导，求逆，积分即可</p>
<p>注：</p>
<p><span class="math display">\[
A&#39;(x)=\sum\limits_{i=1}^{n-1}ia_ix^{i-1}
\]</span></p>
<p><span class="math display">\[
\int A(x)dx=\sum\limits_{i=0}^{n-1}\frac{a_{i}}{i+1}x^{i+1}
\]</span></p>
]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
</search>
