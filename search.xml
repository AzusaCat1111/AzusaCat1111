<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF235D Graph Game</title>
    <url>/2020/06/13/CF235D%20Graph%20Game/</url>
    <content><![CDATA[<p>求基环树随机点分治总遍历次数期望</p>
<p>基环树随机点分治步骤：</p>
<p>①遍历当前分治区域所有点一次</p>
<p>②在当前分治区域随机选择一个点 <span class="math inline">\(x\)</span></p>
<p>③将 <span class="math inline">\(x\)</span> 删掉，产生的所有连通块递归处理。</p>
<p><span class="math inline">\(n\leqslant 3000\)</span></p>
<p>按照套路，我们先考虑如果是一棵树的情况，再扩展到基环树的情况。不难发现如果我们把分治过程建成点分树，那么我们实际上求的是 <span class="math inline">\(\sum\limits_xsize_x\)</span> 的期望，其中 <span class="math inline">\(size_x\)</span> 是 <span class="math inline">\(x\)</span> 子树的大小。 根据期望的线性性，我们考虑计算点的贡献，每个点会被计算 <span class="math inline">\(deep_x\)</span> 次，那么答案就化为 <span class="math inline">\(\sum\limits_xdeep_x\)</span> ， 再进行一步转化， <span class="math inline">\(deep_x\)</span> 等价于 <span class="math inline">\(\sum_\limits y[y是x的祖先]\)</span> （当 <span class="math inline">\(x=y\)</span> 时也成立） 。我们可以画图发现，点对 <span class="math inline">\((x,y)\)</span> 会产生贡献当且仅当 <span class="math inline">\(y\)</span> 被选中时 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在一个连通块内，也就是 <span class="math inline">\(y\)</span> 是在原树中 <span class="math inline">\(x\rightarrow y\)</span> 路径（包括端点）上第一个被选中的点，举个例子</p>
<p><img src="/CF235D/1.png" /></p>
<p>我们现在考虑 <span class="math inline">\((3,1)\)</span> 的贡献，如果我们按照 <span class="math inline">\(1,2,3\)</span> 或 <span class="math inline">\(1,3,2\)</span> 的顺序，那么1就是3的祖先，会产生贡献，而如果是 <span class="math inline">\(2,1,3\)</span> <span class="math inline">\(2,3,1\)</span> <span class="math inline">\(3,1,2\)</span> <span class="math inline">\(3,2,1\)</span> 就都不会产生贡献（点对是有序的）。</p>
<p>显然，这个的概率是 <span class="math inline">\(\frac{1}{dis(x,y)}\)</span> 所以答案就是 <span class="math inline">\(\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac{1}{dis(i,j)}\)</span> 。</p>
<p>接下来我们把树上的做法扩展到基环树上，我们仍旧考虑点对对答案的贡献，分类讨论一下：</p>
<ul>
<li>当 <span class="math inline">\(x,y\)</span> 在同一棵树内，概率仍为 <span class="math inline">\(\frac{1}{dis(x,y)}\)</span></li>
<li>当路径 <span class="math inline">\(x\rightarrow y\)</span> 经过环上的点时，有两种情况可以造成贡献，分别是直接删掉 <span class="math inline">\(y\)</span> 或者先删掉环上的某一个点再删掉 <span class="math inline">\(y\)</span> ，如图</li>
</ul>
<p><img src="CF235D/2.png" /></p>
<p>我们考虑点对 <span class="math inline">\((1,7)\)</span> 设两个点到对应的树根的距离之和为 <span class="math inline">\(a\)</span> （蓝色区域），两个点对应的树根将环切为两条链，链长为 <span class="math inline">\(b,c\)</span> （绿色区域和黄色区域）。那么直接删掉 <span class="math inline">\(y\)</span> 的概率为 <span class="math inline">\(\frac{1}{a+b+c}\)</span> ，先切掉绿色区域后，剩余的绿色区域就已经不在 <span class="math inline">\(x\rightarrow y\)</span> 这条路径上了，不会对后面造成影响 ，所以我们不需要管剩余的绿色区域，只需要看 <span class="math inline">\(y\)</span> 是否是蓝色+黄色区域中第一个被切掉的点，这样总概率为 <span class="math inline">\(\frac{b}{a+b+c} \cdot \frac{1}{a+c}\)</span> 。类似，先切掉黄色，再切掉 <span class="math inline">\(y\)</span> 的概率为 <span class="math inline">\(\frac{c}{a+b+c}\cdot \frac{1}{a+b}\)</span> 。</p>
<p>所以总概率为 <span class="math inline">\(\frac{1}{a+b+c}(1+\frac{b}{a+c}+\frac{c}{a+b})\)</span> 。实现上我们只需要找到环然后暴力枚举计算答案就可以了。还需要写一个lca，代码中用倍增实现，所以复杂度为 <span class="math inline">\(O(n^2\log n)\)</span></p>
<h5 id="code">code:</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">6005</span>],pre[<span class="number">6005</span>],last[<span class="number">3005</span>],tot,fa[<span class="number">3005</span>],belong[<span class="number">3005</span>],</span><br><span class="line">deep[<span class="number">3005</span>],f[<span class="number">3005</span>][<span class="number">12</span>],index[<span class="number">3005</span>];</span><br><span class="line"><span class="keyword">bool</span> cir[<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target[++tot]=y;</span><br><span class="line">    pre[tot]=last[x];</span><br><span class="line">    last[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cir[x])&#123;index[x]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(tar,x);</span><br><span class="line">        <span class="keyword">if</span>(cir[tar])cir[x]=<span class="number">1</span>,index[x]=index[tar]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deep[x]=deep[fa]+<span class="number">1</span>;belong[x]=z;</span><br><span class="line">    f[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa||cir[tar])<span class="keyword">continue</span>;</span><br><span class="line">        dfs2(tar,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&lt;deep[y])swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">11</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(deep[f[x][k]]&gt;=deep[y])x=f[x][k];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">11</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(f[x][k]!=f[y][k])x=f[x][k],y=f[y][k];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y,len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        x++,y++;</span><br><span class="line">        <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)fa[fx]=fy;</span><br><span class="line">        <span class="keyword">else</span> cir[y]=<span class="number">1</span>,dfs(x,<span class="number">0</span>),len=index[x];</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(cir[i])dfs2(i,<span class="number">0</span>,i); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">11</span>;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i][k]=f[f[i][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(belong[i]==belong[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=lca(i,j);</span><br><span class="line">                ans+=<span class="number">1.0</span>/(deep[i]+deep[j]<span class="number">-2</span>*deep[l]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a=deep[i]+deep[j],b=<span class="built_in">abs</span>(index[belong[i]]-index[belong[j]])<span class="number">-1</span>,c=len-b<span class="number">-2</span>;</span><br><span class="line">                ans+=<span class="number">1.0</span>/(a+b+c)*(<span class="number">1</span>+<span class="number">1.0</span>*b/(a+c)+<span class="number">1.0</span>*c/(a+b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>probablities</tag>
        <tag>graphs</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT学习笔记</title>
    <url>/2020/01/29/fwt/</url>
    <content><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>给定长度为 <span class="math inline">\(2^n\)</span> 两个序列 <span class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>，设 <span class="math display">\[
C_i=\sum_{j\oplus k = i}A_j \times B_k
\]</span></p>
<p>分别当<span class="math inline">\(\oplus\)</span>是<span class="math inline">\(\text{or}\)</span>,<span class="math inline">\(\text{and}\)</span>和<span class="math inline">\(\text{xor}\)</span>时求出<span class="math inline">\(C\)</span></p>
<a id="more"></a>
<h3 id="什么是fwt">什么是FWT</h3>
<p>FWT（快速沃尔什变换）是一种类似FFT的优化卷积运算的算法，只不过卷积时下标由<span class="math inline">\(+\)</span>变成了位运算。类似FFT，我们需要找到一种变换方式，设<span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>为原序列，<span class="math inline">\(FWT(A)\)</span>，<span class="math inline">\(FWT(B)\)</span>变换后的序列，<span class="math inline">\(\otimes\)</span>为卷积运算，<span class="math inline">\(*\)</span>为对应下标相乘的运算，使得 <span class="math display">\[
FWT(A\otimes B)=FWTA*FWTB
\]</span> （想想FFT，通过变换为点值表达使得卷积运算可以变为对应下标相乘，两者实际上思想一样！）</p>
<p>接下来说一下如何实现</p>
<h4 id="or">OR</h4>
<p>设<span class="math inline">\(A\)</span>为原序列，<span class="math inline">\(FWT_A\)</span>为变换后序列，则有 <span class="math display">\[
FWT_A[i]=\sum\limits_{i|j=i}A[j]
\]</span> 考虑为什么是对的，我们考虑两个变换后的数组按位相乘后的结果 <span class="math display">\[
FWT_A[i]*FWT_B[i]=(\sum\limits_{i|j=i}A[j])*(\sum\limits_{i|k=i}B[k])\\
=\sum\limits_{i|(j|k)=i}A[j]*B[k]
\]</span> 这正是<span class="math inline">\(FWT_{A*B}\)</span>！</p>
<p>但是不能直接这么求，像FFT，我们是否可以把原序列分为两半，通过子问题的解合并出问题的解呢？是可以的，下面给出式子 <span class="math display">\[
FWT_A=
\begin{cases}
A &amp;     &amp;|A|=1\\
merge(FWT_{A_0},FWT_{A_0}+FWT_{A_1})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span></p>
<p>其中，<span class="math inline">\(merge\)</span>为把两个序列拼接起来（左面的序列拼合完成后下标较小），<span class="math inline">\(A_0\)</span>，<span class="math inline">\(A_1\)</span>分别为序列的前半部分（下标较小的部分）和后半部分，<span class="math inline">\(+\)</span>为对应下标的值相加。</p>
<p>考虑正确性，当<span class="math inline">\(|A|=1\)</span>时，显然只有这一个元素，当<span class="math inline">\(|A|\not =1\)</span>时，我们按下标的最高位分为<span class="math inline">\(0\)</span>与<span class="math inline">\(1\)</span>两部分，递归处理左右两边，再考虑这一位的影响，因为只有<span class="math inline">\(0|0=0\)</span>，所以<span class="math inline">\(0\)</span>只有自己的贡献，而<span class="math inline">\(0|1=1,1|1=1\)</span>，所以<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>都有贡献。</p>
<p>或者换种想法，最初定义<span class="math inline">\(FWT\)</span>的式子，如果我们把下标看作集合的状压表示，那么<span class="math inline">\(FWT_A[i]\)</span>实际上是<span class="math inline">\(i\)</span>所有子集对应值的和，我们按位相加时，保证除了最高位，其他低位都是相等的（低位的子集已经递归算过），所以我们只关注最高位，而这一位下标为0或者为1都是这一位为1的子集，所以右边是左右相加，而左边只有0是0的子集，所以只有左边一半。</p>
<p>接下来考虑逆变换，也就是把<span class="math inline">\(FWT\)</span>序列还原为原序列。其实很简单，就是解方程，下面直接给出式子，不做解释 <span class="math display">\[
IFWT_A=
\begin{cases}
FWT_A &amp;     &amp;|A|=1\\
merge(IFWT{A_0},IFWT{A_1}-IFWT{A_0})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span> 然后对于整个序列，<span class="math inline">\(IFWT_A\)</span>就是它自己了</p>
<p>下面是<span class="math inline">\(or\)</span>的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">1</span>)f[j+(len&gt;&gt;<span class="number">1</span>)]+=f[j],f[j+(len&gt;&gt;<span class="number">1</span>)]%=p;</span><br><span class="line">                <span class="keyword">else</span> f[j+(len&gt;&gt;<span class="number">1</span>)]+=(p-f[j]),f[j+(len&gt;&gt;<span class="number">1</span>)]%=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(p\)</span>是板子题的模数，op==1时是正变换，其它时为逆变换，采用像FFT一样的迭代实现</p>
<h4 id="and">AND</h4>
<p>and操作和or操作类似，下面只给出式子和代码 <span class="math display">\[
FWT_A[i]=\sum\limits_{i\&amp;j=i}A[j]
\]</span> <span class="math display">\[
FWT_A=
\begin{cases}
A &amp;     &amp;|A|=1\\
merge(FWT_{A_0+A_1},FWT_{A_0})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtand</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">1</span>)f[j]+=f[j+(len&gt;&gt;<span class="number">1</span>)],f[j]%=p;</span><br><span class="line">                <span class="keyword">else</span> f[j]+=(p-f[j+(len&gt;&gt;<span class="number">1</span>)]),f[j]%=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xor">XOR</h4>
]]></content>
      <tags>
        <tag>polynomial</tag>
        <tag>bitmasks</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2015」地震后的幻想乡</title>
    <url>/2020/01/21/%E3%80%8CZJOI2015%E3%80%8D%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
    <content><![CDATA[<p>给定一张无向图，边权在<span class="math inline">\([0,1]\)</span>之间随机均匀分布，求这张图的最小生成树边权最大值的期望。</p>
<a id="more"></a>
<p><span class="math inline">\(1\leqslant n\leqslant 10\)</span>，<span class="math inline">\(1\leqslant m\leqslant \frac{n(n-1)}{2}\)</span>（分别是点数与边数）</p>
<p>提示：对于<span class="math inline">\(n\)</span>个<span class="math inline">\([0,1]\)</span>之间的随机变量<span class="math inline">\(x1\)</span>,<span class="math inline">\(x2\)</span>,...,<span class="math inline">\(xn\)</span>，第<span class="math inline">\(k\)</span>小的那个的期望值是<span class="math inline">\(\frac{k}{n+1}\)</span>。</p>
<p>如果我们按照边权从小到大加入边，那么最下生成树边权的最大值也就是加入某一条边使得图恰好联通的那条边的权值。于是我们只需计算这张图是从小到大加了第<span class="math inline">\(i\)</span>条边后恰好联通的概率，记为<span class="math inline">\(P[i]\)</span>，则 <span class="math display">\[
ans=\sum\limits_{i=1}^{m}P[i]E[i]
\]</span> 其中<span class="math inline">\(E[i]\)</span>是这条边的边权期望，由提示我们知道<span class="math inline">\(E[i]=\frac{i}{m+1}\)</span>，那么 <span class="math display">\[
ans=\frac{1}{m+1}\sum\limits_{i=1}^m iP[i]\\
=\frac{1}{m+1}\sum\limits_{i=1}^m\sum\limits_{j=i}^mP[j]
\]</span> 我们设<span class="math inline">\(p[i]=\sum\limits_{j=i}^mP[j]\)</span>那么<span class="math inline">\(ans=\frac{1}{m+1}\sum\limits_{i=1}^m p[i]\)</span>，而<span class="math inline">\(p[i]\)</span>的意义是加入至少<span class="math inline">\(i\)</span>条边才联通的概率，这显然比<span class="math inline">\(P\)</span> 要好计算！</p>
<p>我们考虑如何计算<span class="math inline">\(p\)</span>，不难发现这等价于加了<span class="math inline">\(i-1\)</span>条边还没有联通的概率，可以用不连通方案数除以总方案数来计算概率。于是我们成功的把一个期望问题转化为了计数问题！</p>
<p>考虑状压计算方案，设<span class="math inline">\(f[i][s]\)</span>和<span class="math inline">\(g[i][s]\)</span>为当前点集为<span class="math inline">\(s\)</span>，内部连了<span class="math inline">\(i\)</span>条边，联通/不连通的方案数，那么有 <span class="math display">\[
f[i][s]+g[i][s]=\binom{size[s]}{i}\\
f[i][s]=\sum\limits_{j=0}^{i-1}\sum\limits_{t\subsetneqq s且r\in t}g[j][t]*\binom{size[s-t]}{i-j}
\]</span> 第一条，不连通+联通=总方案数，其中<span class="math inline">\(size[s]\)</span>为子图<span class="math inline">\(s\)</span>中的边数</p>
<p>第二条，<span class="math inline">\(r\)</span>是<span class="math inline">\(s\)</span>中的第一个点（其实可以是任何一个但是在枚举<span class="math inline">\(j\)</span>和<span class="math inline">\(t\)</span>中不能变），这样的话通过枚举这个点所在的连通块大小，可以不重不漏计算出所有不连通图的数量（连通图计数貌似有很多类似的trick，可惜我并没做过）</p>
<p>最后答案式子就不列了，直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">int</span> ss[<span class="number">46</span>],tt[<span class="number">46</span>],cnt[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line">ll f[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">46</span>],g[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">46</span>],c[<span class="number">46</span>][<span class="number">46</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ss[i],&amp;tt[i]),ss[i]--,tt[i]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;ss[j]))&amp;&amp;(i&amp;(<span class="number">1</span>&lt;&lt;tt[j])))cnt[i]++;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">45</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==(s&amp;(-s)))&#123;g[s][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> lowbit=(s&amp;(-s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=s&amp;(s<span class="number">-1</span>);t;t=s&amp;(t<span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(t&amp;lowbit))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[t];i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt[s^t];j++)</span><br><span class="line">                    f[s][i+j]+=g[t][i]*c[cnt[s^t]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[s];i++)g[s][i]=c[cnt[s]][i]-f[s][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)ans+=<span class="number">1.0</span>*f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]/c[cnt[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6Lf"</span>,ans/(m+<span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里更新方式和上面长得不太一样，但实际上是一个东西。复杂度为<span class="math inline">\(O(3^nm)\)</span></p>
]]></content>
      <tags>
        <tag>probabilities</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>K-Dtree学习笔记</title>
    <url>/2020/01/17/KDtree/</url>
    <content><![CDATA[<h3 id="什么是k-dtree">什么是K-Dtree</h3>
<blockquote>
<p>在计算机科学里，<strong>k-d树</strong>（ <strong>k-维树</strong>的缩写）是在<strong>k</strong>维欧几里德空间组织点的数据1结构。<strong>k-d</strong>树可以使用在多种应用场合，如多维键值搜索（例：范围搜寻及最邻近搜索）。<strong>k-d树</strong>是空间二分树（Binary space partitioning ）的一种特殊情况。</p>
</blockquote>
<a id="more"></a>
<hr />
<h3 id="如何构造k-dtree">如何构造K-Dtree</h3>
<h4 id="节点存储">节点存储</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,minx,miny,maxx,maxy;</span><br><span class="line">    node *ch[<span class="number">2</span>];</span><br><span class="line">    node (point a)</span><br><span class="line">    &#123;</span><br><span class="line">        x=minx=maxx=a.x;</span><br><span class="line">        y=miny=maxy=a.y;</span><br><span class="line">        ch[<span class="number">0</span>]=ch[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br></pre></td></tr></table></figure>
<p>可以看到代码是<strong>2-Dtree</strong>，没有使用一个数组存放每个维度的位置而是直接开了<strong>x</strong>和<strong>y</strong>两个变量。<strong>minx</strong>,<strong>miny</strong>,<strong>maxx</strong>,<strong>maxy</strong>存放了以这个节点为根的树中的点的覆盖范围，当维数增大时依然可以使用数组存放更加方便。<strong>ch[2]</strong>是儿子，这里使用了指针，也可使用数组。</p>
<h4 id="build函数">build函数</h4>
<p>参考当<span class="math inline">\(k=2\)</span>时的特殊数据结构——二叉查找树的构造方法，确定一个当前要排序的维度，对所有的数据以这一维排序，并递归到两边的数据继续这样的操作，直到只有一个点直接 return 。</p>
<p>如何确定当前划分维度？有三种方法：按顺序一维一维划分，rand()和按每维度方差。三种方法各有各的好处。</p>
<p>以下是一个rand划分的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dim)</span><span class="comment">//l和r为划分的点在序列中的位置，dim为当前划分的维度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        node* t=<span class="keyword">new</span> node(p[l]);<span class="comment">//这个点自己的信息</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    nth_element(p+l,p+mid,p+r,dim?cmpy:cmpx);<span class="comment">//找到区间内这一维的中位数，小于中位数的在左边，大于的在右边</span></span><br><span class="line">    node *t=<span class="keyword">new</span> node(p[mid]);</span><br><span class="line">    <span class="keyword">int</span> nxt=rand()%<span class="number">2</span>;<span class="comment">//rand划分</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;mid)t-&gt;ch[<span class="number">0</span>]=build(l,mid<span class="number">-1</span>,nxt);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)t-&gt;ch[<span class="number">1</span>]=build(mid+<span class="number">1</span>,r,nxt);</span><br><span class="line">    pushup(t);<span class="comment">//更新minx等数据</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造好的<strong>K-Dtree</strong>大概长这个样子：</p>
<p>待更新qwq</p>
]]></content>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1318 最大公约数与最小公倍数方程组</title>
    <url>/2020/01/17/qwq/</url>
    <content><![CDATA[<p>求解一个有趣的方程组，方程组有 <span class="math inline">\(N\)</span> 个未知正整数 <span class="math inline">\(x_0,x_1,x_2,...,x_{N-1}\)</span></p>
<p>方程组由 <span class="math inline">\(M\)</span> 个方程组成，方程只有两种类型：</p>
<p>1）<span class="math inline">\(\text{gcd}(x[i],x[j]) = G\)</span> ；其中， <span class="math inline">\(i\not= j\)</span> ，且 <span class="math inline">\(\text{gcd}(a,b)\)</span> 为正整数 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 的最大公约数的值</p>
<p>2）<span class="math inline">\(\text{lcm}(x[i],x[j]) = L\)</span> ；其中， <span class="math inline">\(i \not= j\)</span> ，且 <span class="math inline">\(\text{lcm}(c,d)\)</span> 为正整数 <span class="math inline">\(c\)</span> 与 <span class="math inline">\(d\)</span> 的最小公倍数的值</p>
<p>你需要判断这样一个方程组是否存在解，且 <span class="math inline">\(N\)</span> 个未知数都是正整数。</p>
<p>例如， <span class="math inline">\(N=4\)</span> ，有8个方程构成的方程组： $$ { <span class="math display">\[\begin{align}
&amp;\text{gcd}(x_0,x_1)=6\\

&amp;\text{lcm}(x_0,x_1)=12\\

&amp;\text{gcd}(x_1,x_2)=6\\

&amp;\text{lcm}(x_1,x_2)=12\\

&amp;\text{gcd}(x_2,x_3)=6\\

&amp;\text{lcm}(x_2,x_3)=12\\

&amp;\text{gcd}(x_3,x_0)=6\\

&amp;\text{lcm}(x_3,x_0)=12\\
\end{align}\]</span> . $$ 这个方程组是有解的，因为 <span class="math inline">\(x_0=x_2=6\)</span> 且 <span class="math inline">\(x_1=x_3=12\)</span> 就是它的一组解。</p>
<p>多组询问， <span class="math inline">\(T\leqslant10,n,m\leqslant200,L_i,G_i\leqslant10^9\)</span>。只需要回答解是否存在。</p>
<p>根据唯一分解定理，我们可以把 <span class="math inline">\(\text{gcd}(x,y)=G\)</span> 或者 <span class="math inline">\(\text{lcm}(x,y)=L\)</span> 这样的方程化为一些指数的 <span class="math inline">\(\min\max\)</span> 方程，我们对每个未知数的每个质因子的指数视作新的未知数，则方程就被划为了 <span class="math inline">\(\max(x,y)=a,\min(x&#39;,y&#39;)=b\)</span> 这样的形式，对每个新的未知数，我们开30个变量（因为指数最大是29） <span class="math inline">\(f[x][i],g[x][i]\)</span> 表示 <span class="math inline">\(x=i\)</span> 是否成立（网上也有题解表示的是 <span class="math inline">\(x\leqslant i\)</span> 是否成立，都可以做）这样的话对于每个方程我们就转化为了01变量的满足性问题，可以使用2-SAT求解。</p>
]]></content>
      <tags>
        <tag>graphs</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2014」力</title>
    <url>/2019/12/29/%E3%80%8CZJOI2014%E3%80%8D%E5%8A%9B/</url>
    <content><![CDATA[<p>给出n个数<span class="math inline">\(q_i\)</span>，给出<span class="math inline">\(F_j\)</span>的定义如下： <span class="math display">\[
F_j = \sum_{i&lt;j}\frac{q_i q_j}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i q_j}{(i-j)^2 }
\]</span></p>
<p>令<span class="math inline">\(E_i=\frac{F_i}{q_i}\)</span>，求<span class="math inline">\(E_i\)</span></p>
<a id="more"></a>
<p><span class="math display">\[
E_j=\sum_{i&lt;j}\frac{q_i}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i}{(i-j)^2 }
\]</span></p>
<p>设<span class="math inline">\(f[i]=q[i],g[i]=\frac{1}{i^2}\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i&lt;j}f[i]g[j-i]-\sum\limits_{i&gt;j}f[i]g[i-j]\\
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=j+1}^nf[i]g[i-j]
\]</span> 设<span class="math inline">\(f&#39;[i]=f[n-i+1]\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=1}^{n-j}f&#39;[i]g[j-i]
\]</span> 直接卷积就好</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> +(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r+y.r,x.i+y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> -(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r-y.r,x.i-y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> *(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r&#125;;&#125;</span><br><span class="line">&#125;q[<span class="number">400005</span>],qq[<span class="number">400005</span>],f[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp* f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        comp wn=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*pi/len),op*<span class="built_in">sin</span>(<span class="number">2</span>*pi/len)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            comp w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                comp d=f[j+q]*w;</span><br><span class="line">                f[j+q]=f[j]-d;</span><br><span class="line">                f[j]=f[j]+d;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;q[i].r),qq[n-i+<span class="number">1</span>].r=q[i].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i].r=(((<span class="keyword">double</span>)<span class="number">1.0</span>)/(<span class="keyword">double</span>)i/(<span class="keyword">double</span>)i);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    getrev(len);</span><br><span class="line">    fft(q,len,<span class="number">1</span>),fft(qq,len,<span class="number">1</span>),fft(f,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)q[i]=q[i]*f[i],qq[i]=qq[i]*f[i];</span><br><span class="line">    fft(q,len,<span class="number">-1</span>),fft(qq,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>,(q[i].r-qq[n-i+<span class="number">1</span>].r)/len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>polynomials</tag>
      </tags>
  </entry>
  <entry>
    <title>csp2019游记</title>
    <url>/2019/12/29/csp2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>咕咕咕了一个多月的游记qwq</p>
<a id="more"></a>
<h3 id="day-8">Day-8</h3>
<p>期中考完了开始快乐的停课生活qwq</p>
<h3 id="day0">Day0</h3>
<p>如果没有记错的话下午到了秦皇岛，试完机后就去酒店放行李（其实就两个包），晚上和同机房的同学们一起去吃了酸菜鱼（味道还不错qwq），本来还想吃冰激淋的可是想到去年noip的惨痛经历就忍住了没吃。回到酒店开始颓Terraria。晚上本来和我一个房间的AlanSP去找家长住了，第一次一个人睡双人间。自我感觉良好。</p>
<h3 id="day1">Day1</h3>
<p>不喜欢吃酒店的早餐，简单吃了点找别人借了本李煜东看了会exgcd和exbsgs，然后就去燕大了。</p>
<p>到考场上丝毫不慌，反正我退役稳了，然后就一直盯着前面的表看时间。</p>
<p>终于开考了，一遍输对了密码（据说有人输了三遍才对）。先看一遍题，感觉不是很难的样子，于是就以正常顺序开题。T1不是**题嘛，花5分钟写好结果大样例过不去，调了10分钟才发现写的是1而不是1ull，在此之前还发现输出锅了，还好我记得 <code>unsigned long long</code> 输出是 <code>%llu</code> （其实也可以用cout的）。大概在开考后30分钟过了大样例然后造了一下64 2^64-1没有问题就封题了。</p>
<p>T2第一眼看眼前一亮，前两天模拟赛不是考过合法括号序列嘛，所以”很快“的码完了，但中间 windows 下爆栈了，不慌不忙开了虚拟机，果然在 linux 下就没啥问题，顺便也把T1又测了一下，过了114514后就封题了（我考场上竟然没看出来114514）。</p>
<p>还有将近两个小时，我过不了T3，这个T3长得这么水，我要是过不了，我当场！就把这个电脑屏幕吃掉！</p>
<p>1 hour left：woc我觉得不行，先把10分暴力打了，看看能不能把链和菊花图做了</p>
<p>45 mins left：我想到链怎么做了！开始码！</p>
<p>20 mins left： woc怎么一直RE，dev的调试功能是什么毒瘤（我之前看了gdb怎么用但是考场上一慌就忘了）。</p>
<p>10 mins left： 标准结局，自闭了。封题检查文件。</p>
<p>出考场问了问其他人，大概都是100+100+10？感觉是个大众分鸭，今年说不定能上400呢。</p>
<p>颓了一下午和一晚上，我昨天跟AlanSP说要打过亵渎天神，晚上又是我一个人睡的，不知道为什么感觉走廊有人走路，有点吓人。</p>
<h3 id="day2">Day2</h3>
<p>自闭日。</p>
<p>先看了一遍题，感觉T1最不可做？？？（出考场后发现读题出锅了）然后T3 送了40分就先码完了40。接着自闭了一个小时来回看三道题都觉得不可做。大概还剩1个小时10分钟想了下并码了T2的 <span class="math inline">\(n^3\)</span>，发现可以二分转移就优化到了<span class="math inline">\(n^2\log n\)</span>，这个时候大概还剩25分钟，赶紧码了T1爆搜结果样例2过不去？？？调了10分钟没出来，然后就彻底自闭了。最后还剩下5分钟只得放弃，开始建文件夹。</p>
<p>出了考场发现其他人都比我高（，自闭了，Eta估分100+64+55，jiqimao神仙切了两道，然后就在遗憾中回了学校。</p>
<p>估分100+100+10+0+64+40</p>
<p>最后得分100+80+10+8+64+40，D1T2没来longlong见祖宗/(ㄒoㄒ)/~~，差了8分进WC，还好我这种菜鸡进了也是爆零，也没有太大遗憾。jiqimao神仙HE rank2 orz。</p>
<p>感觉这次败在了D2T1上，要多做做DP了（</p>
]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>bsgs</title>
    <url>/2019/12/26/bsgs-exbsgs/</url>
    <content><![CDATA[<h3 id="bsgs">BSGS</h3>
<p>求<span class="math inline">\(a^x\equiv b\space( \mod p)\)</span> 的解，保证<span class="math inline">\(gcd(a,p)=1\)</span>。</p>
<a id="more"></a>
<p>我们设<span class="math inline">\(x=i*m-j\)</span> ，其中<span class="math inline">\(0\leqslant j &lt;m\)</span> 。那么原式可转化为<span class="math inline">\(a^{im}\equiv b*a^j\pmod p\)</span>的解。我们预处理出<span class="math inline">\(b*a^0,b*a^1,...,b*a^{m-1}\)</span>的值，将它们存入哈希表中，枚举<span class="math inline">\(i\)</span>的值，每次查看<span class="math inline">\(a^{im}\)</span>在表中是否出现。</p>
<p>由费马小定理可知，等号左边是有循环节<span class="math inline">\(p-1\)</span>的，所以只需要从<span class="math inline">\(1\)</span>到<span class="math inline">\(\frac{p}{m}\)</span>枚举<span class="math inline">\(i\)</span> ，则不包含哈希表的时间复杂度在当<span class="math inline">\(m=\lceil\sqrt{n}\rceil\)</span>时最优，为<span class="math inline">\(O(\sqrt{p})\)</span>，在实际中常使用<code>std::map</code>作为哈希表，时间复杂度为<span class="math inline">\(O(\sqrt p\log_2p)\)</span></p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(ll a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>((<span class="keyword">double</span>)p));</span><br><span class="line">    mp.clear();</span><br><span class="line">    ll now=<span class="number">1</span>,t=pw(a,m,p);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++)mp[b*now%p]=i,now*=a,now%=p;</span><br><span class="line">    now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now*=t,now%=p;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(now))&#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,i*m-mp[now]);<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exbsgs">EXBSGS</h3>
]]></content>
      <tags>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/2019/12/22/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<h4 id="多项式求逆乘法逆">多项式求逆（乘法逆）</h4>
<p>给定 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> ，求出 <span class="math inline">\(G(x)\)</span> 使得 <span class="math inline">\(F(x)G(x)\equiv1\pmod{x^n}\)</span></p>
<p>首先， <span class="math inline">\(F(x)\)</span> 在系数模质数有逆元的充要条件是 <span class="math inline">\(F(0)\not=0\)</span> ，即常数项 <span class="math inline">\([x^0]F(x)\)</span> 不为 <span class="math inline">\(0\)</span> 。必要性显然因为常数项怎么乘都是 <span class="math inline">\(0\)</span> ，接下来的构造方式证明了这也是充分条件。</p>
<p>我们先考虑朴素的构造方式，假设我们已知 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的值，那么我们算出其与 <span class="math inline">\(F(x)\)</span> 的乘积，设此时 <span class="math inline">\(m+1\)</span> 次项的系数为 <span class="math inline">\(a\)</span> ，那么 <span class="math inline">\(F(0)[x^{m+1}]G(x)=a\)</span> ，因为 <span class="math inline">\(F(0)\not=0\)</span> ，所以 <span class="math inline">\(F(0)\)</span> 在模 <span class="math inline">\(p\)</span> 意义下存在逆元，所以 <span class="math inline">\([x^{m+1}]G(x)=a*(F(0))^{-1}\)</span> ，这样我们每一次可以计算出一项直到 <span class="math inline">\(n\)</span> 项，利用 NTT 复杂度为 <span class="math inline">\(O(n^2\log n)\)</span> 。</p>
<p>我们考虑已知 <span class="math inline">\(m\)</span> 项的情况下是否能得到更多项的系数，而不是只推出了后一项。我们考虑倍增，设 <span class="math inline">\(H(x)\)</span> 为 <span class="math inline">\(G(x)\mod x^m\)</span> ，即只含有 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的多项式。 <span class="math display">\[
F(x)G(x)\equiv 1\pmod{x^m}\\
F(x)H(x)\equiv 1\pmod{x^m}\\
F(x)(G(x)-H(x))\equiv 0\pmod{x^m}
\]</span> 由于 <span class="math inline">\(F(x)\not\equiv 0\)</span>，故 <span class="math display">\[
G(x)-H(x)\equiv 0\pmod{x^m}
\]</span></p>
<p>两边同时平方 <span class="math display">\[
(G(x)-H(x))^2\equiv0\pmod{x^{2m}}
\]</span> 平方使得这里的精度（即模的指数）提升了一倍 （ 因为 <span class="math inline">\(x^m\)</span> 以下的项都为 <span class="math inline">\(0\)</span> ， <span class="math inline">\(x^m\)</span> 以上的项只能和 <span class="math inline">\(x^m\)</span> 以上的项相乘，这样指数是大于等于 <span class="math inline">\(2m\)</span> 的） ，这也是能倍增的原因。</p>
<p>接下来将括号展开 <span class="math display">\[
G^2(x)-2G(x)H(x)+H^2(x)\equiv 0\pmod{x^{2m}}
\]</span> 两边同乘 <span class="math inline">\(F(x)\)</span> <span class="math display">\[
F(x)G^2(x)-2F(x)G(x)H(x)+F(x)H^2(x)\equiv 0\pmod{x^{2m}}
\]</span> 由于 <span class="math inline">\(2m&lt;n\)</span> （大于的时候就不用求了），故 <span class="math inline">\(F(x)G(x)\equiv 1\pmod{x^{2m}}\)</span> <span class="math display">\[
G(x)-2H(x)+F(x)H^2(x)\equiv 0\pmod{x^{2m}}\\
G(x)\equiv 2H(x)-F(x)H^2(x)\pmod{x^{2m}}
\]</span> 所以我们只需要用三次 NTT 就可以把项数提高一倍，实际操作一般从上到下求，具体见代码。</p>
<h4 id="分治fft">分治FFT</h4>
<p>给定数组<span class="math inline">\(g[1],...,g[n-1]\)</span>，求<span class="math inline">\(f[0],...,f[n-1]\)</span>，其中 <span class="math display">\[
f[i]=\sum\limits_{j=1}^i{f[i-j]g[j]}\\f[0]=1
\]</span> 在模<span class="math inline">\(998244353\)</span>意义下进行</p>
<p>考虑分治，先计算左半边，再计算左对右贡献，最后计算右半边，复杂度<span class="math inline">\(O(Nlog^2N)\)</span></p>
<p>也可以求逆解决，设 <span class="math display">\[
F(x)=\sum\limits_{i=0}^{n-1}f[i]x^i\\G(x)=\sum\limits_{i=0}^{n-1}g[i]x^i
\]</span> 其中，<span class="math inline">\(g[0]=0\)</span></p>
<p>对其卷积（在<span class="math inline">\(\mod x^n\)</span>意义下进行） <span class="math display">\[
F(x)G(x)\sum\limits_{k=0}^{n-1}\sum\limits_{i+j=k}f[i]g[j]x^k\\
F(x)G(x)=\sum\limits_{k=0}^{n-1}f[k]x^k-f[0]\\
F(x)G(x)=F(x)-f[0]\\
F(x)(G(x)-1)=-f[0]\\
F(x)=\frac{f[0]}{1-G(x)}
\]</span> （第二行是因为<span class="math inline">\(g[0]=0\)</span>,所以<span class="math inline">\(f[0]g[0]=0\)</span>）由于<span class="math inline">\(f[0]=1\)</span>，求逆就好了，复杂度<span class="math inline">\(O(NlogN)\)</span></p>
<h4 id="多项式-ln">多项式 <span class="math inline">\(\ln\)</span></h4>
<p>求<span class="math inline">\(B(x)\)</span>使得 <span class="math display">\[
B(x)\equiv \ln A(x) \pmod {x^n}
\]</span> 设 <span class="math display">\[
G(x)=\ln(x)
\]</span></p>
<p><span class="math display">\[
B(x)\equiv G(A(x))\pmod {x^n}
\]</span></p>
<p>两边同时求导得 <span class="math display">\[
B&#39;(x)\equiv G&#39;(A(x))A&#39;(x)\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B&#39;(x)\equiv \frac{A&#39;(x)}{A(x)}\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B(x) \equiv \int \frac{A&#39;(x)}{A(x)}dx\pmod {x^n}
\]</span></p>
<p>多项式求导，求逆，积分即可</p>
<p>注：</p>
<p><span class="math display">\[
A&#39;(x)=\sum\limits_{i=1}^{n-1}ia_ix^{i-1}
\]</span></p>
<p><span class="math display">\[
\int A(x)dx=\sum\limits_{i=0}^{n-1}\frac{a_{i}}{i+1}x^{i+1}
\]</span></p>
<h4 id="多项式除法和取模">多项式除法和取模</h4>
<p>首先，已知 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)=\sum\limits_{i=0}^nf_ix^i\)</span> ，则 <span class="math inline">\(x^nF(\frac{1}{x})=F_r(x)\)</span> ，其中 <span class="math inline">\(F_r(x)=\sum\limits_{i=0}^nf_{n-i}x^i\)</span> ，即将 <span class="math inline">\(F(x)\)</span> 系数翻转后的多项式。</p>
<p>现在，给定 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(m\)</span> 次多项式 <span class="math inline">\(G(x)\)</span> <span class="math inline">\((n&gt;m)\)</span> ，求出 <span class="math inline">\(n-m\)</span> 次多项式 <span class="math inline">\(Q(x)\)</span> 和次数小于 <span class="math inline">\(m\)</span> 的多项式 <span class="math inline">\(R(x)\)</span> 使得 <span class="math inline">\(F(x)=G(x)Q(x)+R(x)\)</span></p>
<p>首先两边同乘 <span class="math inline">\(x^n\)</span></p>
<p>则有 <span class="math display">\[
x^nF(x)=x^mG(x)x^{n-m}Q(x)+x^{n-m}x^mR(x)
\]</span> 将 <span class="math inline">\(x\)</span> 替换为 <span class="math inline">\(\frac{1}{x}\)</span> <span class="math display">\[
x^nF(\frac{1}{x})=x^mG(\frac{1}{x})x^{n-m}Q(\frac{1}{x})+x^{n-m}x^mR(\frac{1}{x})
\]</span> 套用上面的公式 <span class="math display">\[
F_r(x)=G_r(x)Q_r(x)+x^{n-m}R_r(x)
\]</span> 我们发现 <span class="math inline">\(Q_r(x)\)</span> 刚好是 <span class="math inline">\(n-m\)</span> 次多项式所以两边对 <span class="math inline">\(x^{n-m}\)</span> 取模以消掉 <span class="math inline">\(R_r(x)\)</span> 这一项 <span class="math display">\[
F_r(x)\equiv G_r(x)Q_r(x)\pmod{x^{n-m}}
\]</span> 所以我们只需要求出 <span class="math inline">\(G_r(x)\)</span> 的逆元，再与 <span class="math inline">\(F_r(x)\)</span> 相乘就得到了 <span class="math inline">\(Q_r(x)\)</span> ，在利用定义计算出 <span class="math inline">\(R(x)\)</span></p>
]]></content>
      <tags>
        <tag>polynomials</tag>
        <tag>combinatorics</tag>
      </tags>
  </entry>
</search>
