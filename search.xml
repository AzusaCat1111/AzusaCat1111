<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARC104 简要题解</title>
    <url>/2020/10/08/ARC104%20%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>A,B 题解被吃了。</p>
]]></content>
      <tags>
        <tag>套题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1408I Bitwise Magic</title>
    <url>/2020/10/02/CF1408I%20Bitwise%20Magic/</url>
    <content><![CDATA[<p>给定 <span class="math inline">\(n,k,c\)</span>，以及长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>（保证元素互不相同）。</p>
<p>操作 <span class="math inline">\(k\)</span> 次，每次随机选择一个 <span class="math inline">\(a_i\)</span>，然后将其 <span class="math inline">\(−1\)</span>。</p>
<p>对于 <span class="math inline">\(x=0,1\dots2^c−1\)</span> 输出最后序列的异或和为 <span class="math inline">\(x\)</span> 的概率。</p>
<p>答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(k,c\leqslant 16\)</span>，<span class="math inline">\(a_i\in[k,2^c)\)</span>，<span class="math inline">\(n\leqslant 2^c−k\)</span>。</p>
<a id="more"></a>
<p>首先有一个结论，对 <span class="math inline">\(x\in[k,2^c)\)</span>，<span class="math inline">\(k\)</span> 元组 <span class="math inline">\((x\oplus (x-1),x\oplus(x-2),\dots,x\oplus(x-k))\)</span> 只有 <span class="math inline">\(O(kc)\)</span> 种本质不同的情况，当 <span class="math inline">\(k=c=16\)</span> 时，有 <span class="math inline">\(192\)</span> 种。</p>
<p>我们考虑证明。我们发现，<span class="math inline">\(x\oplus(x-1)\)</span> 等于把 <span class="math inline">\(x\)</span> 在二进制下最低位的 <span class="math inline">\(1\)</span> 变为 <span class="math inline">\(0\)</span>，比它更低的位变为 <span class="math inline">\(1\)</span>。我们设 <span class="math inline">\(t=\log \text{lowbit}(x)\)</span>。</p>
<ul>
<li>当 <span class="math inline">\(t&gt;\log k\)</span> 时，我们发现 <span class="math inline">\(x\oplus(x-1),x\oplus(x-2),\dots,x\oplus(x-k)\)</span> 这些数比第 <span class="math inline">\(t\)</span> 位高的地方都是 <span class="math inline">\(0\)</span>，且比第 <span class="math inline">\(t\)</span> 位低的地方与 <span class="math inline">\(x\)</span> 无关（因为都是从全 <span class="math inline">\(1\)</span> 开始减的），这一部分有 <span class="math inline">\(O(c)\)</span> 种。</li>
<li>当 <span class="math inline">\(t\leqslant \log k\)</span> 时，我们设 <span class="math inline">\(r\)</span> 为 <span class="math inline">\(x\)</span> 比 <span class="math inline">\(\lfloor\log k\rfloor\)</span> 高的第一个为 <span class="math inline">\(1\)</span> 的位，则 <span class="math inline">\(r\)</span> 以上的位都为 <span class="math inline">\(0\)</span>，而 <span class="math inline">\(r\)</span> 以下的位的情况只与后 <span class="math inline">\(\log k\)</span> 位的情况有关，所以这一部分一共有 <span class="math inline">\(O(c2^{\log k})=O(ck)\)</span> 种。</li>
</ul>
<p>设 <span class="math inline">\(d_{i,j}=a_i\oplus(a_i-j)\)</span>，我们考虑枚举答案分别关于结果和操作次数的二元 EGF，则有 <span class="math display">\[
F(x,y)=\prod\limits_{i=1}^n(\sum\limits_{j=0}^k \frac{x^{d_{i,j}}y^j}{j!})
\]</span> 其中 <span class="math inline">\(x\)</span> 维是异或卷积，<span class="math inline">\(y\)</span> 维为加法卷积。则 <span class="math inline">\(q![x^p][y^q]F(x,y)\)</span> 就是 <span class="math inline">\(q\)</span> 次操作后结果为 <span class="math inline">\(p\oplus a_1\oplus a_2\oplus\dots\oplus a_n\)</span> 的方案数。</p>
<p>我们现在考虑计算出这个多项式，我们先计算每种本质不同的 <span class="math inline">\(k\)</span> 元组的出现次数，设 <span class="math inline">\(G_i(x,y)\)</span> 为第 <span class="math inline">\(i\)</span> 种本质不同的 <span class="math inline">\(k\)</span> 元组的 EGF，<span class="math inline">\(r_i\)</span> 为其出现次数，则 <span class="math inline">\(F(x,y)=\prod G_i^{r_i}(x,y)\)</span>，如果我们对每一种 <span class="math inline">\(k\)</span> 元组都做 <span class="math inline">\(O(k^2)\)</span> 的暴力 <span class="math inline">\(\ln,\exp\)</span> 来多项式快速幂（牛顿迭代由于常数大可能会更慢），这样的总复杂度是 <span class="math inline">\(O(2^cck^3)\)</span> 的。</p>
<p>我们发现，如果我们对某个 <span class="math inline">\(k\)</span> 元组固定 <span class="math inline">\(y\)</span>，再对 <span class="math inline">\(x\)</span> 做 FWT，此时做 FWT 的序列一定形如只有一项为 <span class="math inline">\(\dfrac{y^j}{j!}\)</span>，其余项都为 <span class="math inline">\(0\)</span>。</p>
<p>我们考虑 FWT 的定义式：<span class="math inline">\(\hat{a}_i=\sum\limits_j(-1)^{\text{popcount}(i\&amp;j)}a_j\)</span>。如果我们认为当前序列只有一个元素 <span class="math inline">\(a_j\)</span> 是 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(\hat{a}_i=(-1)^{\text{popcount}(i\&amp;j)}\)</span>。所以，对于 <span class="math inline">\(y^j\)</span> 来说，FWT 后任何一个 <span class="math inline">\(x\)</span> 都只可能是 <span class="math inline">\(\pm\dfrac{y^j}{j!}\)</span>。</p>
<p>而对于一个 <span class="math inline">\(k\)</span> 元组做完所有 FWT 后，其关于 <span class="math inline">\(x\)</span> 的某一位可以表示为一个长为 <span class="math inline">\(k+1\)</span> 的 <span class="math inline">\(\pm 1\)</span> 序列，序列的每一位表示 <span class="math inline">\(\dfrac{y^j}{j!}\)</span> 的正负。我们注意到，如果两个 <span class="math inline">\(x\)</span> 相同的多项式对应的 <span class="math inline">\(\pm1\)</span> 序列也相同，则我们只需要把它们的指数加到一起然后一起做快速幂，这样能够显著减少 <span class="math inline">\(\ln,\exp\)</span> 次数。</p>
<p>代码（卡着时限过的）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> count __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">65537</span>],iv[<span class="number">65537</span>],b[<span class="number">65537</span>],sum[<span class="number">195</span>],inv[<span class="number">65537</span>],cnt[<span class="number">131075</span>],</span><br><span class="line">st[<span class="number">195</span>],top,tmp[<span class="number">20</span>],tmp2[<span class="number">20</span>],tmp3[<span class="number">20</span>],f[<span class="number">65537</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp4[<span class="number">20</span>];</span><br><span class="line">vec v[<span class="number">65537</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;vec,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getexp</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> n)</span><span class="comment">//x^0-x^&#123;n-1&#125;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i]=<span class="number">0</span>;f[i]=<span class="number">1l</span>l*f[i]*i%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            g[i]=(g[i]+<span class="number">1l</span>l*f[j+<span class="number">1</span>]*g[i-j<span class="number">-1</span>])%p;</span><br><span class="line">        g[i]=<span class="number">1l</span>l*g[i]*iv[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getln</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            g[i]=(g[i]+<span class="number">1l</span>l*f[j]*g[i-j])%p;</span><br><span class="line">        g[i]=(<span class="number">1l</span>l*i*f[i]+p-g[i])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)g[i]=<span class="number">1l</span>l*g[i]*iv[i]%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iv[<span class="number">1</span>]=inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">65536</span>;i++)iv[i]=<span class="number">1l</span>l*(p-p/i)*iv[p%i]%p,inv[i]=<span class="number">1l</span>l*inv[i<span class="number">-1</span>]*iv[i]%p;</span><br><span class="line">    <span class="keyword">int</span> n,K,c,xorsum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;K,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),xorsum^=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=K;j++)</span><br><span class="line">            v[i].pb(a[i]^(a[i]-j));</span><br><span class="line">        mp[v[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,fac=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> r:mp)t++,v[t]=r.first,sum[t]=r.second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=K;i++)fac=<span class="number">1l</span>l*fac*i%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;c);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=K;j++)</span><br><span class="line">                d|=((count(s&amp;v[i][j])&amp;<span class="number">1</span>)&lt;&lt;j);</span><br><span class="line">            <span class="keyword">if</span>(!cnt[d])st[++top]=d;</span><br><span class="line">            cnt[d]+=sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">        tmp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=K;j++)</span><br><span class="line">                <span class="keyword">if</span>(st[i]&amp;(<span class="number">1</span>&lt;&lt;j))tmp2[j]=p-inv[j];</span><br><span class="line">                <span class="keyword">else</span> tmp2[j]=inv[j];</span><br><span class="line">            getln(tmp2,tmp3,K+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=K;j++)tmp3[j]=<span class="number">1l</span>l*tmp3[j]*cnt[st[i]]%p;</span><br><span class="line">            getexp(tmp3,tmp2,K+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(tmp4,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp4));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=K;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=K-j;k++)</span><br><span class="line">                    tmp4[j+k]+=<span class="number">1l</span>l*tmp2[j]*tmp[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=K;j++)tmp[j]=tmp4[j]%p;</span><br><span class="line">            cnt[st[i]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        f[s]=<span class="number">1l</span>l*tmp[K]*fac%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=(<span class="number">1</span>&lt;&lt;c);len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;c);i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=f[j];</span><br><span class="line">                f[j]=mod(f[j]+f[j+(len&gt;&gt;<span class="number">1</span>)]);</span><br><span class="line">                f[j+(len&gt;&gt;<span class="number">1</span>)]=mod(t-f[j+(len&gt;&gt;<span class="number">1</span>)]+p);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">1l</span>l*pw(<span class="number">1</span>&lt;&lt;c,p<span class="number">-2</span>)*pw(n,p<span class="number">-1</span>-K)%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;c);i++)<span class="built_in">printf</span>(<span class="string">"%lld "</span>,<span class="number">1l</span>l*f[i^xorsum]*d%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>「清华集训2017」生成树计数</title>
    <url>/2020/09/27/%E3%80%8C%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E3%80%8D%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4002" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<h4 id="前置知识求数列幂和">前置知识：求数列幂和</h4>
<p>给定数列 <span class="math inline">\(\{a_n\}\)</span>，对 <span class="math inline">\(0\leqslant t \leqslant k\)</span>，求 <span class="math inline">\(\sum\limits_{i=1}^na_i^t\)</span>，<span class="math inline">\(n,t\leqslant 10^5\)</span>。</p>
<p>我们写出幂次和对应的生成函数 <span class="math inline">\(F(x)\)</span> <span class="math display">\[
\begin{aligned}
F(x)=&amp;\sum\limits_{t=0}\left(\sum\limits_{i=1}^na_i^t\right)x^t\\
=&amp;\sum\limits_{i=1}^n\sum\limits_{t=0}a_i^tx^t\\
=&amp;\sum\limits_{i=1}^n\frac{1}{1-a_ix}
\end{aligned}
\]</span> 然后我们考虑 <span class="math inline">\(G(x)=\sum\limits_{i=1}^n\left(\ln(1-a_ix)\right)&#39;\)</span>，化简则有 <span class="math display">\[
\begin{aligned}
G(x)=&amp;\sum\limits_{i=1}^n\left(\ln(1-a_ix)\right)&#39;\\
=&amp;-\sum\limits_{i=1}^n\frac{a_i}{1-a_ix}\\
=&amp;-\sum\limits_{t=0}\sum\limits_{i=1}^na_i^{t+1}x^t
\end{aligned}
\]</span> 如果我们能求得 <span class="math inline">\(G(x)\)</span>，则很好就能求出 <span class="math inline">\(F(x)\)</span>。同时发现 <span class="math display">\[
\begin{aligned}
G(x)=&amp;\sum\limits_{i=1}^n\left(\ln(1-a_ix)\right)&#39;\\
=&amp;\left(\sum\limits_{i=1}^n\ln(1-a_ix)\right)&#39;\\
=&amp;\left(\ln(\prod\limits_{i=1}^n(1-a_ix))\right)&#39;
\end{aligned}
\]</span> <span class="math inline">\(\prod\limits_{i=1}^n(1-a_ix)\)</span> 可以通过分治+NTT 计算，然后求个 <span class="math inline">\(\ln\)</span> 再求导就好了。复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<p>然后我们考虑这道题。</p>
<p>显然，我们可以把每一个连通块看成一个点，然后只需要考虑连通块的连接方式，每连接一条边额外乘上连通块大小即可。</p>
<p>我们考虑枚举 prufer 序列，如果一个数在 prufer 序列中出现了 <span class="math inline">\(d\)</span> 次，则其的度数为 <span class="math inline">\(d+1\)</span>。</p>
<p>那么我们考虑枚举每个点在 prufer 序列中出现的次数 <span class="math inline">\(d_i\)</span>，则我们有 <span class="math display">\[
\begin{aligned}
ans=&amp;\sum\limits_{\sum d=n-2}(n-2)!\left(\prod_{i=1}^n(d_i+1)^m\right)\left(\sum_{i=1}^n(d_i+1)^m\right)\left(\prod_{i=1}^n\frac{a_i^{d_i+1}}{d_i!}\right)\\
=&amp;(n-2)!\prod_{i=1}^na_i\sum\limits_{\sum d=n-2}\left(\prod_{i=1}^n\frac{a_i^{d_i}}{d_i!}(d_i+1)^m\right)\left(\sum_{i=1}^n(d_i+1)^m\right)
\end{aligned}
\]</span> 前面两项是定值，我们先不管。我们考虑后面那个东西，它等价于 <span class="math display">\[
\sum\limits_{\sum d=n-2}\sum\limits_{i=1}^n\frac{a_i^{d_i}}{d_i!}(d_i+1)^{2m}\prod\limits_{j\not=i}\frac{a_j^{d_j}}{d_j!}(d_j+1)^m
\]</span> 我们考虑构造两个多项式 <span class="math inline">\(A(x)=\sum\limits_{i}\dfrac{(i+1)^{2m}x^i}{i!},B(x)=\sum\limits_{i}\dfrac{(i+1)^mx^i}{i!}\)</span>，设答案关于 <span class="math inline">\(\sum d\)</span> 的生成函数为 <span class="math inline">\(F(x)\)</span>，则有 <span class="math display">\[
\begin{aligned}
F(x)&amp;=\sum\limits_{i=1}^nA(a_ix)\prod\limits_{j\not=i}B(a_jx)\\
&amp;=\sum\limits_{i=1}^n\frac{A(a_ix)}{B(a_ix)}\prod_{j=1}^n
B(a_jx)\\
&amp;=\sum\limits_{i=1}^n\frac{A(a_ix)}{B(a_ix)}\exp\left(\sum\limits_{j=1}^n\ln(B(a_jx))\right)
\end{aligned}
\]</span> 如果我们求出了 <span class="math inline">\(\dfrac{A(x)}{B(x)}\)</span> 与 <span class="math inline">\(\ln(B(x))\)</span>，我们只需要每一项的系数乘上 <span class="math inline">\(\sum\limits_{i=1}^na_i^t\)</span> 即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> polynomials</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>,g=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> w[N],iv[N],r[N],last;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">            x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">            y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;n)lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        iv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=lim;i++)iv[i]=mod(p<span class="number">-1l</span>l*(p/i)*iv[p%i]%p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wn=pw(g,(p<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,ww=<span class="number">1</span>;j&lt;i;j++,ww=<span class="number">1l</span>l*ww*wn%p)w[i+j]=ww;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(vec &amp;f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=f[j+k],y=<span class="number">1l</span>l*f[i+j+k]*w[i+k]%p;</span><br><span class="line">                f[j+k]=mod(x+y);f[i+j+k]=mod(x-y+p);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(&amp;f[<span class="number">1</span>],&amp;f[n]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i]=<span class="number">1l</span>l*f[i]*iv[n]%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(vec f,vec &amp;g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> vec x;</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=pw(f[<span class="number">0</span>],p<span class="number">-2</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        getinv(f,g,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;(n&lt;&lt;<span class="number">1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        x.resize(lim);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)x[i]=f[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;lim;i++)x[i]=<span class="number">0</span>;</span><br><span class="line">        g.resize(lim);</span><br><span class="line">        ntt(x,lim,<span class="number">1</span>),ntt(g,lim,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)g[i]=<span class="number">1l</span>l*g[i]*(<span class="number">2</span><span class="number">-1l</span>l*g[i]*x[i]%p+p)%p;</span><br><span class="line">        ntt(g,lim,<span class="number">-1</span>);</span><br><span class="line">        g.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getln</span><span class="params">(vec f,vec &amp;g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> vec x;</span><br><span class="line">        getinv(f,x,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)f[i]=<span class="number">1l</span>l*f[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">        f[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;((n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ntt(f,lim,<span class="number">1</span>),ntt(x,lim,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)x[i]=<span class="number">1l</span>l*x[i]*f[i]%p;</span><br><span class="line">        ntt(x,lim,<span class="number">-1</span>);</span><br><span class="line">        g.resize(n);</span><br><span class="line">        g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)g[i]=<span class="number">1l</span>l*x[i<span class="number">-1</span>]*iv[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getln</span><span class="params">(vec f,vec &amp;g,vec &amp;h,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> vec x;</span><br><span class="line">        getinv(f,x,n);h=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)f[i]=<span class="number">1l</span>l*f[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">        f[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;((n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ntt(f,lim,<span class="number">1</span>),ntt(x,lim,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)x[i]=<span class="number">1l</span>l*x[i]*f[i]%p;</span><br><span class="line">        ntt(x,lim,<span class="number">-1</span>);</span><br><span class="line">        g.resize(n);</span><br><span class="line">        g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)g[i]=<span class="number">1l</span>l*x[i<span class="number">-1</span>]*iv[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getexp</span><span class="params">(vec f,vec &amp;g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> vec x;</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> m,lim=<span class="number">1</span>;</span><br><span class="line">        getexp(f,g,m=((n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;(n&lt;&lt;<span class="number">1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        g.resize(lim);</span><br><span class="line">        getln(g,x,n);</span><br><span class="line">        x.resize(lim);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)x[i]=mod(f[i]-x[i]+p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;lim;i++)x[i]=<span class="number">0</span>;</span><br><span class="line">        x[<span class="number">0</span>]=mod(x[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        ntt(g,lim,<span class="number">1</span>),ntt(x,lim,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)g[i]=<span class="number">1l</span>l*g[i]*x[i]%p;</span><br><span class="line">        ntt(g,lim,<span class="number">-1</span>);</span><br><span class="line">        g.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> polynomials;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">30005</span>];</span><br><span class="line"><span class="function">vec <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;vec res;res.pb(<span class="number">1</span>);res.pb(p-a[l]);<span class="keyword">return</span> res;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,lim=<span class="number">1</span>;</span><br><span class="line">    vec x=solve(l,mid),y=solve(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(r-l+<span class="number">2</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    ntt(x,lim,<span class="number">1</span>),ntt(y,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)x[i]=<span class="number">1l</span>l*x[i]*y[i]%p;</span><br><span class="line">    ntt(x,lim,<span class="number">-1</span>);x.resize(r-l+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">30005</span>],inv[<span class="number">30005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prod=<span class="number">1</span>;</span><br><span class="line">    init(<span class="number">131071</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),prod=<span class="number">1l</span>l*prod*a[i]%p;</span><br><span class="line">    vec t=solve(<span class="number">1</span>,n+<span class="number">1</span>),res;</span><br><span class="line">    getln(t,res,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)res[i]=<span class="number">1l</span>l*res[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(res[i])res[i]=p-res[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)res[i]=res[i<span class="number">-1</span>];</span><br><span class="line">    res[<span class="number">0</span>]=n;</span><br><span class="line">    vec a,b,c,d;</span><br><span class="line">    a.resize(n),b.resize(n);</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    inv[n<span class="number">-1</span>]=pw(fac[n<span class="number">-1</span>],p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)inv[i]=<span class="number">1l</span>l*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=pw(i+<span class="number">1</span>,m);</span><br><span class="line">        b[i]=<span class="number">1l</span>l*t*inv[i]%p;</span><br><span class="line">        a[i]=<span class="number">1l</span>l*b[i]*t%p;</span><br><span class="line">    &#125;</span><br><span class="line">    getln(b,d,c,n);</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(n&lt;&lt;<span class="number">1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    ntt(a,lim,<span class="number">1</span>),ntt(c,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)a[i]=<span class="number">1l</span>l*a[i]*c[i]%p;</span><br><span class="line">    ntt(a,lim,<span class="number">-1</span>),a.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1l</span>l*a[i]*res[i]%p,d[i]=<span class="number">1l</span>l*d[i]*res[i]%p;</span><br><span class="line">    c.clear();</span><br><span class="line">    getexp(d,c,n);</span><br><span class="line">    ntt(a,lim,<span class="number">1</span>),ntt(c,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)a[i]=<span class="number">1l</span>l*a[i]*c[i]%p;</span><br><span class="line">    ntt(a,lim,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,<span class="number">1l</span>l*a[n<span class="number">-2</span>]*fac[n<span class="number">-2</span>]%p*prod%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>prufer 序列</tag>
      </tags>
  </entry>
  <entry>
    <title>「USACO18DEC」Balance Beam P &amp; AGC044E Random Pawn</title>
    <url>/2020/09/26/%E3%80%8CUSACO18DEC%E3%80%8DBalance%20Beam%20P%20&amp;%20AGC044E%20Random%20Pawn/</url>
    <content><![CDATA[<p>这两道题是一个类型的，所以放到一起写了。</p>
<a id="more"></a>
<h4 id="balance-beam-p">Balance Beam P</h4>
<p>我们不算那个什么关键点了，直接设 <span class="math inline">\(E_i\)</span> 为最优策略下从 <span class="math inline">\(i\)</span> 开始的报酬。那么我们有 <span class="math inline">\(E_0=E_{n+1}=0\)</span>，同时考虑这一步的决策，如果走，那么期望为 <span class="math inline">\(\dfrac{E_{i-1}+E_{i+1}}{2}\)</span>，如果不走，报酬是 <span class="math inline">\(f_i\)</span>。</p>
<p>所以我们有 <span class="math display">\[
E_{i}=\max(\frac{E_{i-1}+E_{i+1}}{2},f_i)\quad (1\leqslant i\leqslant n)
\]</span> 我们有以下定论：点集 <span class="math inline">\(\{(i,E_i)\}\)</span> 在点集 <span class="math inline">\(\{(i,f_i)\}\cup\{(0,0),(n+1,0)\}\)</span> 所构成的凸包上。</p>
<p>我们不难发现 <span class="math inline">\(E_i\)</span> 等于 <span class="math inline">\((i,f_i)\)</span> 和经过 <span class="math inline">\((i-1,E_{i-1})\)</span> 与 <span class="math inline">\((i+1,E_{i+1})\)</span> 两点的直线在 <span class="math inline">\(x=i\)</span> 出的纵坐标的较大值，则其一定是凸的；同时不难发现，<span class="math inline">\(\{(i,f_i)\}\cup\{(0,0),(n+1,0)\}\)</span> 构成的凸包一定满足上述条件。</p>
<p>下面我们证明这样的点集是唯一的。为此我们扩展一下状态：给定平面中 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i,y_i)\)</span> 和点 <span class="math inline">\((x_0,f_0),(x_{n+1},f_{n+1})\)</span>，满足 <span class="math inline">\(x_i\)</span> 互不相同且从小到大排列。设<span class="math inline">\(f_i=\max(y_i,\dfrac{x_{i+1}-x_i}{x_{i+1}-x_{i-1}}f_{i-1}+\dfrac{x_i-x_{i-1}}{x_{i+1}-x_{i-1}}f_{i+1})\)</span>，从图形意义上依旧是相邻的两个点形成直线和给定点的较高点。则我们只需要证明 <span class="math inline">\(\{(x_i,f_i)\}\)</span> 的每一个顶点都是给定点集中的点。我们考虑归纳证明。</p>
<p>当 <span class="math inline">\(n=1\)</span> 时显然成立。</p>
<p>当 <span class="math inline">\(n&gt;1\)</span> 时，考虑任意添加最后一个点，如果其在前 <span class="math inline">\(n+1\)</span> 个点形成的凸包内部，则继续；反之新形成的凸包一定由原凸包上点的子集和新加入的点组成。这样一定不会有不属于原点集的点。</p>
<p>所以我们只需要维护原点集的凸包，这个可以线性实现。</p>
<p>代码（这题卡精度最后输出的时候不要用 <code>double</code> 要用 <code>__int128</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line">ll a[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">200005</span>],tl;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">200005</span>];</span><br><span class="line"><span class="function">ll <span class="title">crs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="keyword">return</span> ((y-x)*(a[y]-a[z])-(y-z)*(a[y]-a[x]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tl&gt;<span class="number">1</span>&amp;&amp;crs(q[tl<span class="number">-1</span>],q[tl],x)&lt;=<span class="number">0</span>)tl--;</span><br><span class="line">    q[++tl]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">9</span>)&#123;<span class="built_in">putchar</span>(<span class="string">'0'</span>+x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    write(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'0'</span>+x%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    q[tl=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">        a[i]=x;</span><br><span class="line">        a[i]*=<span class="number">100000</span>;</span><br><span class="line">        add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    add(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q[now+<span class="number">1</span>]&lt;=i)now++;</span><br><span class="line">        write(((((q[now+<span class="number">1</span>]-i)*a[q[now]])+(i-q[now])*a[q[now+<span class="number">1</span>]])/(q[now+<span class="number">1</span>]-q[now])));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="random-pawn">Random Pawn</h4>
<p>上一道题的加强版。</p>
<p>首先我们发现，如果走到了环上的最大值，则一定会停止，所以我们可以在最大值处破环为链（令 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(n\)</span> 都为最大值）。</p>
<p>令 <span class="math inline">\(E_i\)</span> 为从 <span class="math inline">\(i\)</span> 开始的期望，那么我们现在也可以写出转移： <span class="math display">\[
E_i=\max(A_i,\frac{E_{i-1}+E_{i+1}}{2}-B_i)
\]</span> 如果没有 <span class="math inline">\(B_i\)</span>，那就是上一道题了，我们现在考虑把 <span class="math inline">\(B_i\)</span> 消掉。</p>
<p>我们尝试构造一个数列 <span class="math inline">\(\{C_i\}\)</span>，那么有 <span class="math display">\[
E_i-C_i=\max(A_i-C_i,\frac{E_{i-1}-C_{i-1}+E_{i+1}-C_{i+1}}{2}+\frac{C_{i-1}+C_{i+1}}{2}-B_i-C_i)
\]</span> 如果我们的 <span class="math inline">\({C_n}\)</span> 能让 <span class="math inline">\(\dfrac{C_{i-1}+C_{i+1}}{2}-B_i-C_i=0\)</span>，设 <span class="math inline">\(F_i=E_i-C_i,G_i=A_i-C_i\)</span>，则有 <span class="math display">\[
F_i=\max(G_i,\frac{F_{i-1}+F_{i+1}}{2})
\]</span> 这个就是上一道题的形式了，<span class="math inline">\(C_i\)</span> 可以随便确定 <span class="math inline">\(C_0,C_1\)</span> 然后直接递推得到（<span class="math inline">\(C_i=2C_{i-1}+2B_{i-1}-C_{i-2}\)</span>）。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll tmp1[<span class="number">200005</span>],tmp2[<span class="number">200005</span>],a[<span class="number">200005</span>],b[<span class="number">200005</span>],c[<span class="number">200005</span>],g[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">200005</span>],tl;</span><br><span class="line"><span class="function">ll <span class="title">crs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="keyword">return</span> ((y-x)*(g[y]-g[z])-(y-z)*(g[y]-g[x]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tl&gt;<span class="number">1</span>&amp;&amp;crs(q[tl<span class="number">-1</span>],q[tl],x)&lt;=<span class="number">0</span>)tl--;</span><br><span class="line">    q[++tl]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp1[i]);</span><br><span class="line">        <span class="keyword">if</span>(tmp1[i]&gt;tmp1[mx])mx=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp2[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mx;i&lt;=n;i++)a[i-mx]=tmp1[i],b[i-mx]=tmp2[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;i++)a[n-mx+i]=tmp1[i],b[n-mx+i]=tmp2[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)c[i]=<span class="number">2</span>*c[i<span class="number">-1</span>]+<span class="number">2</span>*b[i<span class="number">-1</span>]-c[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)g[i]=a[i]-c[i],add(i);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q[now+<span class="number">1</span>]&lt;=i)now++;</span><br><span class="line">        res+=((((q[now+<span class="number">1</span>]-i)*g[q[now]])+(i-q[now])*g[q[now+<span class="number">1</span>]])*<span class="number">1.0</span>/(q[now+<span class="number">1</span>]-q[now]))+c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf"</span>,res/n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC102</title>
    <url>/2020/09/23/ARC102/</url>
    <content><![CDATA[<h3 id="c---triangular-relationship">C - Triangular Relationship</h3>
<p>如果 <span class="math inline">\(K\)</span> 是奇数，那么一定有 <span class="math inline">\(K\mid a,K\mid b,K\mid c\)</span>，所以答案为 <span class="math inline">\(\lfloor\frac{N}{K}\rfloor^3\)</span>。</p>
<p>如果 <span class="math inline">\(K\)</span> 是偶数，还有可能 <span class="math inline">\(a,b,c\equiv \frac{K}{2}\pmod K\)</span>，所以在奇数的基础上还要加上 <span class="math inline">\(\left(\lfloor\frac{N-\frac{K}{2}}{K}\rfloor+1\right)^3\)</span>，注意如果 <span class="math inline">\(N&lt;\frac{K}{2}\)</span> 时不能加上。</p>
<a id="more"></a>
<h3 id="d---all-your-paths-are-different-lengths">D - All Your Paths are Different Lengths</h3>
<p>先考虑 <span class="math inline">\(L=2^k\)</span> 怎么做：只需要把 <span class="math inline">\(1-k+1\)</span> 的点排成一排，<span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 的点分别连权值为 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(2^{i-1}\)</span> 的两条边就可以了。</p>
<p>然后我们考虑 <span class="math inline">\(L\not=2^k\)</span> 的情况，首先设 <span class="math inline">\(2^{mx}\leqslant L&lt;2^{mx+1}\)</span>，那么我们先构造一个如上的长为 <span class="math inline">\(mx+1\)</span> 的链，然后我们从高到低遍历 <span class="math inline">\(L\)</span> 的二进制，同时维护把比当前位更低（包括当前位）的位都置为 <span class="math inline">\(0\)</span> 后 <span class="math inline">\(L\)</span> 的值 <span class="math inline">\(now\)</span>，如果 <span class="math inline">\(2^k(k\not=mx)\)</span> 这一位是 <span class="math inline">\(1\)</span>，则从 <span class="math inline">\(k+1\)</span> 向 <span class="math inline">\(mx+1\)</span> 连一条权值为 <span class="math inline">\(now\)</span> 的边。</p>
<p>不难发现这样的构造方式是对的。</p>
<h3 id="e---stop.-otherwise...">E - Stop. Otherwise...</h3>
<p>我们考虑现在求 <span class="math inline">\(y\)</span> 的答案。</p>
<p>那么如果 <span class="math inline">\(i\)</span> 出现，则 <span class="math inline">\(y-i\)</span> 就不能出现了，这样，我们可以把若干的两个和为 <span class="math inline">\(y\)</span> 的权值一起考虑；如果 <span class="math inline">\(y\)</span> 为偶数，则 <span class="math inline">\(\dfrac{y}{2}\)</span> 只能出现一次； 剩下的数没有要求。</p>
<p>我们考虑以上三种情况的 OGF：</p>
<p>对于两个和为 <span class="math inline">\(y\)</span> 的权值 <span class="math inline">\(a,b\)</span>，当至少出现一次时，一定只能全是 <span class="math inline">\(a\)</span> 或全是 <span class="math inline">\(b\)</span>，所以其 OGF 为 <span class="math display">\[
1+2x+2x^2+2x^3+\dots=(1+x)(1+x+x^2+\dots)=\frac{1+x}{1-x}
\]</span> 对于 <span class="math inline">\(\dfrac{y}{2}\)</span>，其只能出现 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span> 次，所以其 OGF 为 <span class="math inline">\(1+x\)</span>。</p>
<p>对于剩下的没有要求的数，可以选任意个，所以其 OGF 为 <span class="math display">\[
1+x+x^2+x^3+\dots=\frac{1}{1-x}
\]</span> 我们把所有的 OGF 乘起来，发现其一定形如 <span class="math inline">\(\dfrac{(1+x)^p}{(1-x)^q}\)</span>，其中 <span class="math inline">\(p,q\)</span> 可以根据 <span class="math inline">\(y\)</span> 计算得到。</p>
<p>分别考虑 <span class="math inline">\((1+x)^p\)</span> 和 <span class="math inline">\(\frac{1}{(1-x)^q}\)</span> 的展开形式，其分别为 <span class="math inline">\(\sum\limits_{i=0}^p\dbinom{p}{i}x^i\)</span> 和 <span class="math inline">\(\sum\limits_{i=0}^{\infty}\dbinom{i+q-1}{q-1}x^i\)</span> 。由于我们只需要求 <span class="math inline">\([x^n]\dfrac{(1+x)^p}{(1-x)^q}\)</span>，所以只需要暴力 <span class="math inline">\(O(n)\)</span> 计算两部分的卷积。</p>
<p>所以总复杂度为 <span class="math inline">\(O(nk)\)</span>。</p>
<h3 id="f---revenge-of-bbubbblesort">F - Revenge of BBuBBBlesort!</h3>
<p>我们发现一次操作交换的两个数下标的奇偶性一定相同，所以如果一开始有一个偶/奇数的下标是奇/偶数一定无解。</p>
<p>我们把原序列按下标的奇偶性分为两个新序列。我们发现，对于在原序列上的一次交换，它使得原序列的逆序对个数减小了 <span class="math inline">\(3\)</span>，而使得某一个新序列的逆序对个数减小了 <span class="math inline">\(1\)</span>，所以必须保证两个新序列的逆序对之和的三倍等于原序列的逆序对个数（因为我们要保证最后两个新序列逆序对个数为 <span class="math inline">\(0\)</span>）。</p>
<p>下面我们证明这两个条件都满足是充分的：考虑对新序列冒泡排序，那么每一次交换，其至多让原排列的逆序对个数下降 <span class="math inline">\(3\)</span>，且如果能，一定等价于合法的对原序列的一次操作。由我们给出的前两个必要条件可知对两个新序列都冒泡排序后原序列有序，故每一次操作都一定让原序列的逆序对个数下降了 <span class="math inline">\(3\)</span>，所以每一次操作都合法。</p>
<p>所以我们只需要上一个树状数组就可以了。</p>
<p>提交记录：#16951728,#16952239,#16964800,#16968538。</p>
]]></content>
      <tags>
        <tag>套题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC103 简要题解</title>
    <url>/2020/09/21/ARC103/</url>
    <content><![CDATA[<h3 id="c--">C - /\/\/\/</h3>
<p>计算出 <code>t1[]</code> 和 <code>t2[]</code> 表示奇数和偶数位置上每个数出现的次数，枚举奇数位改成了哪一种数，那么偶数位就改成不等于这个数之外的出现最多的数，用前缀和后缀最大值解决。</p>
<a id="more"></a>
<h3 id="d---robot-arms">D - Robot Arms</h3>
<p>首先考虑无解的情况，当存在两个点 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，且 <span class="math inline">\(x_1+y_1\not\equiv x_2+y_2\pmod 2\)</span> 时，一定无解。因为任何两个点的操作一定是把某一个 <span class="math inline">\(\pm d_i\)</span> 改成 <span class="math inline">\(\mp d_i\)</span>，这样差一定是 <span class="math inline">\(2d_i\)</span> 为偶数，所以所有的 <span class="math inline">\(x_i+y_i\)</span> 奇偶性一定相同。</p>
<p>然后考虑构造方案，看到最多只有 <span class="math inline">\(40\)</span> 节考虑倍增。我们让 <span class="math inline">\(d={1,2,4,\dots,2^k}\)</span>，那么通过作图可以发现，所有可以达到的点为 <span class="math inline">\(x+y&lt;2^k\)</span> 且为奇数的所有点。至于构造方案，从大到小枚举长度，每一次走走完后的坐标距离目标最近的点，这样一定可以走到。</p>
<p>如果 <span class="math inline">\(x+y\)</span> 都是偶数，那么再添加一个 <span class="math inline">\(1\)</span> 然后把所有点坐标都偏移一下。</p>
<h3 id="e---tree">E - Tr/ee</h3>
<p>依旧先考虑无解，显然如果 <span class="math inline">\(s_1=0\)</span> 或 <span class="math inline">\(s_n=1\)</span> 时无解，同时我们发现如果 <span class="math inline">\(s_i\)</span> 和 <span class="math inline">\(s_{n-i}\)</span> 不同也无解，因为如果断出了一个大小为 <span class="math inline">\(i\)</span> 的连通块，那么另一部分大小为 <span class="math inline">\(n-i\)</span>。下面的构造方式证明其他情况一定有解。</p>
<p>我们首先让 <span class="math inline">\(1,2\)</span> 连边，然后我们从 <span class="math inline">\(2\)</span> 开始到 <span class="math inline">\(n-1\)</span> 遍历 <span class="math inline">\(s\)</span>，记一个变量 <code>now</code>，其初值为 <span class="math inline">\(2\)</span>，然后每一次连接 <span class="math inline">\(now\)</span> 和 <span class="math inline">\(i+1\)</span>，如果 <span class="math inline">\(s_i=1\)</span>，令 <span class="math inline">\(now=i+1\)</span>。</p>
<p>考虑这样为什么是对的，这样构造出来的树一定是一条长链，然后每个链上的点挂了若干个点，显然切开链和挂着的点之间的边只会得到 <span class="math inline">\(1\)</span>，那么考虑切链上的边，如果从一段 dfs，那么切掉一条边后连通块大小就是某个端点的 <span class="math inline">\(size\)</span>，显然根据我们的构造方式，只会存在 <span class="math inline">\(s_i=1\)</span> 的 <span class="math inline">\(size\)</span>。</p>
<h3 id="f---distance-sums">F - Distance Sums</h3>
<p>我们考虑如果从 <span class="math inline">\(u\)</span> 变到 <span class="math inline">\(v\)</span>，<span class="math inline">\(d\)</span> 的变化。设断开 <span class="math inline">\((u,v)\)</span> 后，两棵树的大小分别为 <span class="math inline">\(siz_u,siz_v\)</span>，则所有 <span class="math inline">\(u\)</span> 树中的点 <span class="math inline">\(dis\)</span> 增加 <span class="math inline">\(1\)</span>，<span class="math inline">\(v\)</span> 树中的点 <span class="math inline">\(dis\)</span> 减小 <span class="math inline">\(1\)</span>。故 <span class="math inline">\(\Delta d=siz_u-siz_v=siz_u-(n-siz_u)=2siz_u-n\)</span>。我们不难有推论：<span class="math inline">\(d\)</span> 最小的点一定是重心，<span class="math inline">\(d\)</span> 最大的点一定是叶子；且以重心为根，父亲的 <span class="math inline">\(d\)</span>，一定小于儿子的 <span class="math inline">\(d\)</span>。</p>
<p>然后我们考虑构造方案，我们把 <span class="math inline">\(d\)</span> 从大到小排序，那么第一个一定是叶子，即它的 <span class="math inline">\(siz\)</span> 已经确定，因为 <span class="math inline">\(d\)</span> 两两不同，我们也就确定了它的父节点，这样我们每访问到一个点，都可以确定它的 <span class="math inline">\(siz\)</span>，也就可以一个一个确定父亲。如果某一次找不到父亲对应的 <span class="math inline">\(d\)</span>，那么一定无解。</p>
<p>然后如果我们都构造完了，也不一定有解。因为我们只是保证了所有 <span class="math inline">\(d\)</span> 之间的相对大小，并没有算出 <span class="math inline">\(d\)</span> 的值，所以我们需要随便计算一个点的 <span class="math inline">\(d\)</span> 查看是否正确。</p>
<p>提交记录（按题号排序）：#16938465,#16947314,#16939196,#16951309。</p>
]]></content>
      <tags>
        <tag>套题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF516E Drazil and His Happy Friends</title>
    <url>/2020/09/20/CF516E%20Drazil%20and%20His%20Happy%20Friends/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/516/E" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>首先，设 <span class="math inline">\(d=\gcd(n,m)\)</span>，由简单的数论知识可知，在任意一天一起玩的男生和女生编号在<span class="math inline">\(\bmod d\)</span> 意义下同余。所以我们可以把所有男生和女生按模 <span class="math inline">\(d\)</span> 的值分组，然后我们只考虑同一组内的情况，即我们把其他组的人都抽出去，那么若求得 <span class="math inline">\(r\)</span> 这一组子问题的答案为 <span class="math inline">\(t\)</span>，那么在原问题中这组的答案即为 <span class="math inline">\(dt+r\)</span>（当第 <span class="math inline">\(0\)</span> 天就合法时需要特判）。然后我们只需要对所有组的答案取 <span class="math inline">\(\max\)</span>。</p>
<p>由裴蜀定理可知，只要一开始有一个人是快乐的，那么最后所有人都会变快乐。由于只有 <span class="math inline">\(b+g\)</span> 个人快乐，所以当 <span class="math inline">\(d&gt;b+g\)</span> 时肯定至少有一组初始状态没有人快乐，这样 <span class="math inline">\(\gcd(n,m)\)</span> 过大时我们直接输出 <code>-1</code> 就好了。</p>
<p>现在我们只需要考虑 <span class="math inline">\(\gcd(n,m)=1\)</span> 的情况。我们考虑分别算出最后一个男生和最后一个女生的变快乐的时间，然后取 <span class="math inline">\(\max\)</span>。先考虑女生的情况，男生类似。</p>
<p>我们发现，如果在第 <span class="math inline">\(i\)</span> 天，第 <span class="math inline">\(i\bmod m\)</span> 个女生是快乐的，那么第 <span class="math inline">\(i\)</span> 天，第 <span class="math inline">\(j\bmod n\)</span> 个男生也是快乐的，那么我们考虑过了 <span class="math inline">\(n\)</span> 天以后，第 <span class="math inline">\(j\bmod n\)</span> 个男生会让第 <span class="math inline">\((i+n)\bmod m\)</span> 个女生变快乐。</p>
<p>那么这可以等价于：<span class="math inline">\(n\)</span> 天以后，第 <span class="math inline">\(i\bmod m\)</span> 个女生让第 <span class="math inline">\((i+n)\bmod m\)</span> 个女生变快乐了。简单推广可知，如果第 <span class="math inline">\(j\)</span> 个女生在某一天变快乐了，那么 <span class="math inline">\(n\)</span> 天后，第 <span class="math inline">\((j+n)\bmod m\)</span> 个女生也一定会快乐。那么我们把这个建成最短路模型：</p>
<ul>
<li><p>对每个女生 <span class="math inline">\(k\)</span> 我们向第 <span class="math inline">\((k+n)\bmod m\)</span> 个女生连一条边权为 <span class="math inline">\(n\)</span> 的边，这相当于某时刻 <span class="math inline">\(k\)</span> 变得快乐，那么 <span class="math inline">\(k+n\)</span> 时刻 <span class="math inline">\((k+n)\bmod m\)</span> 会快乐。</p></li>
<li><p>对每个一开始就快乐的女生 <span class="math inline">\(k\)</span>，从源点 <span class="math inline">\(S\)</span> 向 <span class="math inline">\(k\)</span> 连一条边权为 <span class="math inline">\(k\)</span> 的边。</p></li>
<li><p>对每个一开始就快乐的男生 <span class="math inline">\(k\)</span>，从 <span class="math inline">\(S\)</span> 向 <span class="math inline">\(k\bmod m\)</span> 连一条边权为 <span class="math inline">\(k\)</span> 的边，即时刻 <span class="math inline">\(k\)</span> 第 <span class="math inline">\(k\bmod m\)</span> 个女生会因该男生变快乐。</p></li>
</ul>
<p>这样跑从 <span class="math inline">\(S\)</span> 开始的最短路，求每个点的 <span class="math inline">\(dis\)</span> 的 <span class="math inline">\(\max\)</span> 就是答案。</p>
<p>但是我们发现点数是 <span class="math inline">\(10^9\)</span> 级别的，没法跑，我们观察这个图的性质：第一类边把所有除 <span class="math inline">\(S\)</span> 以外的点练成了一个大环，我们认为 <span class="math inline">\(S\)</span> 直接连向的点为关键点，那么关键点的 <span class="math inline">\(dis\)</span> 即为 <span class="math inline">\(S\)</span> 连向这个点的边权。我们考虑把所有关键点按在环上的顺序排序（可以通过 exgcd 来实现），那么对于连续的两个关键点 <span class="math inline">\(A,B\)</span>，显然 <span class="math inline">\(B\)</span> 前面的那个点是 <span class="math inline">\(AB\)</span> 这一段之间 <span class="math inline">\(dis\)</span> 最大的，我们对所有连续的点对都做一遍取 <span class="math inline">\(\max\)</span> 就是答案。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,b,g,d,x[<span class="number">100005</span>],y[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;V[<span class="number">200005</span>],W[<span class="number">200005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;buc;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y?gcd(y,x%y):x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;exgcd(b,a%b,y,x);y-=(a/b)*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;<span class="keyword">return</span> x.z&lt;y.z;&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.size()==m)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v.size()==<span class="number">0</span>&amp;&amp;w.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    mp.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:w)mp[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:v)</span><br><span class="line">        <span class="keyword">if</span>(mp.find(i%m)==mp.end())mp[i%m]=i;</span><br><span class="line">        <span class="keyword">else</span> mp[i%m]=min(mp[i%m],i);</span><br><span class="line">    buc.clear();</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        buc.push_back(node&#123;i.first,i.second,<span class="number">0</span>&#125;);</span><br><span class="line">        exgcd(n,m,t1,t2);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t=<span class="number">1l</span>l*t1*i.first;</span><br><span class="line">        t+=<span class="number">1l</span>l*m*<span class="built_in">ceil</span>(<span class="number">1.0</span>*(<span class="number">1</span>-t)/m);</span><br><span class="line">        <span class="keyword">if</span>(t==m)t-=m;</span><br><span class="line">        buc[buc.size()<span class="number">-1</span>].z=t;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(buc.begin(),buc.end(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;buc.size();i++)</span><br><span class="line">        ans=max(ans,buc[i<span class="number">-1</span>].y+<span class="number">1l</span>l*(buc[i].z-buc[i<span class="number">-1</span>].z<span class="number">-1</span>)*n);</span><br><span class="line">    <span class="keyword">if</span>(buc.size()&gt;<span class="number">1</span>)ans=max(ans,buc[buc.size()<span class="number">-1</span>].y+<span class="number">1l</span>l*(m-buc[buc.size()<span class="number">-1</span>].z+buc[<span class="number">0</span>].z<span class="number">-1</span>)*n);</span><br><span class="line">    <span class="keyword">else</span> ans=<span class="number">1l</span>l*(m<span class="number">-1</span>)*n+buc[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;y[i]);</span><br><span class="line">    d=gcd(n,m);</span><br><span class="line">    <span class="keyword">if</span>(d&gt;b+g)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)V[x[i]%d].push_back(x[i]/d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++)W[y[i]%d].push_back(y[i]/d);</span><br><span class="line">    n/=d,m/=d;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t=solve(V[i],W[i]);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-2</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=max(ans,t*d+i);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t=solve(W[i],V[i]);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=max(ans,t*d+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC045C Range Set</title>
    <url>/2020/09/17/AGC045C%20Range%20Set/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc045/tasks/agc045_c" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>首先，我们发现交换 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的值答案是不变的，因为显然我们可以把序列变为全 <span class="math inline">\(1\)</span>，那么对于每一种未交换 <span class="math inline">\(AB\)</span> 的合法序列，每一位全部反转后得到的序列一定可以在交换 <span class="math inline">\(AB\)</span> 后得到。所以下面我们假定 <span class="math inline">\(A\leqslant B\)</span>。</p>
<p>我们考虑给定一个序列，如何判断其是否可以被得到。</p>
<p>首先我们发现，如果这个序列把所有长度大于等于 <span class="math inline">\(A\)</span> 的全部为 <span class="math inline">\(0\)</span> 的子串置为 <span class="math inline">\(1\)</span> 后，存在一个长度大于等于 <span class="math inline">\(B\)</span> 的全部为 <span class="math inline">\(1\)</span> 的子串，那么它可以被得到。因为我们可以按照从外向内的方式得到这个子串外的每一位，并且都不会影响其它子串外的位，然后把这个子串全部置为 <span class="math inline">\(1\)</span>。这样就得到了变化后的序列，再把变为 <span class="math inline">\(1\)</span> 的部分置为 <span class="math inline">\(0\)</span> 即可。</p>
<p>必要性可以考虑全部置为 <span class="math inline">\(1\)</span> 的操作，如果不存在长度大于等于 <span class="math inline">\(B\)</span> 的全 <span class="math inline">\(1\)</span> 子串，那么任何一个置 <span class="math inline">\(1\)</span> 操作都会让至少一个 <span class="math inline">\(0\)</span> 变成 <span class="math inline">\(1\)</span>，而任何一个置 <span class="math inline">\(0\)</span> 操作也会让至少一个 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>，所以怎么调整都无法结束。</p>
<p>现在我们考虑计算答案，我们计算不可以被得到的序列的个数，即把所有长度大于等于 <span class="math inline">\(A\)</span> 的纯 <span class="math inline">\(0\)</span> 子串置为 <span class="math inline">\(1\)</span> 后，不存在长度大于等于 <span class="math inline">\(B\)</span> 的纯 <span class="math inline">\(1\)</span> 子串，再用 <span class="math inline">\(2^n\)</span> 减去即可。</p>
<p>设 <span class="math inline">\(f(i,0/1)\)</span> 为长度为 <span class="math inline">\(i\)</span>，最后一位为 <span class="math inline">\(0/1\)</span>（注意这里如果最后是连续的长度大于等于 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(0\)</span> 串除了在结尾我们都不计算） 的不合法的序列个数，为了计算 <span class="math inline">\(f\)</span>，我们再引入 <span class="math inline">\(g(i,0/1)\)</span> 为长度为 <span class="math inline">\(i\)</span>，所有极大 <span class="math inline">\(0\)</span> 子串的长度均大于等于 <span class="math inline">\(A\)</span>，且第一位为 <span class="math inline">\(1\)</span>，最后一位为 <span class="math inline">\(0/1\)</span> 的序列的个数。</p>
<p>先考虑 <span class="math inline">\(g\)</span> 的转移，考虑最后放的是 <span class="math inline">\(1\)</span> 还是连续的一段 <span class="math inline">\(0\)</span>，我们有： <span class="math display">\[
g(i,0)=\sum\limits_{j\leqslant i-A}g(j,1)\\
g(i,1)=g(i-1,0)+g(i-1,1)
\]</span> 然后考虑 <span class="math inline">\(f\)</span>，我们需要每一次填一段长度小于 <span class="math inline">\(B\)</span> 且头尾都是 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(g\)</span> 表示的序列或者一段长度小于 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(0\)</span>，为了防止两段的 <span class="math inline">\(0\)</span> 在一起，我们限制了头尾都是 <span class="math inline">\(1\)</span>，但是在最终的序列的头尾是没有这个限制的，所以我们需要额外加上一部分答案，则我们有 <span class="math display">\[
f(i,0)=\sum\limits_{j&gt;i-A}f(j,1)+[i=n]\sum\limits_{j&gt;i-B}f(j,0)g(i-j,0)\\
f(i,1)=\sum\limits_{j&gt;i-B}f(j,0)(g(i-j,1)+[j=0]g(i-j,0))
\]</span> 注意最后一个 <span class="math inline">\(g(i-j,0)\)</span> 指的是以 <span class="math inline">\(0\)</span> 开头，<span class="math inline">\(1\)</span> 结尾的串（也就是把所有串反过来）。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">5005</span>][<span class="number">2</span>],g[<span class="number">5005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)swap(a,b);</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;b;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i-a;j++)</span><br><span class="line">            g[i][<span class="number">0</span>]=mod(g[i][<span class="number">0</span>]+g[j][<span class="number">1</span>]);</span><br><span class="line">        g[i][<span class="number">1</span>]=mod(g[i<span class="number">-1</span>][<span class="number">0</span>]+g[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=max(i-a+<span class="number">1</span>,<span class="number">0</span>);j&lt;i;j++)f[i][<span class="number">0</span>]=mod(f[i][<span class="number">0</span>]+f[j][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=max(i-b+<span class="number">1</span>,<span class="number">0</span>);j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n)f[i][<span class="number">0</span>]=(f[i][<span class="number">0</span>]+<span class="number">1l</span>l*f[j][<span class="number">0</span>]*g[i-j][<span class="number">0</span>])%p;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)f[i][<span class="number">1</span>]=(<span class="number">1l</span>l*f[i][<span class="number">1</span>]+g[i][<span class="number">0</span>]+g[i][<span class="number">1</span>])%p;</span><br><span class="line">            <span class="keyword">else</span> f[i][<span class="number">1</span>]=(f[i][<span class="number">1</span>]+<span class="number">1l</span>l*f[j][<span class="number">0</span>]*g[i-j][<span class="number">1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pw=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pw=mod(pw+pw);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,(<span class="number">1l</span>l*pw+p+p-f[n][<span class="number">0</span>]-f[n][<span class="number">1</span>])%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2020部分题解</title>
    <url>/2020/09/04/NOI2020%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="美食家">美食家</h3>
<p>我们很容易写出朴素的 dp 方程，设 <span class="math inline">\(f(i,u)\)</span> 为第 <span class="math inline">\(i\)</span> 天在城市 <span class="math inline">\(u\)</span> 能得到的最大愉悦值之和，那么有转移： <span class="math display">\[
f(i,u)=\max_{(v,u)\in E}f(i-w_{(v,u)},v)+c_u
\]</span> <a id="more"></a></p>
<p>如果某一个某一次美食节被举办，那么就往对应的 <span class="math inline">\(f\)</span> 加上 <span class="math inline">\(y_i\)</span></p>
<p>我们注意到 <span class="math inline">\(w\)</span> 很小，并且 <span class="math inline">\(\max\)</span> 对 <span class="math inline">\(+\)</span> 有分配律，所以我们可以矩阵快速幂加速计算，我们考虑向量： <span class="math display">\[
\begin{bmatrix}
f(t,1)\\
f(t,2)\\
\vdots\\
f(t,n)\\
f(t-1,1)\\
\vdots\\
f(t-4,n)
\end{bmatrix}
\]</span> 这个东西可以通过 <span class="math display">\[
\begin{bmatrix}
f(t-1,1)\\
f(t-1,2)\\
\vdots\\
f(t-1,n)\\
f(t-2,1)\\
\vdots\\
f(t-5,n)
\end{bmatrix}
\]</span> 左乘转移矩阵得到。转移矩阵比较显然，大概是每有一条边 <span class="math inline">\((u,v,w)\)</span> 就把 <span class="math inline">\((v,u+(w-1)n)\)</span> 改为 <span class="math inline">\(c_v\)</span>，然后其余地方是 <span class="math inline">\(-inf\)</span>。这样总复杂度是 <span class="math inline">\(O(n^3w^3k\log T)\)</span> 无法通过，只需要预处理转移矩阵的次幂，然后每一次只需要向量乘矩阵，总复杂度为 <span class="math inline">\(O((n^3w^3+kn^2w^2)\log T)\)</span>，可以通过。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">55</span>],lim;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll s[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line">    mat()&#123;<span class="built_in">memset</span>(s,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(s));&#125;</span><br><span class="line">    <span class="keyword">friend</span> mat <span class="keyword">operator</span> *(<span class="keyword">const</span> mat &amp;x,<span class="keyword">const</span> mat &amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        mat res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=lim;k++)</span><br><span class="line">                    res.s[i][j]=max(res.s[i][j],x.s[i][k]+y.s[k][j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;r[<span class="number">35</span>];</span><br><span class="line">ll ans[<span class="number">255</span>],ans2[<span class="number">255</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;d[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(event a,event b)</span></span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,t,q,x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;t,&amp;q);</span><br><span class="line">    lim=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        r[<span class="number">1</span>].s[y][x+(z<span class="number">-1</span>)*n]=c[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">5</span>*n;i++)</span><br><span class="line">        r[<span class="number">1</span>].s[i][i-n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">30</span>;i++)r[i]=r[i<span class="number">-1</span>]*r[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    ans[<span class="number">1</span>]=c[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;d[i].x,&amp;d[i].y,&amp;d[i].z);</span><br><span class="line">    q++;d[q].x=t;</span><br><span class="line">    sort(d+<span class="number">1</span>,d+q+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=d[i].x-now;</span><br><span class="line">        now=d[i].x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(tmp&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=lim;k++)ans2[k]=ans[k];</span><br><span class="line">                <span class="built_in">memset</span>(ans,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=lim;k++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=lim;l++)</span><br><span class="line">                        ans[k]=max(ans[k],ans2[l]+r[j].s[k][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        ans[d[i].y]+=d[i].z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans[<span class="number">1</span>]&lt;<span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命运">命运</h3>
<p>我们在一条链的底部加入这条链的限制。考虑 dp，设 <span class="math inline">\(f(u,t)\)</span> 为以 <span class="math inline">\(u\)</span> 为根的子树，目前尚未满足并且已经被加入的链中，最深的链顶的深度为 <span class="math inline">\(t\)</span> 的方案数。特殊的，当所有限制都被满足，方案数被记在 <span class="math inline">\(f(u,0)\)</span> 中。则答案为 <span class="math inline">\(f(1,0)\)</span>。</p>
<p>那么我们考虑加入一个子树 <span class="math inline">\(v\)</span> 的答案，不难发现有转移 <span class="math display">\[
\begin{aligned}
f&#39;(u,t)&amp;=\sum\limits_{\max(x,y)=t}f(u,x)f(v,y)+f(u,t)\sum\limits_{y\leqslant deep_u}f(v,y)\\
&amp;=f(u,t)\left(\sum\limits_{y=0}^tf(v,y)+\sum\limits_{z=0}^{deep_u}f(v,z)\right)+f(v,t)\sum\limits_{x=0}^{t-1}f(u,x)\\
&amp;=f(u,t)(s(v,t)+s(v,deep_u))+f(v,t)s(u,t-1)\\
\end{aligned}
\]</span> 其中 <span class="math inline">\(s\)</span> 是前缀和。这个转移叫做 “max 卷积”，这个东西看上去难以维护，怎么优化我们一会再说。</p>
<p>合并完所有子树之后我们对每一个点需要增加以这个点为底的限制，设 <span class="math inline">\(maxd_u\)</span> 为以 <span class="math inline">\(u\)</span> 为起点的所有链中链顶最深的节点的深度，那么则 <span class="math display">\[
f&#39;(u,t)=
\begin{cases}
f(u,t)&amp;t&gt; maxd_u\\
\sum\limits_{x=0}^{maxd_u}f(u,x) &amp;t=maxd_u\\
0 &amp;t&lt;maxd_u
\end{cases}
\]</span> 接下来我们说怎么优化这个 dp。先做 max 卷积。max 卷积可以通过线段树合并来实现：具体地，我们合并的时候，维护两个标记 <span class="math inline">\(s1,s2\)</span> 分别表示 <span class="math inline">\(s(v,l-1)+s(v,deep_u)\)</span> 和 <span class="math inline">\(s(u,l-1)\)</span>，那么当递归到叶子节点时，直接按照标记这个乘一下；当某一个区间只在一棵树中存在时，是一个区间乘的形式；剩下的情况先把左儿子的 <span class="math inline">\(sum\)</span> 加到标记上，递归右儿子，再用之前的标记递归左儿子，最后合并答案即可。</p>
<p>然后合并完所有的子树，加入新的限制时，相当于区间查询、区间修改和新增一个节点，都可以使用线段树维护。复杂度的话，由于每一个限制至多新增一个节点，所以一开始所有线段树的总结点数是 <span class="math inline">\(O(n\log n)\)</span> 的（这里认为 <span class="math inline">\(n,m\)</span> 同阶），然后合并时如果某一个节点在合并中的两棵树都存在，总结点数会 <span class="math inline">\(-1\)</span>，而只在一棵树中存在的情况和都存在的情况次数是同阶的，所以总复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,target[<span class="number">1000005</span>],pre[<span class="number">1000005</span>],last[<span class="number">500005</span>],tot,deep[<span class="number">500005</span>],maxd[<span class="number">500005</span>],</span><br><span class="line">ch[<span class="number">20000005</span>][<span class="number">2</span>],sum[<span class="number">20000005</span>],mul[<span class="number">20000005</span>],tag[<span class="number">20000005</span>],cnt,root[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target[++tot]=y;</span><br><span class="line">    pre[tot]=last[x];</span><br><span class="line">    last[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deep[x]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(tar,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tag[x]!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">0</span>])sum[ch[x][<span class="number">0</span>]]=<span class="number">1l</span>l*(mid-l+<span class="number">1</span>)*tag[x]%p,tag[ch[x][<span class="number">0</span>]]=tag[x];</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">1</span>])sum[ch[x][<span class="number">1</span>]]=<span class="number">1l</span>l*(r-mid)*tag[x]%p,tag[ch[x][<span class="number">1</span>]]=tag[x];</span><br><span class="line">        tag[x]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mul[x]!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">0</span>])sum[ch[x][<span class="number">0</span>]]=<span class="number">1l</span>l*sum[ch[x][<span class="number">0</span>]]*mul[x]%p,mul[ch[x][<span class="number">0</span>]]=<span class="number">1l</span>l*mul[x]*mul[ch[x][<span class="number">0</span>]]%p;</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">1</span>])sum[ch[x][<span class="number">1</span>]]=<span class="number">1l</span>l*sum[ch[x][<span class="number">1</span>]]*mul[x]%p,mul[ch[x][<span class="number">1</span>]]=<span class="number">1l</span>l*mul[x]*mul[ch[x][<span class="number">1</span>]]%p;</span><br><span class="line">        mul[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pushdown(l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=a&amp;&amp;r&lt;=b)<span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid)ans=query(l,mid,ch[x][<span class="number">0</span>],a,b);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;mid)ans=mod(ans+query(mid+<span class="number">1</span>,r,ch[x][<span class="number">1</span>],a,b));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> s1,<span class="keyword">int</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!x)&amp;&amp;(!y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pushdown(l,r,x),pushdown(l,r,y);</span><br><span class="line">    <span class="keyword">if</span>((!x)||(!y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[y]=<span class="number">1l</span>l*sum[y]*s2%p;</span><br><span class="line">            mul[y]=<span class="number">1l</span>l*mul[y]*s2%p;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[x]=<span class="number">1l</span>l*sum[x]*s1%p;</span><br><span class="line">        mul[x]=<span class="number">1l</span>l*mul[x]*s1%p;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[x]=(<span class="number">1l</span>l*sum[x]*(s1+sum[y])+<span class="number">1l</span>l*sum[y]*s2)%p;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ch[x][<span class="number">1</span>]=merge(mid+<span class="number">1</span>,r,ch[x][<span class="number">1</span>],ch[y][<span class="number">1</span>],mod(s1+sum[ch[y][<span class="number">0</span>]]),mod(s2+sum[ch[x][<span class="number">0</span>]]));</span><br><span class="line">    ch[x][<span class="number">0</span>]=merge(l,mid,ch[x][<span class="number">0</span>],ch[y][<span class="number">0</span>],s1,s2);</span><br><span class="line">    sum[x]=mod(sum[ch[x][<span class="number">0</span>]]+sum[ch[x][<span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=++cnt;</span><br><span class="line">    pushdown(l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;sum[x]=b;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid)insert(l,mid,ch[x][<span class="number">0</span>],a,b);</span><br><span class="line">    <span class="keyword">else</span> insert(mid+<span class="number">1</span>,r,ch[x][<span class="number">1</span>],a,b);</span><br><span class="line">    sum[x]=mod(sum[ch[x][<span class="number">0</span>]]+sum[ch[x][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">    pushdown(l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=a&amp;&amp;r&lt;=b)&#123;sum[x]=<span class="number">1l</span>l*(r-l+<span class="number">1</span>)*c%p;tag[x]=c;mul[x]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid)modify(l,mid,ch[x][<span class="number">0</span>],a,b,c);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;mid)modify(mid+<span class="number">1</span>,r,ch[x][<span class="number">1</span>],a,b,c);</span><br><span class="line">    sum[x]=mod(sum[ch[x][<span class="number">0</span>]]+sum[ch[x][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    insert(<span class="number">0</span>,n,root[x],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs2(tar,x);</span><br><span class="line">        root[x]=merge(<span class="number">0</span>,n,root[x],root[tar],query(<span class="number">0</span>,n,root[tar],<span class="number">0</span>,deep[x]),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxd[x])</span><br><span class="line">    &#123;</span><br><span class="line">        insert(<span class="number">0</span>,n,root[x],maxd[x],query(<span class="number">0</span>,n,root[x],<span class="number">0</span>,maxd[x]));</span><br><span class="line">        modify(<span class="number">0</span>,n,root[x],<span class="number">0</span>,maxd[x]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch<span class="number">-48</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tag,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(tag));</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)x=read(),y=read(),add(x,y),add(y,x);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        x=read(),y=read(),maxd[y]=max(maxd[y],deep[x]);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,query(<span class="number">0</span>,n,root[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时代的眼泪">时代的眼泪</h3>
<p>这个是标程做法，但是实现起来比直接分块要麻烦所以没有写代码（其实就是复述了一遍 ppt /kk，如果有误麻烦指出）。</p>
<p>如非特殊说明，复杂度分析认为 <span class="math inline">\(n,m\)</span> 同阶。</p>
<p>我们考虑对平面建立树套树（线段树套动态开点线段树）。那么内层的每个节点代表了平面中的一个矩形，为了之后的计算，我们需要维护树套树中每个矩形内部的答案。</p>
<p><img src="https://s1.ax1x.com/2020/08/24/dsTlgU.md.png"></p>
<p>如图，假设我们现在有一个长和宽均不为 <span class="math inline">\(1\)</span> 的矩形（当至少一维为 <span class="math inline">\(1\)</span> 时答案一定为 <span class="math inline">\(0\)</span>），我们想要求出这个矩形的答案（我们认为左下角为较小的下标），我们把这个矩形一分为四，并且我们已经递归得出了每个子矩形的答案，那么我们有： <span class="math display">\[
\begin{aligned}
ans(ABCD)=&amp;ans(AB)+ans(CD)+ans(AC)+ans(BD)\\
-&amp;ans(A)-ans(B)-ans(C)-ans(D)+siz(A)\cdot siz(D)
\end{aligned}
\]</span> 其中 <span class="math inline">\(siz(A)\)</span> 是 <span class="math inline">\(A\)</span> 中包含点的数量。这个东西本质就是枚举任意两块，求出块之间的答案，再求出块内部的答案。由于 <span class="math inline">\(ans(AB)\)</span> 已经包含了 <span class="math inline">\(ans(A)+ans(B)\)</span>，所以这里要容斥捡回去。<strong>本题可以这样分治的关键在于 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(D\)</span> 的贡献是平凡的。</strong></p>
<p>子矩形的 <span class="math inline">\(ans\)</span> 我们可以通过子树查询得到，<span class="math inline">\(siz\)</span> 我们只需要顺便维护就好了。</p>
<p>现在我们考虑回答询问。首先，我们需要用 <span class="math inline">\(O(\log^2n)\)</span> 个在树套树中的矩形定位出询问矩形，如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/08/24/dsjK6x.md.png"></p>
<p>其中每一个 <span class="math inline">\(A_{i,j}\)</span> 都是树套树中的矩形。那么我们用类似上面的容斥来计算答案：即求出每行和每列的答案，加上行列均不同的两块的贡献，再减去每一块内部的答案。那么有 <span class="math display">\[
\begin{aligned}
ans(1\dots w,1\dots h)=&amp;\sum\limits_{i=1}^w\sum\limits_{j=1}^hsiz(i,j)\sum\limits_{c=i+1}^w\sum\limits_{d=j+1}^hsiz(c,d)\\
+&amp;\sum\limits_{i=1}^wans(i,1\dots h)+\sum\limits_{i=1}^hans(1\dots w,i)\\
-&amp;\sum\limits_{i=1}^w\sum\limits_{j=1}^hans(i,j)
\end{aligned}
\]</span> 第一行和第三行我们直接在树套树上查询就可以了，注意第二行，我们发现这实际上仍旧是一个值域范围内的区间顺序对，但是这里值域范围一定出现在了树套树上，即只有 <span class="math inline">\(O(n\log n)\)</span> 种。并且如果这是一个 <span class="math inline">\(w\times n\)</span> 的矩形，由于我们给定的是一个排列，所以这个矩形内的数只有 <span class="math inline">\(w\)</span> 个。这样我们在这样的矩形查一次的复杂度是 <span class="math inline">\(O(\sqrt w)\)</span> 的，由于每一个长度的矩形只会出现 <span class="math inline">\(O(1)\)</span> 次，所以一次查询的总复杂度是 <span class="math inline">\(O(\sqrt n+\sqrt{\frac{n}{2}}+\sqrt{\frac{n}{4}}+\dots)=O((1+\frac{1}{\sqrt 2}+\frac{1}{2}+\dots)\sqrt n)=O(\sqrt n)\)</span> 的。预处理的复杂度类似，所以这个算法的总复杂度是 <span class="math inline">\(O(n\log^2n+T)\)</span>（<span class="math inline">\(T\)</span> 指区间逆序对复杂度）的，空间上如果用一般的树套树也是 <span class="math inline">\(O(n\log^2n+T)\)</span> 的。据官方题解说也可以做到一个 <span class="math inline">\(\log\)</span> 或者线性。</p>
<p>据 lxl 说，这样分治套分块似乎当分块的复杂度比 <span class="math inline">\(O(n^{1.5})\)</span> 低时才会更优秀。</p>
<h3 id="制作菜品">制作菜品</h3>
<p>通过观察样例和数据范围，我们可能有一个猜想：当 <span class="math inline">\(m\geqslant n-1\)</span> 时一定有解，这个结论我们可以通过归纳法证明：当 <span class="math inline">\(n\leqslant 2\)</span> 时显然成立，当 <span class="math inline">\(n&gt;2\)</span> 时，我们取剩余质量最小的食材，如果质量 <span class="math inline">\(\geqslant k\)</span>，那么一定有 <span class="math inline">\(m\geqslant n\)</span>，那么我们把这道菜全部用这个食材做，那么 <span class="math inline">\(m\)</span> 减小 <span class="math inline">\(1\)</span>，依旧满足 <span class="math inline">\(m\geqslant n-1\)</span>；如果质量 <span class="math inline">\(&lt;k\)</span>，我们再取质量最大的菜，不难证明两种菜的质量加起来一定 <span class="math inline">\(\geqslant k\)</span>，这样就相当于把第一种菜用掉，然后剩余要做的菜 <span class="math inline">\(-1\)</span>，即 <span class="math inline">\(m,n\)</span> 均减小 <span class="math inline">\(1\)</span>，依旧满足 <span class="math inline">\(m\geqslant n-1\)</span>。</p>
<p>然后我们考虑 <span class="math inline">\(m=n-2\)</span> 的情况，也不难有猜想：只有能够划分为两个 <span class="math inline">\(m=n-1\)</span> 的集合的时候有解。充分性显然，考虑必要性：当 <span class="math inline">\(m=1,n=3\)</span> 时无解，如果不能划分为两个 <span class="math inline">\(m=n-1\)</span> 的集合，那么每做一盘菜质量减为 <span class="math inline">\(0\)</span> 的食材数量一定 <span class="math inline">\(\leqslant1\)</span>（要不然我们就找到了一组划分），这样一直保持 <span class="math inline">\(m\leqslant n-2\)</span>，所以一定无解。</p>
<p>那么对于 <span class="math inline">\(m\geqslant n-1\)</span> 的情况，我们随便写个模拟就好了，对于 <span class="math inline">\(m=n-2\)</span> 的情况，如果我们设每种食材的权值为 <span class="math inline">\(d_i-k\)</span>，那么就相当于问有没有一个子集的权值和为 <span class="math inline">\(-k\)</span>，这是一个可行性背包，可以使用 <code>bitset</code> 优化，复杂度为 <span class="math inline">\(O(\frac{n^2k}{w})\)</span>，输出方案只需要找到的时候往前递归找就可以了。</p>
<p>代码（由于未知原因，这份代码在 windows 下似乎会 RE）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,id;</span><br><span class="line">&#125;v[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(dish x,dish y)</span></span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k,d[<span class="number">505</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt;ans[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">namespace</span> subtask1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sort(v+<span class="number">1</span>,v+n+<span class="number">1</span>,cmp);</span><br><span class="line">            ans[i].clear();</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">1</span>].w&gt;=k)ans[i].pb(mp(v[<span class="number">1</span>].id,k));</span><br><span class="line">            <span class="keyword">else</span> v[n].w-=k-v[<span class="number">1</span>].w,ans[i].pb(mp(v[<span class="number">1</span>].id,v[<span class="number">1</span>].w)),ans[i].pb(mp(v[n].id,k-v[<span class="number">1</span>].w));</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">1</span>].w&lt;=k)swap(v[<span class="number">1</span>],v[n]),n--;</span><br><span class="line">            <span class="keyword">else</span> v[<span class="number">1</span>].w-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ans[i].size();j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d "</span>,ans[i][j].first,ans[i][j].second);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> subtask2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;5000005&gt;f[<span class="number">505</span>];</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">505</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[x<span class="number">-1</span>][y])dfs(x<span class="number">-1</span>,y);</span><br><span class="line">        <span class="keyword">else</span> visited[x]=<span class="number">1</span>,v[++now].id=x,v[now].w=d[x],dfs(x<span class="number">-1</span>,y-k+d[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">2500001</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k-d[i]&gt;=<span class="number">0</span>)f[i]=((f[i<span class="number">-1</span>])|(f[i<span class="number">-1</span>]&lt;&lt;(k-d[i])));</span><br><span class="line">            <span class="keyword">else</span> f[i]=((f[i<span class="number">-1</span>])|(f[i<span class="number">-1</span>]&gt;&gt;(d[i]-k)));</span><br><span class="line">            <span class="keyword">if</span>(f[i][<span class="number">2500001</span>+k])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,<span class="number">2500001</span>+k);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        subtask1::main(now,now<span class="number">-1</span>);</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])v[++now].id=i,v[now].w=d[i];</span><br><span class="line">        subtask1::main(now,now<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d[i]);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;=n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i].id=i,v[i].w=d[i];</span><br><span class="line">            subtask1::main(n,m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> subtask2::main();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超现实树">超现实树</h3>
<p>设森林中最深的树的深度为 <span class="math inline">\(h\)</span>。我们定义一棵树为好的当且仅当对于每个节点，左右儿子的 <span class="math inline">\(size\)</span> 的较小值小于等于 <span class="math inline">\(1\)</span> （如果为空那么 <span class="math inline">\(size=0\)</span>），不难发现好树的形态一定是一条主链，然后链上每个点可能额外接了一个单独的节点。那么有以下结论：这个森林是几乎完备的当且仅当所有深度 <span class="math inline">\(\leqslant h\)</span> 的好的树都可以被生成。因为每一棵树都可以由至少一棵好树生成（把单独的叶子变成一棵树），如果有一棵好树无法被生成，一定存在一个叶子使得无论把叶子替换成什么树都无法生成（感性理解一下吧）。</p>
<p>这样，在给定的森林中，如果不是好的树，那么它一定没用（因为它无法生成任何一棵好树）。</p>
<p>我们递归判断一个森林是否是几乎完备的，如果为空，那么返回否，如果有单个节点的是，返回是，否则遍历每一棵树，可能分为以下情况：</p>
<ol type="1">
<li>根节点只有左子树，这时把根节点的左子树加入这种情况的集合中</li>
<li>根节点只有右子树，这时把根节点的右子树加入这种情况的集合中</li>
<li>根节点有左子树，且右子树大小为 <span class="math inline">\(1\)</span>，这时把根节点的左子树加入这种情况的集合中</li>
<li>根节点有右子树，且左子树大小为 <span class="math inline">\(1\)</span>，这时把根节点的右子树加入这种情况的集合中</li>
<li>根节点的左右子树大小均大于 <span class="math inline">\(1\)</span>，这时忽略这棵树</li>
</ol>
<p>显然每一棵树最多符合两种条件（当左右子树大小都为 <span class="math inline">\(1\)</span> 时同时满足 2,3），那么这个森林完备当且仅当前四种递归计算下去均满足，因为如果有一种不满足，我们等价于找到了一棵深度 <span class="math inline">\(\leqslant h\)</span> 的好树。这样一开始预处理好每个点的 <span class="math inline">\(size\)</span>，每个点只会造成 <span class="math inline">\(O(1)\)</span> 贡献，总复杂度为 <span class="math inline">\(O(\sum n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;l,r,siz;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;l.clear();r.clear();siz.clear();l.resize(n+<span class="number">1</span>);r.resize(n+<span class="number">1</span>);siz.resize(n+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        siz[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l[x])dfs(l[x]),siz[x]+=siz[l[x]];</span><br><span class="line">        <span class="keyword">if</span>(r[x])dfs(r[x]),siz[x]+=siz[r[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T[<span class="number">2000005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1,v2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id.size())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;id1,id2,id3,id4,root1,root2,root3,root4;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;id.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=id[i],y=root[i];</span><br><span class="line">        <span class="keyword">if</span>((!T[x].l[y])&amp;&amp;(!T[x].r[y]))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!T[x].r[y])id1.push_back(x),root1.push_back(T[x].l[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!T[x].l[y])id2.push_back(x),root2.push_back(T[x].r[y]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(T[x].siz[T[x].r[y]]==<span class="number">1</span>)id3.push_back(x),root3.push_back(T[x].l[y]);</span><br><span class="line">            <span class="keyword">if</span>(T[x].siz[T[x].l[y]]==<span class="number">1</span>)id4.push_back(x),root4.push_back(T[x].r[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(id1,root1)&amp;&amp;check(id2,root2)&amp;&amp;check(id3,root3)&amp;&amp;check(id4,root4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        v1.clear(),v2.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T[i].n);</span><br><span class="line">            T[i].init();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=T[i].n;j++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;T[i].l[j],&amp;T[i].r[j]);</span><br><span class="line">            T[i].dfs(<span class="number">1</span>);</span><br><span class="line">            v1.push_back(i),v2.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check(v1,v2))<span class="built_in">puts</span>(<span class="string">"Almost Complete"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>套题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2016」循环之美</title>
    <url>/2020/08/11/%E3%80%8CNOI2016%E3%80%8D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<p>求 <span class="math inline">\(k\)</span> 进制下可以表示为纯循环小数（认为整数也是）的既约分数 <span class="math inline">\(\dfrac{i}{j}\)</span>，且 <span class="math inline">\(1\leqslant i\leqslant n\)</span>，<span class="math inline">\(1\leqslant j\leqslant m\)</span> 的个数。<span class="math inline">\(n,m\leqslant 10^9\)</span>，<span class="math inline">\(k\leqslant 2000\)</span>。</p>
<a id="more"></a>
<p>经过尝试可以发现，既约分数 <span class="math inline">\(\dfrac{i}{j}\)</span> 在 <span class="math inline">\(k\)</span> 进制下是纯循环的当且仅当 <span class="math inline">\(\gcd(j,k)=1\)</span>（证明可以见其它题解）。</p>
<p>所以，我们只需要求 <span class="math display">\[
\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\gcd(i,j)=1][\gcd(j,k)=1]
\]</span> 因为要既约分数，所以要保证 <span class="math inline">\(\gcd(i,j)=1\)</span>。</p>
<p>因为两个 <span class="math inline">\(\gcd\)</span> 都与 <span class="math inline">\(j\)</span> 有关，我们考虑把 <span class="math inline">\(j\)</span> 提到外面 <span class="math display">\[
ans=\sum\limits_{j=1}^m[\gcd(j,k)=1]\sum\limits_{i=1}^n[\gcd(i,j)=1]
\]</span> 然后我们对后面来一次莫比乌斯反演 <span class="math display">\[
\begin{aligned}
ans&amp;=\sum\limits_{j=1}^m[\gcd(j,k)=1]\sum\limits_{i=1}^n\sum\limits_{d\mid i,d\mid j}\mu(d)\\
&amp;=\sum\limits_{j=1}^m[\gcd(j,k)=1]\sum\limits_{d\mid j}\lfloor\frac{n}{d}\rfloor\mu(d)
\end{aligned}
\]</span> 然后我们把 <span class="math inline">\(d\)</span> 提到前面去 <span class="math display">\[
ans=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor\mu(d)\sum\limits_{d\mid j,j\leqslant m}[\gcd(j,k)=1]
\]</span> 我们发现，<span class="math inline">\(j\)</span> 可以表示为 <span class="math inline">\(xd\)</span>，那么 <span class="math inline">\(\gcd(j,k)=1\)</span> 等价于 <span class="math inline">\(\gcd(x,k)=1\)</span> 且 <span class="math inline">\(\gcd(d,k)=1\)</span> ，于是我们有 <span class="math display">\[
ans=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor\mu(d)[\gcd(d,k)=1]\sum\limits_{x=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(x,k)=1]
\]</span> 然后我们观察第二个求和号，如果我们设 <span class="math inline">\(f(z)=\sum\limits_{i=1}^z[\gcd(i,k)=1]\)</span>，那么后面的就是 $ f()$。</p>
<p>我们考虑是否能够快速计算 <span class="math inline">\(f\)</span>，根据辗转相除（减）法的原理，我们有 <span class="math inline">\(\gcd(x,k)=\gcd(x+k,k)\)</span>，所以我们有 <span class="math display">\[
f(z)=\lfloor \frac{z}{k}\rfloor f(k)+f(z\bmod k)
\]</span> 即我们按照每个数模 <span class="math inline">\(k\)</span> 的余数将其分为若干等价类。这样我们只需要预处理 <span class="math inline">\(f(1)\dots f(k)\)</span> 就可以在 <span class="math inline">\(O(1)\)</span> 时间内计算 <span class="math inline">\(f(z)\)</span>。</p>
<p>那么有 <span class="math display">\[
ans=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor f(\lfloor\frac{m}{d}\rfloor)\mu(d)[\gcd(d,k)=1]
\]</span> 我们发现，如果我们可以快速计算 <span class="math inline">\(\mu(d)[\gcd(d,k)=1]\)</span> 的前缀和，我们就可以通过整除分块计算答案，那么问题就转化为了快速计算 <span class="math inline">\(\mu(d)[\gcd(d,k)=1]\)</span> 的前缀和。</p>
<p>我们设 <span class="math inline">\(g(z)=\sum\limits_{d=1}^z\mu(d)[\gcd(d,k)=1]\)</span>，那么我们再来一次莫比乌斯反演： <span class="math display">\[
\begin{aligned}
g(z)&amp;=\sum\limits_{d=1}^z\mu(d)\sum\limits_{t\mid d,t\mid k}\mu(t)\\
&amp;=\sum\limits_{t\mid k}\mu(t)\sum\limits_{t\mid d,d\leqslant z}\mu(d)\\
&amp;=\sum\limits_{t\mid k}\mu(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(dt)\\
\end{aligned}
\]</span> 我们发现，如果 <span class="math inline">\(\gcd(d,t)\not= 1\)</span>，那么 <span class="math inline">\(dt\)</span> 一定含有平方因子（<span class="math inline">\(\gcd(d,t)^2\)</span>），所以这时 <span class="math inline">\(\mu(dt)=0\)</span>，由于我们只在乎和，所以我们可以只对 <span class="math inline">\(\mu(dt)\not=0\)</span>，即 <span class="math inline">\(\gcd(d,t)=1\)</span> 的情况计算。那么有： <span class="math display">\[
g(z)=\sum\limits_{t\mid k}\mu(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(dt)[\gcd(d,t)=1]
\]</span> 这样由于我们强制令 <span class="math inline">\(d,t\)</span> 互质，我们就可以把 <span class="math inline">\(\mu(dt)\)</span> 拆成 <span class="math inline">\(\mu(d)\mu(t)\)</span>： <span class="math display">\[
\begin{aligned}
g(z)&amp;=\sum\limits_{t\mid k}\mu(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(d)\mu(t)[\gcd(d,t)=1]\\
&amp;=\sum\limits_{t\mid k}\mu^2(t)\sum\limits_{d=1}^{\lfloor\frac{z}{t}\rfloor}\mu(d)[\gcd(d,t)=1]
\end{aligned}
\]</span> 我们发现第二个求和号后面的东西和 <span class="math inline">\(g\)</span> 很像，不过是 <span class="math inline">\([\gcd(d,t)=1]\)</span> 而不是 <span class="math inline">\([\gcd(d,k)=1]\)</span>，为此我们扩展一下 <span class="math inline">\(g\)</span> 的定义，设 <span class="math inline">\(g(z,c)=\sum\limits_{i=1}^z\mu(i)[\gcd(i,c)=1]\)</span>，那么 <span class="math display">\[
g(z,c)=\sum\limits_{t\mid c}\mu^2(t)g(\lfloor\frac{z}{t}\rfloor,t)
\]</span> 边界条件为 <span class="math inline">\(c=1\)</span>，此时就是莫比乌斯函数的前缀和，可以杜教筛求解。注意计算时要记忆化，复杂度据说是 <span class="math inline">\(O(n^{\frac{2}{3}}+\sigma_0(k)\sqrt n)\)</span> 的，不会证。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> N=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> k,p[N+<span class="number">5</span>],mu[N+<span class="number">5</span>],smu[N+<span class="number">5</span>],cnt,F[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y?gcd(y,x%y):x;&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=N)<span class="keyword">return</span> smu[n];</span><br><span class="line">    <span class="keyword">if</span>(mp2.find(n)!=mp2.end())<span class="keyword">return</span> mp2[n];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">        r=(n/(n/l)),ans-=(r-l+<span class="number">1</span>)*s(n/l);</span><br><span class="line">    <span class="keyword">return</span> mp2[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">return</span> (n/k)*F[k]+F[n%k];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> z,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">1</span>)<span class="keyword">return</span> s(z);</span><br><span class="line">    <span class="keyword">if</span>(!z)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp.find(make_pair(z,c))!=mp.end())<span class="keyword">return</span> mp[make_pair(z,c)];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:v[c])</span><br><span class="line">        <span class="keyword">if</span>(mu[i])ans+=g(z/i,i);</span><br><span class="line">    <span class="keyword">return</span> mp[make_pair(z,c)]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])&#123;p[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%p[j]))&#123;mu[i*p[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            mu[i*p[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)smu[i]=smu[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)F[i]=F[i<span class="number">-1</span>]+(gcd(k,i)==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=k;j+=i)</span><br><span class="line">            v[j].push_back(i);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=min(n,m);l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=<span class="number">1l</span>l*(n/l)*f(m/l)*(g(r,k)-g(l<span class="number">-1</span>,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC047 部分题解</title>
    <url>/2020/08/10/AtCoder%20Grand%20Contest%20047%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="a---integer-product">A - Integer Product</h2>
<p>由于每一个数都可以表示为十进制下的有限小数，所以化成分数后其分母的只可能含有 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(5\)</span> 两个质因子。记录其次数，那么就是求 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(5\)</span> 的次数加起来都大于等于 <span class="math inline">\(0\)</span> 的数对个数。这个可以开一个桶暴力计算。</p>
<p>为了方便，一开始把每个数都乘上 <span class="math inline">\(10^9\)</span>，这样求的就是次数加起来大于等于 <span class="math inline">\(18\)</span> 的数对个数。复杂度 <span class="math inline">\(O(n\log^2n)\)</span>（实际上是次数的乘积之和，应该比这个小）。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/15784117" target="_blank" rel="noopener">代码</a></p>
<a id="more"></a>
<h2 id="b---first-second">B - First Second</h2>
<p>不难发现，如果 <span class="math inline">\(T\)</span> 能从 <span class="math inline">\(S\)</span> 得到，那么 <span class="math inline">\(T\)</span> 一定可以表示为 <span class="math inline">\(S\)</span> 中的一个字符拼上 <span class="math inline">\(S\)</span> 的一个后缀（可以为空后缀，字符必须在后缀前）。</p>
<p>考虑用 Trie 树，我们每一次倒着插入一个 <span class="math inline">\(S_i\)</span>，额外开一个数组 <code>sum[x][c]</code> 记录 <span class="math inline">\(x\)</span> 的子树内字符 <span class="math inline">\(c\)</span> 的出边数量，这样每走一步我们都看一下 <span class="math inline">\(S\)</span> 前面的字符种类，如果有把 <code>sum[x][c]</code> 对应加上 1，全插入完以后再查询一下就做完了。复杂度 <span class="math inline">\(O(26\sum|S|)\)</span>。上述操作也可以通过哈希完成，但是我一开始写的哈希跑的太慢了过不去。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/15788874" target="_blank" rel="noopener">代码</a></p>
<h2 id="c---product-modulo">C - Product Modulo</h2>
<p>我们发现模数很小而且是质数，所以我们考虑计算 <span class="math inline">\(A_iA_j=c\)</span> 的 <span class="math inline">\((i,j)\)</span> 的数量。因为是质数，存在原根（温馨提示 <span class="math inline">\(200003\)</span> 的一个原根是 <span class="math inline">\(5\)</span>），所以我们可以把每一个数都取离散对数，那么乘法就变成了加法，这样可以通过 FFT 快速计算（注意不能用单模 NTT 可能会爆）。复杂度 <span class="math inline">\(O(n+p\log p)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/15810387" target="_blank" rel="noopener">代码</a></p>
<h2 id="d---twin-binary-trees">D - Twin Binary Trees</h2>
<p>首先我们发现如果我们确定了两条特殊边，那么我们就唯一确定了一条回路。我们考虑枚举这条回路在第一棵树上的 LCA，那么所有的回路在第一棵树上的叶子一定分别在两个子树内。</p>
<p>我们设两棵子树分别为 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(R\)</span>，我们先枚举 <span class="math inline">\(L\)</span> 中的每个叶子，然后我们参照 LNOI LCA 那道题的套路，把第二棵树中对应叶子（通过特殊边连接的）到第二棵树上的根上的每个节点加上从枚举的 LCA 到这个节点的编号乘积。然后我们枚举 <span class="math inline">\(R\)</span> 中的叶子，并从第二棵树中对应的叶子向上跳，那么每当我们跳到一个点 <span class="math inline">\(x\)</span> 时，在第二棵树的 LCA 为这个点的所有回路的总贡献为 <span class="math inline">\(\text{dis}(LCA,x)\cdot(w[x]-x\cdot w[pre])\)</span>，其中 <span class="math inline">\(pre\)</span> 是上一个经过的点，<span class="math inline">\(w\)</span> 是点上的权值， <span class="math inline">\(\text{dis}\)</span> 为 LCA 到 <span class="math inline">\(x\)</span> 路径点的乘积（不含端点），要减去 <span class="math inline">\(x\cdot w[pre]\)</span> 是因为要减去 LCA 已经被算过的部分。这样总复杂度为 <span class="math inline">\(O(H^22^H)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/15812896" target="_blank" rel="noopener">代码</a></p>
]]></content>
      <tags>
        <tag>套题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「HNOI2019」白兔之舞</title>
    <url>/2020/08/05/%E3%80%8CHNOI2019%E3%80%8D%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5293" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>我们先来考虑，如果给定 <span class="math inline">\(m\)</span>（长度），怎么求方案数。</p>
<p>显然我们可以把横着（二元组的第一维）的单独考虑，即我们要在 <span class="math inline">\(L\)</span> 个横坐标内选出 <span class="math inline">\(m\)</span> 个经过的横坐标，这部分的方案为 <span class="math inline">\(\dbinom{L}{m}\)</span>；然后考虑纵坐标，当 <span class="math inline">\(n=1\)</span> 的时候显然是 <span class="math inline">\(w_{1,1}^m\)</span>，当 <span class="math inline">\(n&gt;1\)</span> 时，如果上一步在 <span class="math inline">\(a\)</span>，发现会给下一步的 <span class="math inline">\(1-n\)</span> 分别贡献 <span class="math inline">\(w_{a,1},w_{a,2},\dots,w_{a,n}\)</span>，发现这是一个矩阵乘法的形式，记 <span class="math inline">\(W\)</span> 为 <span class="math display">\[
\begin{bmatrix}
w_{1,1}  &amp; \dots &amp; w_{1,n}\\
\vdots  &amp; \ddots &amp;  \vdots \\
w_{n,1}  &amp; \dots &amp; w_{n,n}
\end{bmatrix}
\]</span> 即第二维的邻接矩阵，为了防止变量重复，我们记题目中的 <span class="math inline">\(x,y\)</span> 为 <span class="math inline">\(a,b\)</span>，那么 <span class="math inline">\(\dbinom{L}{m}W^m_{a,b}\)</span> 就是答案。</p>
<p>然后我们考虑用多项式来表示这个式子，即我们构造一个系数为矩阵的多项式： <span class="math display">\[
F(x)=(I+Wx)^L
\]</span> 其中 <span class="math inline">\(I\)</span> 是单位矩阵，则 <span class="math inline">\(\left([x^m]F(x)\right)_{a,b}\)</span> 就是答案。</p>
<p>那么我们考虑题目要求的是所有模 <span class="math inline">\(k\)</span> 等于 <span class="math inline">\(t\)</span> 的 <span class="math inline">\(m\)</span> 的答案之和，即 <span class="math display">\[
\sum\limits_{m\equiv t\pmod k}\left([x^m]F(x)\right)_{a,b}
\]</span> 那么我们就是要求 <span class="math display">\[
ans_t=\sum\limits_{m\equiv t\pmod k}\left([x^m]F(x)\right)_{a,b}
\]</span> 根据单位根反演的简单推广，可以得到 <span class="math display">\[
\begin{aligned}
ans_t&amp;=\sum\limits_{m\equiv t\pmod k}\left([x^m]F(x)\right)_{a,b}\\
&amp;=\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{-tj}F(w_k^j)_{a,b}
\end{aligned}
\]</span> 推导过程可以看<a href="https://s1rius.gitee.io/2020/07/28/单位根反演/#more" target="_blank" rel="noopener">这里</a>，注意单位根反演对矩阵也是成立的（似乎只需要满足数乘对加法有分配律就可以）。</p>
<p>显然 <span class="math inline">\(F(w_k^j)_{a,b}\)</span> 可以通过矩阵快速幂来求（把邻接矩阵乘上 <span class="math inline">\(w_k^j\)</span> 再加上单位矩阵的 <span class="math inline">\(L\)</span> 次方），现在的问题就是我们要对每个 <span class="math inline">\(0\leqslant t\leqslant k-1\)</span> 都求出 <span class="math inline">\(ans_t\)</span>。</p>
<p>发现这是一个任意基 IDFT 的形式，并且不一定存在 <span class="math inline">\(2k\)</span> 次单位根，我们考虑使用 Bluestein's Algorithm 的形式二，即把 <span class="math inline">\(-tj\)</span> 拆成 <span class="math inline">\(\dbinom{t}{2}+\dbinom{j}{2}-\dbinom{t+j}{2}\)</span>，那么带入并化简： <span class="math display">\[
\begin{aligned}
ans_t&amp;=\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{-tj}F(w_k^j)_{a,b}\\
&amp;=\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}F(w_k^j)_{a,b}\\
&amp;=\frac{w_k^{\binom{t}{2}}}{k}\sum\limits_{j=0}^{k-1}w_k^{\binom{j}{2}-\binom{t+j}{2}}F(w_k^j)_{a,b}\\
\end{aligned}
\]</span> 设 <span class="math inline">\(A(x)=\sum\limits_iw_k^{\binom{i}{2}}F(w_k^j)_{a,b}x^i\)</span>，<span class="math inline">\(B(x)=\sum\limits_iw_k^{-\binom{i}{2}}x^i\)</span>后面是一个差一定的卷积形式，可以通过反转 <span class="math inline">\(B\)</span> 求解。</p>
<p>由于这题不一定是 NTT 模数，所以需要自己找到原根然后写一个 MTT。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">400005</span>],G[<span class="number">400005</span>],H[<span class="number">400005</span>],g,n,k,l,a,b,p;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">const</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> r,i;</span><br><span class="line">        comp()&#123;r=i=<span class="number">0</span>;&#125;</span><br><span class="line">        comp(<span class="keyword">long</span> <span class="keyword">double</span> x,<span class="keyword">long</span> <span class="keyword">double</span> y)&#123;r=x,i=y;&#125;</span><br><span class="line">        <span class="function">comp <span class="title">conj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> comp(r,-i);&#125;</span><br><span class="line">        <span class="keyword">friend</span> comp <span class="keyword">operator</span> +(comp x,comp y)&#123;<span class="keyword">return</span> comp(x.r+y.r,x.i+y.i);&#125;</span><br><span class="line">        <span class="keyword">friend</span> comp <span class="keyword">operator</span> -(comp x,comp y)&#123;<span class="keyword">return</span> comp(x.r-y.r,x.i-y.i);&#125;</span><br><span class="line">        <span class="keyword">friend</span> comp <span class="keyword">operator</span> *(comp x,comp y)&#123;<span class="keyword">return</span> comp(x.r*y.r-x.i*y.i,x.i*y.r+x.r*y.i);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">400005</span>];</span><br><span class="line">    comp a[<span class="number">400005</span>],b[<span class="number">400005</span>],c[<span class="number">400005</span>],d[<span class="number">400005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            comp wn=comp(<span class="built_in">cos</span>(pi/q),op*<span class="built_in">sin</span>(pi/q));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            &#123;</span><br><span class="line">                comp w=comp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;j++,w=w*wn)</span><br><span class="line">                &#123;</span><br><span class="line">                    comp d=f[j+q]*w;</span><br><span class="line">                    f[j+q]=f[j]-d;</span><br><span class="line">                    f[j]=f[j]+d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mtt</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> *h,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            a[i].r=(f[i]&gt;&gt;<span class="number">15</span>),a[i].i=(f[i]&amp;<span class="number">32767</span>),</span><br><span class="line">            c[i].r=(g[i]&gt;&gt;<span class="number">15</span>),c[i].i=(g[i]&amp;<span class="number">32767</span>);</span><br><span class="line">        fft(a,n,<span class="number">1</span>),fft(c,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)b[i]=a[n-i].conj();</span><br><span class="line">        b[<span class="number">0</span>]=a[<span class="number">0</span>].conj();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)d[i]=c[n-i].conj();</span><br><span class="line">        d[<span class="number">0</span>]=c[<span class="number">0</span>].conj();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            comp </span><br><span class="line">            aa=(a[i]+b[i])*comp(<span class="number">0.5</span>,<span class="number">0</span>),</span><br><span class="line">            bb=(a[i]-b[i])*comp(<span class="number">0</span>,<span class="number">-0.5</span>),</span><br><span class="line">            cc=(c[i]+d[i])*comp(<span class="number">0.5</span>,<span class="number">0</span>),</span><br><span class="line">            dd=(c[i]-d[i])*comp(<span class="number">0</span>,<span class="number">-0.5</span>);</span><br><span class="line">            a[i]=aa*cc+comp(<span class="number">0</span>,<span class="number">1</span>)*(aa*dd+bb*cc),b[i]=bb*dd;</span><br><span class="line">        &#125;</span><br><span class="line">        fft(a,n,<span class="number">-1</span>),fft(b,n,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> </span><br><span class="line">            aa=(ll)(a[i].r/n+<span class="number">0.5</span>)%p,</span><br><span class="line">            bb=(ll)(a[i].i/n+<span class="number">0.5</span>)%p,</span><br><span class="line">            cc=(ll)(b[i].r/n+<span class="number">0.5</span>)%p;</span><br><span class="line">            h[i]=((<span class="number">1l</span>l*aa*(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)+<span class="number">1l</span>l*bb*(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+cc)%p+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> poly::mtt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">int</span> t=p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(t%i))</span><br><span class="line">        &#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">            <span class="keyword">while</span>(!(t%i))t/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=p<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v.size();j++)</span><br><span class="line">            <span class="keyword">if</span>(pw(i,(p<span class="number">-1</span>)/v[j])==<span class="number">1</span>)&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    matrix()&#123;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));&#125;</span><br><span class="line">    <span class="keyword">friend</span> matrix <span class="keyword">operator</span> *(matrix a,matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                    tmp.s[i][j]=mod(tmp.s[i][j]+<span class="number">1l</span>l*a.s[i][k]*b.s[k][j]%p);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> matrix <span class="keyword">operator</span> *(<span class="keyword">int</span> a,matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                b.s[i][j]=<span class="number">1l</span>l*b.s[i][j]*a%p;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> matrix <span class="keyword">operator</span> +(matrix a,matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                b.s[i][j]=mod(a.s[i][j]+b.s[i][j]);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;W,I;</span><br><span class="line"><span class="function">matrix <span class="title">pw2</span><span class="params">(matrix x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix res=I;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=res*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;n,&amp;k,&amp;l,&amp;a,&amp;b,&amp;p);</span><br><span class="line">    g=get(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;W.s[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)I.s[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wk=pw(g,(p<span class="number">-1</span>)/k),w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++,w=<span class="number">1l</span>l*w*wk%p)</span><br><span class="line">        F[i]=<span class="number">1l</span>l*pw(wk,(<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>)%k)*pw2(w*W+I,l).s[a][b]%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)</span><br><span class="line">        G[i]=<span class="number">1l</span>l*pw(wk,(p<span class="number">-1</span>-(<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k)));</span><br><span class="line">    reverse(G,G+(k&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1</span>,inv=pw(k,p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(k&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    mtt(F,G,H,lim,p);</span><br><span class="line">    reverse(H,H+(k&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="number">1l</span>l*inv*H[i]%p*pw(wk,(<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>)%k)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>FFT</tag>
        <tag>单位根反演</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2018」冒泡排序</title>
    <url>/2020/08/04/%E3%80%8CNOI2018%E3%80%8D%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4769" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>我们先来考虑，好的排列满足什么性质。不难发现，如果这个排列的最长下降子序列长度大于 2，那么这个排列一定不是好的排列，设不满足的 3 个数为 <span class="math inline">\(c,b,a(c&gt;b&gt;a)\)</span>，那么 <span class="math inline">\(c\)</span> 要移到 <span class="math inline">\(b\)</span> 的右面，一定会和 <span class="math inline">\(b\)</span> 交换一次，然后 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span> 再交换一次，这时变成了 <span class="math inline">\(b,a,c\)</span>，还需要额外交换一次。现在我们再来证明一下这个条件也是充分条件：</p>
<p>我们发现，如果要保证这个排列是好的排列，我们改变任何一个数的位置的时候，都需要让它往它应该在的位置移动，也就是说，如果 <span class="math inline">\(p_i&lt;i\)</span>，那么 <span class="math inline">\(p_i\)</span> 一定只会向左移动，<span class="math inline">\(p_i&gt;i\)</span> 同理，当 <span class="math inline">\(p_i=i\)</span> 时，这个位置不能移动，反之，如果不是好的排列，至少有一次交换使得某一个数距离它应该在的位置变远了。</p>
<p>考虑任何一次交换，设我们交换的数为 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_{i+1}\)</span>，那么我们有 <span class="math inline">\(p_i&gt;p_{i+1}\)</span>，由不存在长度为 3 的下降子序列我们可知 <span class="math inline">\(p_1\dots p_{i-1}&lt;p_i\)</span>，<span class="math inline">\(p_{i+2}\dots p_n&gt;p_{i+1}\)</span>，这样就有 <span class="math inline">\(p_{i+1}&lt;i+1\)</span>，<span class="math inline">\(p_i&gt;i\)</span>，故这一次交换两个数都往应该走的方向走了，显然这样的交换不会增加最长下降子序列的长度。</p>
<p>这样我们就证明了不存在长度为 3 的最长下降子序列是好的排列的充要条件。</p>
<p>现在我们考虑计算方案数。我们先忽略字典序的限制，即让 <span class="math inline">\(p_i=i\)</span>，设 <span class="math inline">\(f(i,j)\)</span> 为填了前 <span class="math inline">\(i\)</span> 个位置，填过的最大的数为 <span class="math inline">\(j\)</span> 的方案数，我们先给出递推式： <span class="math display">\[
f(i,j)=\sum\limits_{k=i-1}^jf(i-1,k)
\]</span> 这个的意思是，如果我们现在填的数比之前都大，显然不会造成影响，所以可以任意填一个比当前最大值大的数；如果我们现在填的数比之前小，那么一定只能填没有填过的最小的数，因为如果填了一个不是最小的数，迟早要把最小的数填上，这样就构成了一个长度为 3 的下降子序列。不难证明按照这样填也一定不会出现长度为 3 的下降子序列（考虑反证，第三个数一定是最小的数转移的，如果在之前已经存在了长度为 2 的下降子序列，那说明填第二个数的时候填的不是当前最小值）。</p>
<p>然后我们可以改写一下 dp 的转移方程。 <span class="math display">\[
f(i,j)=f(i,j-1)+f(i-1,j)
\]</span> 且 <span class="math inline">\(f(i,j)=0,j&lt;i\)</span>。</p>
<p>我们发现，这等价于在平面直角坐标系中，只能向右或向上走，从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((i,j)\)</span>，且一直在直线 <span class="math inline">\(y=x\)</span> 上方的方案数。我们要求的是 <span class="math inline">\(f(n,n)\)</span>，这个的方案数便是卡特兰数 <span class="math inline">\(C_n\)</span>。</p>
<p>现在我们要把字典序的限制加上，经典的处理方法是枚举实际排列和要求排列的 LCP。我们假定在第 <span class="math inline">\(i\)</span> 位实际排列和要求排列不同，那么我们这一位一定比之前大。设从第 <span class="math inline">\(i+1\)</span> 位开始不同，前 <span class="math inline">\(i\)</span> 位中最大值为 <span class="math inline">\(mx\)</span>，那么方案数就是 <span class="math inline">\((i-1,mx+1)\)</span> 到 <span class="math inline">\((n,n)\)</span> 一直在 <span class="math inline">\(y=x\)</span> 下方的方案数。这实际上是卡特兰数的一个扩展，可以发现所有跨过 <span class="math inline">\(y=x\)</span> 的路径都经过了 <span class="math inline">\(y=x-1\)</span>，所以对这些路径关于 <span class="math inline">\(y=x-1\)</span> 对称，这样就等价于 <span class="math inline">\((i-1,mx+1)\)</span> 到 <span class="math inline">\((n+1,n-1)\)</span> 的方案数，这样的总方案数为 <span class="math inline">\(\dbinom{2n-i-mx}{n-i+1}-\dbinom{2n-i-mx}{n-i+2}\)</span>。</p>
<p>需要注意的是如果给定的排列某一位比前缀最大值小，而且这一位并不是剩余的最小值，这样后面全部不合法，需要直接 <code>break</code> 掉。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">1200005</span>],inv[<span class="number">1200005</span>],r[<span class="number">1200005</span>],mx[<span class="number">1200005</span>],mn[<span class="number">1200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l*fac[n]*inv[m]%p*inv[n-m]%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1200000</span>;i++)fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    inv[<span class="number">1200000</span>]=pw(fac[<span class="number">1200000</span>],p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1199999</span>;i&gt;=<span class="number">1</span>;i--)inv[i]=<span class="number">1l</span>l*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,mx=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r[i]);</span><br><span class="line">        mn[n]=r[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)mn[i]=min(mn[i+<span class="number">1</span>],r[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mx=max(mx,r[i]);</span><br><span class="line">            ans+=(<span class="number">1l</span>l*c(<span class="number">2</span>*n-i-mx,n-i+<span class="number">1</span>)-c(<span class="number">2</span>*n-i-mx,n-i+<span class="number">2</span>)+p)%p;</span><br><span class="line">            ans%=p;</span><br><span class="line">            <span class="keyword">if</span>(r[i]&lt;mx&amp;&amp;r[i]!=mn[i])<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2019」序列</title>
    <url>/2020/08/03/%E3%80%8CNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>给定两个长为 <span class="math inline">\(n\)</span> 的正整数序列 <span class="math inline">\(\{a_n\},\{b_n\}\)</span>，现在让你在每个序列中都选 <span class="math inline">\(k\)</span> 个下标，并且在两个序列中都被选中的下标个数不少于 <span class="math inline">\(L\)</span>，最大化选中的下标对应的数之和。<span class="math inline">\(n\leqslant 2\times 10^5\)</span>。 <a id="more"></a></p>
<p>我们认为一次操作为各选中 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 中的一个未被选中的下标。我们发现两个序列中都被选中的下标个数不少于 <span class="math inline">\(L\)</span>，等价于最多 <span class="math inline">\(k-L\)</span> 次操作选中的下标不同。这样我们可以建出一个费用流模型：</p>
<p><img src="/2020/08/03/%E3%80%8CNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/1.png"></p>
<p>括号里的是边权，第一个数是流量大小，第二个数是费用，同类边只标注了一次边权，这样 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的流量恰好为 <span class="math inline">\(k\)</span> 时的费用就是答案。这个算法的正确性比较显然，只有通过红色边才能增广出 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 下标不同的情况，而最多只能进行 <span class="math inline">\(k-L\)</span> 次这样的增广，而且我们每一次单路增广增加的流量一定为 1。</p>
<p>如果直接写一个 SPFA 费用流，这样的复杂度为 <span class="math inline">\(O(nmk)\)</span>，实际跑不满似乎可以拿到 64 分。</p>
<p>然后是重头戏模拟费用流部分。首先我们定义红边的剩余流量为自由流的大小。很显然，如果自由流有剩余，那么一次增广通过红边增广的权值一定最大，因为它可以覆盖任何匹配。</p>
<p>我们考虑增广的情况：</p>
<ol type="1">
<li><p>通过 <span class="math inline">\(C,D\)</span> 增广了一条 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的下标不同的情况。（如果增广了下标相同的点我们可以归为第二种情况，也就是不要白消耗自由流了），这等价于匹配了一对下标不同的数。</p></li>
<li><p>直接走一条 <span class="math inline">\(s\rightarrow a_i\rightarrow b_i\rightarrow t\)</span> 的增广路，这等价于匹配了一对下标相同的数。</p></li>
<li><p>考虑退流，走了一条 <span class="math inline">\(s\rightarrow a_i\rightarrow C\rightarrow a_j\rightarrow b_j\rightarrow t\)</span> 的增广路，设原来和 <span class="math inline">\(a_j\)</span> 匹配的为 <span class="math inline">\(b_k\)</span>，那么这等价于把原来的 <span class="math inline">\(a_j-b_k\)</span> 这个匹配取消，然后新添加 <span class="math inline">\(a_j-b_j\)</span> 和 <span class="math inline">\(a_i-b_k\)</span> 两对匹配。这样会使匹配数量增加 1，自由流数量不变或 <span class="math inline">\(+1\)</span>（具体情况见后面）。</p></li>
<li><p>类似情况 3，走一条 <span class="math inline">\(s\rightarrow a_j\rightarrow b_j\rightarrow D\rightarrow b_i\rightarrow t\)</span> 的增广路，这等价于把 <span class="math inline">\(a_k-b_j\)</span> 这个匹配取消，新增 <span class="math inline">\(a_j-b_j\)</span> 和 <span class="math inline">\(a_k-b_i\)</span> 两对匹配。</p></li>
</ol>
<p>这样，我们开一个变量 <code>left</code> 记录自由流的大小，如果还有自由流，我们优先用自由流，因为一定不劣。否则，我们选择剩下几种方案中权值最高的那个。</p>
<p>实现上，我们需要开 5 个堆，分别维护未匹配的 <span class="math inline">\(a_i/b_i\)</span> 的值，未匹配的 <span class="math inline">\(a_i+b_i\)</span> 的值，匹配过但是没有固定（指这个点不通过红色边增广，显然，如果一个点通过了蓝色边增广，那么它的匹配一定不会变）的 <span class="math inline">\(a_i/b_i\)</span> 所对应的 <span class="math inline">\(b_i/a_i\)</span> 的值。然后有一些操作会导致自由流变多，下面列出来：</p>
<p>下面认为橙色为现在匹配的两个点：</p>
<figure>
<img src="/2020/08/03/%E3%80%8CNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/2.png" alt><figcaption>情况1</figcaption>
</figure>
<figure>
<img src="/2020/08/03/%E3%80%8CNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/3.png" alt><figcaption>情况2</figcaption>
</figure>
<p>如果是类型 1，那么自由流额外 +1（我们认为只要出现一次类型 1，自由流都减小 1，也就是说这样等价于自由流大小最终没有变化），要不然就是类型 3 或 4，这种情况自由流不变。</p>
<figure>
<img src="/2020/08/03/%E3%80%8CNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/4.png" alt><figcaption>情况3</figcaption>
</figure>
<figure>
<img src="/2020/08/03/%E3%80%8CNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/5.png" alt><figcaption>情况4</figcaption>
</figure>
<p>这两种情况（本质上是一种，即现在匹配的两个点在另外一个序列中都被匹配过了）出现在类型 1 时，自由流额外 +2；出现在类型 3 或 4 时，自由流额外 +1。</p>
<p>至于如何判断，我们开两个数组记录每个数是否被增广过，同时这个作为懒惰删除的标记，如果不明白代码不是很长可以看代码。</p>
<p>由于我们每一次的操作都等价于在费用流图中的增广，且每次都是最长路，所以这个算法是正确的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> input</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> InputBufferSize=(<span class="number">1</span>&lt;&lt;<span class="number">25</span>)+<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[InputBufferSize],*s,*eof;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assert(<span class="built_in">stdin</span>!=<span class="literal">NULL</span>);</span><br><span class="line">        s=buffer;</span><br><span class="line">        eof=s+fread(buffer,<span class="number">1</span>,InputBufferSize,<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(*s)&amp;&amp;*s!=<span class="string">'-'</span>)s++;</span><br><span class="line">        <span class="keyword">if</span>(eof&lt;=s)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'-'</span>)flag=<span class="number">-1</span>,s++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s))x=x*<span class="number">10</span>+*s++-<span class="string">'0'</span>;</span><br><span class="line">        x*=flag;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> input;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line">priority_queue&lt;pii&gt;q1,q2,q3,q4,q5;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>],b[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">200005</span>],visited2[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    read(_);</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>]=b[<span class="number">0</span>]=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty())q2.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q3.empty())q3.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q4.empty())q4.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q5.empty())q5.pop();</span><br><span class="line">        <span class="keyword">int</span> n,k,l,left;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        read(n),read(k),read(l);</span><br><span class="line">        left=k-l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)read(a[i]),q1.push(mp(a[i],i)),visited[i]=visited2[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)read(b[i]),q2.push(mp(b[i],i)),q3.push(mp(a[i]+b[i],i));</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left)<span class="comment">//类型 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(visited[q1.top().second])q1.pop();</span><br><span class="line">                <span class="keyword">while</span>(visited2[q2.top().second])q2.pop();</span><br><span class="line">                <span class="keyword">int</span> x=q1.top().second,y=q2.top().second;</span><br><span class="line">                q1.pop(),q2.pop();</span><br><span class="line">                ans+=a[x]+b[y];</span><br><span class="line">                <span class="keyword">if</span>(x!=y)</span><br><span class="line">                &#123;</span><br><span class="line">                    left--,left+=visited2[x]+visited[y];</span><br><span class="line">                    <span class="keyword">if</span>(!visited2[x])q5.push(mp(b[x],x));</span><br><span class="line">                    <span class="keyword">else</span> q4.pop();</span><br><span class="line">                    <span class="keyword">if</span>(!visited[y])q4.push(mp(a[y],y));</span><br><span class="line">                    <span class="keyword">else</span> q5.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                visited[x]=visited2[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(visited[q1.top().second])q1.pop();</span><br><span class="line">                <span class="keyword">while</span>(visited2[q2.top().second])q2.pop();</span><br><span class="line">                <span class="keyword">while</span>(visited[q3.top().second]||visited2[q3.top().second])q3.pop();</span><br><span class="line">                <span class="keyword">int</span> r=q3.top().second,s1=q4.empty()?<span class="number">0</span>:q4.top().second,s2=q2.top().second,t1=q5.empty()?<span class="number">0</span>:q5.top().second,t2=q1.top().second;</span><br><span class="line">                <span class="keyword">if</span>(a[r]+b[r]&gt;=a[s1]+b[s2]&amp;&amp;a[r]+b[r]&gt;=b[t1]+a[t2])<span class="comment">//类型2</span></span><br><span class="line">                &#123;</span><br><span class="line">                    visited[r]=visited2[r]=<span class="number">1</span>;</span><br><span class="line">                    ans+=a[r]+b[r];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[s1]+b[s2]&gt;=b[t1]+a[t2])<span class="comment">//类型3</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=a[s1]+b[s2];</span><br><span class="line">                    visited[s1]=visited2[s2]=<span class="number">1</span>;</span><br><span class="line">                    q2.pop(),q4.pop();</span><br><span class="line">                    <span class="keyword">if</span>(visited[s2])left++,q5.pop();</span><br><span class="line">                    <span class="keyword">else</span> q4.push(mp(a[s2],s2));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//类型4</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=b[t1]+a[t2];</span><br><span class="line">                    visited2[t1]=visited[t2]=<span class="number">1</span>;</span><br><span class="line">                    q1.pop(),q5.pop();</span><br><span class="line">                    <span class="keyword">if</span>(visited2[t2])left++,q4.pop();</span><br><span class="line">                    <span class="keyword">else</span> q5.push(mp(b[t2],t2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>网络流</tag>
        <tag>模拟费用流</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>luoguP6295 有标号 DAG 计数</title>
    <url>/2020/07/30/luoguP6295%E6%9C%89%E6%A0%87%E5%8F%B7DAG%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>对每个 <span class="math inline">\(1\leqslant i\leqslant n\)</span> 求 <span class="math inline">\(i\)</span> 个点的弱连通有标号有向无环图数目，<span class="math inline">\(n\leqslant 10^5\)</span>。 <a id="more"></a></p>
<p>首先，根据 exp 的组合意义，即有标号对象组成的集合个数，如果我们求出了不一定弱连通的 DAG 数目的 EGF <span class="math inline">\(G(x)\)</span>，设弱连通的 DAG 数目的 EGF 为 <span class="math inline">\(F(x)\)</span>，则 <span class="math display">\[
F(x)=\ln(G(x))
\]</span> 显然一张 DAG 一定有至少一个入度为 <span class="math inline">\(0\)</span> 的点，所以我们尝试枚举度数为 <span class="math inline">\(0\)</span> 的点的个数，然后我们计算度数为 <span class="math inline">\(0\)</span> 的点和其它点的连边情况，然后就递归到了子问题，这样你可能会写出以下式子 <span class="math display">\[
g_i=\sum\limits_{j=1}^i\binom{i}{j}2^{j(i-j)}g_{i-j}
\]</span> 但是写个暴力试一下发现是错的，为什么？因为剩下的点里可能也有入度为 <span class="math inline">\(0\)</span> 的点，所以会计重。</p>
<p>我们发现，我们实际上不是枚举入度为 <span class="math inline">\(0\)</span> 的点，而是在钦定入度为 <span class="math inline">\(0\)</span> 的点，我们设 <span class="math inline">\(h_{i,j}\)</span> 为<span class="math inline">\(i\)</span> 个点的图钦定 <span class="math inline">\(j\)</span> 个入度为 <span class="math inline">\(0\)</span> 个点的方案数，<span class="math inline">\(c_{i,j}\)</span> 为恰好 <span class="math inline">\(j\)</span> 个入度为 <span class="math inline">\(0\)</span> 的点的方案数，那么有（这个式子都不知道见了多少遍了）： <span class="math display">\[
h_{i,j}=\sum\limits_{k=j}^i \binom{k}{j}c_{i,k}
\]</span> 由二项式反演： <span class="math display">\[
c_{i,j}=\sum\limits_{k=j}^i \binom{k}{j}(-1)^{k-j}h_{i,k}
\]</span> 同时类似刚才那个假的式子，我们有 $h_{i,j}=2^{j(i-j)}g_{i-j} $，有 <span class="math inline">\(g_i=\sum\limits_{j=1}^i c_{i,j}\)</span>。</p>
<p>然后我们把能带入的都带入 <span class="math display">\[
\begin{aligned}
g_n&amp;=\sum\limits_{i=1}^nc_{n,i}\\
&amp;=\sum\limits_{i=1}^n\sum\limits_{j=i}^n\binom{j}{i}(-1)^{j-i}h_{i,j}\\
&amp;=\sum\limits_{i=1}^n\sum\limits_{j=i}^n\binom{j}{i}(-1)^{j-i}\binom{n}{j}2^{j(n-j)}g_{n-j}\\
&amp;=\sum\limits_{j=1}^n\binom{n}{j}2^{j(n-j)}g_{n-j}\sum\limits_{i=1}^{j}\binom{j}{i}(-1)^{i-j}\\
&amp;=\sum\limits_{j=1}^n\binom{n}{j}2^{j(n-j)}g_{n-j}(0-(-1)^j)\\
&amp;=\sum\limits_{j=1}^n\binom{n}{j}(-1)^{j+1}2^{j(n-j)}g_{n-j}
\end{aligned}
\]</span></p>
<p>然后注意到有个 <span class="math inline">\(j(n-j)\)</span>，我们采用和 Bluestein 一样的套路，把 <span class="math inline">\(j(n-j)\)</span> 拆成组合数的和。 <span class="math display">\[
j(n-j)=\binom{n}{2}-\binom{j}{2}-\binom{n-j}{2}
\]</span></p>
<p>如果记不住可以考虑组合意义：等价于有两堆石子，各有 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(n-j\)</span> 个，然后从两堆石子各取一个的方案数等于任取的方案数减去同时在一堆石子里取的方案数。</p>
<p>这里没有用平方式的那个，因为不一定存在 <span class="math inline">\(2\)</span> 的二次剩余（虽然 AKrry 证明了如果是 NTT 模数都存在）。</p>
<p>这样就是卷积形式了 <span class="math display">\[
\begin{aligned}
g_n=\sum\limits_{j=1}^n\binom{n}{j}(-1)^{j+1}2^{j(n-j)}g_{n-j}\\
\frac{g_n}{n!2^{\binom{n}{2}}}=\sum\limits_{j=1}^n\frac{(-1)^{j+1}}{2^{\binom{j}{2}}j!}\frac{g^{n-j}}{2^\binom{n-j}{2}(n-j)!}
\end{aligned}
\]</span> 设 <span class="math display">\[
F(x)=\sum\limits_{i=1}^\infty \frac{(-1)^{i+1}}{2^{\binom{i}{2}}i!}x^i\\
G(x)=\sum\limits_{i=0}^\infty \frac{g_i}{2^{\binom{i}{2}}i!}x^i
\]</span></p>
<p>则 <span class="math inline">\(G(x)=F(x)G(x)+1\)</span>，故 <span class="math inline">\(G(x)=\frac{1}{1-F(x)}\)</span>。这样就可以求出 <span class="math inline">\(g\)</span>，然后再做一遍 <span class="math inline">\(\ln\)</span> 就好了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> inv2=<span class="number">499122177</span>;</span><br><span class="line"><span class="keyword">namespace</span> polynomials</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>,g=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">19</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> w[N],iv[N],r[N],last;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">            x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">            y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;n)lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        iv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=lim;i++)iv[i]=mod(p<span class="number">-1l</span>l*(p/i)*iv[p%i]%p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wn=pw(g,(p<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,ww=<span class="number">1</span>;j&lt;i;j++,ww=<span class="number">1l</span>l*ww*wn%p)w[i+j]=ww;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(vec &amp;f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=f[j+k],y=<span class="number">1l</span>l*f[i+j+k]*w[i+k]%p;</span><br><span class="line">                f[j+k]=mod(x+y);f[i+j+k]=mod(x-y+p);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(&amp;f[<span class="number">1</span>],&amp;f[n]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i]=<span class="number">1l</span>l*f[i]*iv[n]%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(vec f,vec &amp;g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> vec x;</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=pw(f[<span class="number">0</span>],p<span class="number">-2</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        getinv(f,g,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;(n&lt;&lt;<span class="number">1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        x.resize(lim);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)x[i]=f[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;lim;i++)x[i]=<span class="number">0</span>;</span><br><span class="line">        g.resize(lim);</span><br><span class="line">        ntt(x,lim,<span class="number">1</span>),ntt(g,lim,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)g[i]=<span class="number">1l</span>l*g[i]*(<span class="number">2</span><span class="number">-1l</span>l*g[i]*x[i]%p+p)%p;</span><br><span class="line">        ntt(g,lim,<span class="number">-1</span>);</span><br><span class="line">        g.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getln</span><span class="params">(vec f,vec &amp;g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> vec x;</span><br><span class="line">        getinv(f,x,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)f[i]=<span class="number">1l</span>l*f[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">        f[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lim&lt;((n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ntt(f,lim,<span class="number">1</span>),ntt(x,lim,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)x[i]=<span class="number">1l</span>l*x[i]*f[i]%p;</span><br><span class="line">        ntt(x,lim,<span class="number">-1</span>);</span><br><span class="line">        g.resize(n);</span><br><span class="line">        g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)g[i]=<span class="number">1l</span>l*x[i<span class="number">-1</span>]*iv[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> polynomials;</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">200005</span>],inv[<span class="number">200005</span>];</span><br><span class="line">vec f,G,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    n++;</span><br><span class="line">    init(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    inv[n<span class="number">-1</span>]=pw(fac[n<span class="number">-1</span>],p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)inv[i]=<span class="number">1l</span>l*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">    f.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        f[i]=<span class="number">1l</span>l*(((i+<span class="number">1</span>)&amp;<span class="number">1</span>)?(p<span class="number">-1</span>):<span class="number">1</span>)*inv[i]%p*pw(inv2,(<span class="number">1l</span>l*i*(i<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>)%(p<span class="number">-1</span>))%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i]=mod(p-f[i]);</span><br><span class="line">    f[<span class="number">0</span>]=mod(f[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    getinv(f,G,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)G[i]=<span class="number">1l</span>l*G[i]*pw(<span class="number">2</span>,(<span class="number">1l</span>l*i*(i<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>)%(p<span class="number">-1</span>))%p;</span><br><span class="line">    getln(G,ans,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">1l</span>l*ans[i]*fac[i]%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>容斥</tag>
        <tag>二项式反演</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>「THUPC2019」找树</title>
    <url>/2020/07/29/%E3%80%8CTHUPC2019%E3%80%8D%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5406" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>首先，这不是一道最优化题，这是一道计数题，如果对每个 <span class="math inline">\(i\)</span>，我们求出权值为 <span class="math inline">\(i\)</span> 的生成树的数量，那么答案就是最大的生成树数量不为 <span class="math inline">\(0\)</span> 的 <span class="math inline">\(i\)</span>。</p>
<p>那么问题就转化成了：求权值为 <span class="math inline">\(i\)</span> 的生成树数量。</p>
<p>首先矩阵树定理是少不了的，我们知道，矩阵树定理实际上求的是</p>
<p><span class="math display">\[
\sum\limits_{T}\prod_{e\in T}w_{Te}
\]</span> 注意到这个 <span class="math inline">\(\prod\)</span>，它不一定非得是数相乘，只要保证 <span class="math inline">\(&lt;W,+,\times&gt;\)</span> 构成一个环，那么这个式子就成立。其中 <span class="math inline">\(W\)</span> 是边权所在的全集。</p>
<p>所以我们可以对于每一条边构造一个集合幂级数 <span class="math inline">\(f_v=x^{v}\)</span>，乘法定义为输入的集合卷积（如果这一位为或，这一位就是集合或卷积，其它同理），这样求出的行列式的 <span class="math inline">\(x^v\)</span> 项的系数就是权值为 <span class="math inline">\(v\)</span> 的生成树个数。（集合幂级数形成了一个交换环）</p>
<p>具体实现我们注意到 FWT 是线性变换，所以我们一开始先把矩阵做好 FWT，求完行列式再 IFWT 回去，而且直接求生成树的数量太大，我们可以对大质数取模，复杂度是 <span class="math inline">\(O(n^32^w)\)</span>，信仰跑吧。关于集合卷积如何按位做不明白的可以看代码。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll <span class="keyword">const</span> p=<span class="number">1e9</span>+<span class="number">7</span>,inv=<span class="number">500000004</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,w;</span><br><span class="line">ll mat[<span class="number">75</span>][<span class="number">75</span>][<span class="number">4097</span>],r[<span class="number">75</span>][<span class="number">75</span>],c[<span class="number">4097</span>];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function">ll <span class="title">mod</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">pw</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res*=x,res%=p;</span><br><span class="line">        x*=x,x%=p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(ll *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>,b=<span class="number">0</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,b++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(str[b]==<span class="string">'|'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;j++)</span><br><span class="line">                    <span class="keyword">if</span>(op==<span class="number">1</span>)f[j+q]=mod(f[j+q]+f[j]);</span><br><span class="line">                    <span class="keyword">else</span> f[j+q]=mod(f[j+q]+p-f[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[b]==<span class="string">'&amp;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;j++)</span><br><span class="line">                    <span class="keyword">if</span>(op==<span class="number">1</span>)f[j]=mod(f[j]+f[j+q]);</span><br><span class="line">                    <span class="keyword">else</span> f[j]=mod(f[j]+p-f[j+q]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[j]=mod(f[j]+f[j+q]);</span><br><span class="line">                    f[j+q]=(f[j]<span class="number">-2</span>*f[j+q]+<span class="number">2</span>*p)%p;</span><br><span class="line">                    <span class="keyword">if</span>(op==<span class="number">-1</span>)f[j]*=inv,f[j]%=p,f[j+q]*=inv,f[j+q]%=p;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">det</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>((!r[i][i])&amp;&amp;r[j][i])&#123;ans=p-ans,swap(r[i],r[j]);<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!r[i][i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll t=pw(r[i][i],p<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll t2=t*r[j][i]%p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;n;k++)</span><br><span class="line">                r[j][k]=mod(r[j][k]-t2*r[i][k]%p+p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)ans*=r[i][i],ans%=p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    w=str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">        mat[x][y][v]--,mat[y][x][v]--;</span><br><span class="line">        mat[x][x][v]++,mat[y][y][v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;w);k++)</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j][k]&lt;<span class="number">0</span>)mat[i][j][k]+=p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            fwt(mat[i][j],(<span class="number">1</span>&lt;&lt;w),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;w);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                r[j][k]=mat[j][k][i];</span><br><span class="line">        c[i]=det();</span><br><span class="line">    &#125;</span><br><span class="line">    fwt(c,(<span class="number">1</span>&lt;&lt;w),<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="number">1</span>&lt;&lt;w)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(c[i])&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>矩阵树定理</tag>
        <tag>fwt</tag>
      </tags>
  </entry>
  <entry>
    <title>「CTSC2010」性能优化</title>
    <url>/2020/07/29/%E3%80%8CCTSC2010%E3%80%8D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4191" target="_blank" rel="noopener">题目链接</a></p>
<p>难得写了一次一句话题解/cy</p>
<p>jiqimao：我认为做了 [CTSC2010]性能优化 才算理解 fft。</p>
<a id="more"></a>
<p>其实 DFT 的基并不一定为 <span class="math inline">\(2\)</span>，如果保证 <span class="math inline">\(m\)</span> 次单位根存在（即 <span class="math inline">\(m\mid (p-1)\)</span> ），我们就可以做基为 <span class="math inline">\(m\)</span> 的 DFT，如果做一次长度为 <span class="math inline">\(m\)</span> 的 DFT，其复杂度为 <span class="math inline">\(O(nm)+mT(\frac{n}{m})\)</span>，即我们按照模 <span class="math inline">\(m\)</span> 的余数分为 <span class="math inline">\(m\)</span> 个多项式，然后递归下去，再分别带入单位根进行计算就可以了。这道题保证 <span class="math inline">\(n\)</span> 的每个质因子小于 <span class="math inline">\(10\)</span>，所以复杂度是对的。</p>
<p>也可以按照一般的 FFT 写法写一个蝴蝶变换，我比较懒没写，跑的也不慢。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p,g,gi,a[<span class="number">500005</span>],b[<span class="number">500005</span>],G[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(x%<span class="number">2</span>))<span class="keyword">if</span>(pw(i,x/<span class="number">2</span>)==<span class="number">1</span>)flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(x%<span class="number">3</span>))<span class="keyword">if</span>(pw(i,x/<span class="number">3</span>)==<span class="number">1</span>)flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(x%<span class="number">5</span>))<span class="keyword">if</span>(pw(i,x/<span class="number">5</span>)==<span class="number">1</span>)flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(x%<span class="number">7</span>))<span class="keyword">if</span>(pw(i,x/<span class="number">7</span>)==<span class="number">1</span>)flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x%<span class="number">2</span>))<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(x%<span class="number">3</span>))<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(x%<span class="number">5</span>))<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> t=get(n),c=n/t;</span><br><span class="line">    <span class="keyword">int</span> tmp[t][c];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)tmp[i%t][i/t]=f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)dft(tmp[i],c,op);</span><br><span class="line">    <span class="keyword">int</span> wn=pw(op==<span class="number">1</span>?g:gi,(p<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,ww=<span class="number">1</span>;i&lt;n;i++,ww=<span class="number">1l</span>l*ww*wn%p)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,w=<span class="number">1</span>;j&lt;t;j++,w=<span class="number">1l</span>l*w*ww%p)</span><br><span class="line">            f[i]+=<span class="number">1l</span>l*tmp[j][i%c]*w%p,f[i]%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line">    p=n+<span class="number">1</span>;</span><br><span class="line">    g=getroot(n);</span><br><span class="line">    gi=pw(g,p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a[i]%=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]),b[i]%=p;</span><br><span class="line">    dft(a,n,<span class="number">1</span>),dft(b,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1l</span>l*a[i]*pw(b[i],c)%p;</span><br><span class="line">    dft(a,n,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> t=pw(n,p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="number">1l</span>l*a[i]*t%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>fft</tag>
        <tag>循环卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>单位根反演</title>
    <url>/2020/07/28/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>这东西就一个式子，但是能推出很多有意思的东西。</p>
<a id="more"></a>
<p><span class="math display">\[
[n\mid a]=\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{ai}
\]</span> 其中 <span class="math inline">\(\mid\)</span> 为整除符号，<span class="math inline">\(w_n^i\)</span> 为第 <span class="math inline">\(i\)</span> 个 <span class="math inline">\(n\)</span> 次单位根。</p>
<p>考虑证明：</p>
<ul>
<li>当 <span class="math inline">\(n\mid a\)</span> 时，设 <span class="math inline">\(a=kn\)</span>，则 <span class="math display">\[
\begin{aligned}
&amp;\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{ai}\\
=&amp;\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{nki}\\
=&amp;\frac{1}{n}\sum\limits_{i=0}^{n-1}(w_n^n)^{ki}\\
=&amp;\frac{1}{n}\sum\limits_{i=0}^{n-1}1\\
=&amp;1
\end{aligned}
\]</span></li>
</ul>
<p>当 <span class="math inline">\(n\nmid a\)</span> 时，考虑等比数列求和 <span class="math display">\[
\begin{aligned}
&amp;\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{ai}\\
=&amp;\frac{1}{n}\frac{1-w_n^{an}}{1-w_n^a}
\end{aligned}
\]</span> 注意到 <span class="math inline">\(1-w_n^{an}=0\)</span> 且 <span class="math inline">\(1-w_n^a\not= 0\)</span>（这也是为啥 <span class="math inline">\(n\mid a\)</span> 时不能这么做，因为公比为 <span class="math inline">\(1\)</span> 了），所以原式为 <span class="math inline">\(0\)</span>。</p>
<p>注意一下如果在模质数意义下有 <span class="math inline">\(n\)</span> 次单位根（即 <span class="math inline">\(n\mid(p-1)\)</span>）那么这个式子也是成立的。</p>
<p>一个推导： <span class="math display">\[
[a\equiv b\pmod n]=\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{ai}w_n^{-bi}
\]</span></p>
<p>另一个推导：如果我们有一个项数很多的多项式（设项数为 <span class="math inline">\(n\)</span>），我们想求 <span class="math inline">\([x^t]f(x),[x^{k+t}]f(x),[x^{2k+t}]f(x),\dots\)</span> 之和，且满足：</p>
<ul>
<li><span class="math inline">\(k\)</span> 较小</li>
<li>多项式的点值便于快速计算</li>
<li>如果是在模质数意义下，则应存在 <span class="math inline">\(k\)</span> 次单位根</li>
</ul>
<p>我们可以通过单位根反演快速计算，具体如下： <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=0}^{n-1}[i\equiv t\pmod k][x^i]f(x)\\
=&amp;\frac{1}{k}\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{k-1}w_k^{(i-t)j}[x^i]f(x)\\
=&amp;\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{-tj}\sum\limits_{i=0}^{n-1}w_k^{ij}[x^i]f(x)\\
=&amp;\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{-tj}f(w_k^j)
\end{aligned}
\]</span> 来一道例题</p>
<h4 id="loj6485-ljj-学二项式定理">loj6485 LJJ 学二项式定理</h4>
<p>输入以下变量的值：$ n, s , a_0 , a_1 , a_2 , a_3$，求以下式子的值： <span class="math display">\[
\left[ \sum_{i=0}^n \left( {n\choose i} \cdot s^{i} \cdot a_{i\bmod 4} \right)     \right] \bmod 998244353
\]</span> 我们枚举 <span class="math inline">\(a_0,a_1,a_2,a_3\)</span> 前面的系数，则 <span class="math display">\[
\begin{aligned}
ans=&amp;\sum\limits_{k=0}^3a_k\sum\limits_{i=0}^n[i\bmod4=k]\binom{n}{i}s^i\\
=&amp;\sum\limits_{k=0}^3a_k\sum\limits_{i=0}^n[4\mid(i-k)]\binom{n}{i}s^i\\
=&amp;\frac{1}{4}\sum\limits_{k=0}^3a_k\sum\limits_{i=0}^{n}\sum_{j=0}^{3}w_4^{j(i-k)}\binom{n}{i}s^i\\
=&amp;\frac{1}{4}\sum\limits_{k=0}^3a_k\sum\limits_{i=0}^{n}\sum_{j=0}^{3}w_4^{ji}w_4^{-jk}\binom{n}{i}s^i\\
=&amp;\frac{1}{4}\sum\limits_{k=0}^3a_k\sum_{j=0}^{3}w_4^{-jk}\sum\limits_{i=0}^{n}w_4^{ji}\binom{n}{i}s^i\\
=&amp;\frac{1}{4}\sum\limits_{k=0}^3a_k\sum_{j=0}^{3}w_4^{-jk}(sw_t^j+1)^n
\end{aligned}
\]</span> 然后在模 <span class="math inline">\(998244353\)</span> 意义下的 <span class="math inline">\(4\)</span> 次单位根为 <span class="math inline">\(g^{\frac{p-1}{4}}\)</span>，其中 <span class="math inline">\(g\)</span> 是某个原根。直接快速幂就好了。</p>
<p><a href="https://loj.ac/submission/880657" target="_blank" rel="noopener">代码</a></p>
<h4 id="用单位根反演证明-idft-正确性">用单位根反演证明 IDFT 正确性</h4>
<p>证明 IDFT 那个方法本质就是单位根反演。 <span class="math display">\[
\begin{aligned}
f&#39;[k]&amp;=\sum\limits_{i=0}^nw_n^{-ki}F(w_n^i)\\
&amp;=\sum\limits_{i=0}^{n-1}w_n^{-ki}\sum\limits_{j=0}^{n-1}f_jw_n^{ij}\\
&amp;=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}f_jw_n^{(j-k)i}\\
&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}w_n^{(j-k)i}\\
&amp;=\sum\limits_{j=0}^{n-1}f_j[(j-k)\mid n]\\
&amp;=nf_k
\end{aligned}
\]</span></p>
<h4 id="bluesteins-algorithm">Bluestein's Algorithm</h4>
<p>有的时候我们单位根反演完了以后要对每个 <span class="math inline">\(k\)</span> 求形似 <span class="math inline">\(\sum\limits_{i=0}^{n-1}w_n^{ik}f_i\)</span> 的东西，而 <span class="math inline">\(n\)</span> 不一定是 <span class="math inline">\(2\)</span> 的次幂。暴力求是 <span class="math inline">\(O(n^2)\)</span> 的，有没有优化方法？</p>
<p>注意到这实际上是一个任意长度的 DFT，当 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(2\)</span> 的次幂时就是普通的 FFT，而 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(2\)</span> 的次幂时不能直接 FFT，我们考虑对 <span class="math inline">\(ik\)</span> 做文章。</p>
<p>形式1： <span class="math display">\[
ik=\frac{-(k-i)^2+i^2+k^2}{2}
\]</span> 所以有 <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=0}^{n-1}w_n^{ik}f_i\\
=&amp;\sum\limits_{i=0}^{n-1}w_n^{\frac{-(k-i)^2}{2}+\frac{i^2}{2}+\frac{k^2}{2}}f_i\\
=&amp;w_n^{\frac{k^2}{2}}\sum\limits_{i=0}^{n-1}w_n^{\frac{-(k-i)^2}{2}}w_n^{\frac{i^2}{2}}f_i\\
=&amp;w_{2n}^{k^2}\sum\limits_{i=0}^{n-1}w_{2n}^{-(k-i)^2}w_{2n}^{i^2}f_i\\
\end{aligned}
\]</span> 我们注意到求和号右面是一个卷积的形式，所以我们做一次正常的卷积就可以了。</p>
<p>有的时候我们是在模质数意义下做的，可能没有 <span class="math inline">\(2n\)</span> 次单位根，所以这个时候我们要利用到形式2： <span class="math display">\[
ik=\binom{i+k}{2}-\binom{i}{2}-\binom{k}{2}
\]</span> 所以有 <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=0}^{n-1}w_n^{ik}f_i\\
=&amp;\sum\limits_{i=0}^{n-1}w_n^{\binom{i+k}{2}-\binom{i}{2}-\binom{k}{2}}f_i\\
=&amp;w_n^{-\binom{k}{2}}\sum\limits_{i=0}^{n-1}w_n^{\binom{i+k}{2}}w_n^{-\binom{i}{2}}f_i\\
=&amp;w_n^{-\binom{k}{2}}\sum\limits_{i=0}^{n-1}w_n^{\binom{i+k}{2}}w_n^{-\binom{i}{2}}f_i\\
\end{aligned}
\]</span> 这样就可以避免不存在 <span class="math inline">\(2n\)</span> 次单位根的问题了。</p>
<p>这个东西可以用来做循环卷积，即 <span class="math display">\[
c_k=\sum\limits_{i=0}^n\sum\limits_{j=0}^{n}[i+j\equiv k\pmod n]a_ib_j
\]</span> 然后是推式子时间 <span class="math display">\[
\begin{aligned}
c_k&amp;=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}[i+j\equiv k\pmod n]a_ib_j\\
&amp;=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}[(i+j-k)\bmod n=0]a_ib_j\\
&amp;=\frac{1}{n}\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}\sum\limits_{t=0}^{n-1}w_n^{t(i+j-k)}a_ib_j\\
&amp;=\frac{1}{n}\sum\limits_{t=0}^{n-1}w_n^{-kt}\left(\sum\limits_{i=0}^{n-1}w_n^{it}a_i\right)\left(\sum\limits_{j=0}^{n-1}w_n^{jt}b_j\right)
\end{aligned}
\]</span> 注意到两个括号内都是长度为 <span class="math inline">\(n\)</span> 的 DFT，所以对 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 做任意基 DFT，然后相乘就得到点值表示了，最后需要做长度为 <span class="math inline">\(n\)</span> 的 IDFT，和正着做类似。</p>
<p>顺便说一下关于 FFT 的本质，我们需要注意到如果我们把两个长为 <span class="math inline">\(n\)</span> 的数组都做一遍 DFT，然后对应位相乘再 IDFT 回去，这样得到的是两个数组做长度为 <span class="math inline">\(n\)</span> 的循环卷积。我们平时写的 FFT 也是长度为 <span class="math inline">\(2^k\)</span> 的循环卷积，只不过我们一开始已经补到了比最高次还要高的 <span class="math inline">\(2^k\)</span> 长度，所以不会出现循环。</p>
<p>给一道关于 FFT 本质的例题：<a href="/2020/07/29/「CTSC2010」性能优化/">「CTSC2010」性能优化</a>，这篇写的比较辣鸡，建议看别人的。</p>
<p>再给一道比较难的单位根反演的例题：<a href="/2020/08/05/「HNOI2019」白兔之舞/">「HNOI2019」白兔之舞</a></p>
]]></content>
      <tags>
        <tag>fft</tag>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title>「CTS2019」珍珠</title>
    <url>/2020/07/27/%E3%80%8CCTS2019%E3%80%8D%E7%8F%8D%E7%8F%A0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5401" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>如果我们设第 <span class="math inline">\(i\)</span> 种颜色一共出现了 <span class="math inline">\(cnt_i\)</span> 次，那么不难发现如果方案合法则有 <span class="math display">\[
\sum\limits_{i=1}^D\lfloor \frac{cnt_i}{2} \rfloor\geqslant m
\]</span> 我们简单推一下式子 <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=1}^D\lfloor \frac{cnt_i}{2} \rfloor\geqslant m\\
=&amp;\sum\limits_{i=1}^D cnt_i-(cnt_i\bmod 2) \geqslant 2m\\
=&amp;\sum\limits_{i=1}^D cnt_i\bmod 2\leqslant n-2m
\end{aligned}
\]</span> 即我们要关注 <span class="math inline">\(cnt_i\)</span> 的奇偶性。</p>
<p>当 <span class="math inline">\(n-2m\geqslant D\)</span> 或 <span class="math inline">\(n-2m&lt;0\)</span> 时需要特判一下。</p>
<p>我们设 <span class="math inline">\(f_i\)</span> 为在满足 <span class="math inline">\(\sum cnt=n\)</span> 的情况下，<span class="math inline">\(cnt\)</span> 为奇数的颜色恰好有 <span class="math inline">\(i\)</span> 个的方案数。由于难以直接算 <span class="math inline">\(f\)</span>，考虑二项式反演，设 <span class="math inline">\(g_i\)</span> 为在满足 <span class="math inline">\(\sum cnt=n\)</span> 的情况下，钦定 <span class="math inline">\(i\)</span> 个颜色 <span class="math inline">\(cnt\)</span> 为奇数，剩下任意的方案数。</p>
<p>我们考虑利用生成函数解决这个问题。</p>
<p>不难发现，对于某一个颜色，<span class="math inline">\(cnt\)</span> 为奇数的方案数所对应的指数生成函数为 <span class="math inline">\(\frac{e^x-e^{-x}}{2}\)</span>，<span class="math inline">\(cnt\)</span> 任意的方案数对应的指数生成函数为 <span class="math inline">\(e^x\)</span>（因为每个珍珠是有编号的，所以用 EGF）。那么有 <span class="math display">\[
\begin{aligned}
g_i&amp;=\binom{D}{i}n![x^n](\frac{e^x-e^{-x}}{2})^i(e^x)^{D-i}\\
&amp;=\binom{D}{i}\frac{n!}{2^i}[x^n](e^x-e^{-x})^i(e^x)^{D-i}
\end{aligned}
\]</span> 然后我们用二项式定理把 <span class="math inline">\((e^x-e^{-x})^i\)</span> 展开。 <span class="math display">\[
\begin{aligned}
g_i&amp;=\binom{D}{i}\frac{n!}{2^i}[x^n]\sum\limits_{j=0}^i\binom{i}{j}(e^x)^j(-e^x)^{i-j}(e^x)^{D-i}\\
&amp;=\binom{D}{i}\frac{n!}{2^i}[x^n]\sum\limits_{j=0}^i\binom{i}{j}(-1) ^{i-j}(e^x)^j(e^{-x})^{i-j}(e^x)^{D-i}\\
&amp;=\binom{D}{i}\frac{n!}{2^i}[x^n]\sum\limits_{j=0}^i\binom{i}{j}(-1) ^{i-j}(e^x)^j(e^x)^{j-i}(e^x)^{D-i}\\
&amp;=\binom{D}{i}\frac{n!}{2^i}[x^n]\sum\limits_{j=0}^i\binom{i}{j}(-1) ^{i-j}(e^x)^{D-2(i-j)}
\end{aligned}
\]</span> 然后我们把 <span class="math inline">\((e^x)^{D-2(i-j)}\)</span>（它的系数为 <span class="math inline">\(\frac{(D-2(i-j))^n}{n!}\)</span>）与组合数展开 <span class="math display">\[
\begin{aligned}
g_i&amp;=\frac{D!}{i!(D-i)!}\frac{n!}{2^i}\sum\limits_{j=0}^i\frac{i!}{j!(i-j)!}(-1) ^{i-j}\frac{(D-2(i-j))^n}{n!}\\
&amp;=\frac{D!}{(D-i)!}\frac{1}{2^i}\sum\limits_{j=0}^i\frac{1}{j!(i-j)!}(-1) ^{i-j}(D-2(i-j))^n\\
&amp;=\frac{D!}{(D-i)!}\frac{1}{2^i}\sum\limits_{j=0}^i\frac{1}{j!(i-j)!}(-1)^{j}(D-2j)^n\\
\end{aligned}
\]</span> 注意最后一行用 <span class="math inline">\(i-j\)</span> 替换了 <span class="math inline">\(j\)</span>。求和号内部的东西显然是卷积形式，NTT 计算即可。</p>
<p>然后我们需要反演回去，但是不能直接两重 <code>for</code>，复杂度爆炸，注意到二项式反演的式子 <span class="math display">\[
\begin{aligned}
f_i&amp;=\sum\limits_{j=i}^d\binom{j}{i}(-1)^{j-i}g_j\\
&amp;=\frac{1}{i!}\sum\limits_{j=i}^d\frac{j!}{(j-i)!}(-1)^{j-i}g_j\\
\end{aligned}
\]</span> 注意到求和号后面是差一定的形式，把 <span class="math inline">\(j!g_j\)</span> 的多项式系数反转就可以卷积了。</p>
<p>答案为 <span class="math inline">\(\sum\limits_{i=0}^{n-2m}f_i\)</span>。注意你差一定的多项式卷完了以后系数也是反的，最后应该取的是多项式的 <span class="math inline">\(x^{d-n+2m}\)</span> 到 <span class="math inline">\(x^d\)</span> 项。</p>
<p>代码如下（两次 NTT 之间记得清空）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>,g=<span class="number">3</span>,gi=(p+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">400005</span>],F[<span class="number">400005</span>],G[<span class="number">400005</span>],fac[<span class="number">400005</span>],inv[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>,wn=pw(op==<span class="number">1</span>?g:gi,(p<span class="number">-1</span>)/len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i,w=<span class="number">1</span>;j&lt;i+q;j++,w=<span class="number">1l</span>l*w*wn%p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> d=<span class="number">1l</span>l*f[j+q]*w%p;</span><br><span class="line">                f[j+q]=(f[j]-d+p)%p;</span><br><span class="line">                f[j]+=d,f[j]%=p;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=pw(n,p<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i]=<span class="number">1l</span>l*f[i]*t%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;d,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-2</span>*m&lt;<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">"0"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-2</span>*m&gt;=d)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,pw(d,n));<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d;i++)fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p,inv[i]=<span class="number">1l</span>l*inv[i<span class="number">-1</span>]*pw(i,p<span class="number">-2</span>)%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)F[i]=inv[i],G[i]=<span class="number">1l</span>l*((i&amp;<span class="number">1</span>)?p<span class="number">-1</span>:<span class="number">1</span>)*inv[i]%p*pw((d<span class="number">-2</span>*i+p)%p,n)%p;</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;=(d&lt;&lt;<span class="number">1</span>))lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    ntt(F,lim,<span class="number">1</span>),ntt(G,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)G[i]=<span class="number">1l</span>l*F[i]*G[i]%p;</span><br><span class="line">    ntt(G,lim,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)G[i]=<span class="number">1l</span>l*G[i]*fac[d]%p*inv[d-i]%p*pw(<span class="number">2</span>,p<span class="number">-1</span>-i)%p*fac[i]%p;</span><br><span class="line">    reverse(G,G+d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">1</span>;i&lt;=lim;i++)F[i]=G[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)F[i]=<span class="number">1l</span>l*inv[i]*((i&amp;<span class="number">1</span>)?p<span class="number">-1</span>:<span class="number">1</span>)%p;</span><br><span class="line">    ntt(F,lim,<span class="number">1</span>),ntt(G,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)G[i]=<span class="number">1l</span>l*F[i]*G[i]%p;</span><br><span class="line">    ntt(G,lim,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">2</span>*m-n;i&lt;=d;i++)ans+=<span class="number">1l</span>l*G[i]*inv[d-i]%p,ans%=p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二项式反演</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>「CTS2019」随机立方体</title>
    <url>/2020/07/27/%E3%80%8CCTS2019%E3%80%8D%E9%9A%8F%E6%9C%BA%E7%AB%8B%E6%96%B9%E4%BD%93/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5400" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>不是很难，比较考验熟练程度（可惜还是没法自己做出来 /kk）。</p>
<p>首先，设 <span class="math inline">\(N=nml\)</span>，并认为 <span class="math inline">\(n\leqslant m, l\)</span>。</p>
<p>发现直接算比较难算，又看到题面中“恰好”两字，不难想到二项式反演。</p>
<p>我们设 <span class="math inline">\(f_i\)</span> 为钦定了 <span class="math inline">\(i\)</span> 个极大的格子，剩下随便填的方案数。则有 <span class="math display">\[
ans=\frac{\sum\limits_{i=k}^n\binom{i}{k}(-1)^{i-k}f(i)}{N!}
\]</span> 所以我们只需要对 <span class="math inline">\(i=k\rightarrow n\)</span> 求出 <span class="math inline">\(f_i\)</span>。</p>
<p>设 <span class="math inline">\(g_i\)</span> 为选出 <span class="math inline">\(i\)</span> 个极大点后受到影响（也就是与至少一个极大点的某一维坐标相等）的所有点的数量，<span class="math inline">\(b_i\)</span> 为选出 <span class="math inline">\(i\)</span> 个极大点的方案数，<span class="math inline">\(h_i\)</span> 为给定 <span class="math inline">\(g_i\)</span> 个数，往 <span class="math inline">\(g_i\)</span> 个点里填且满足题意的方案数。</p>
<p>那么有 <span class="math display">\[
f_i=\binom{N}{g_i}(N-g_i)!b_ih_i
\]</span> 即我们先选出 <span class="math inline">\(g_i\)</span> 个要填的数，然后剩下的数随便填，然后我们钦定格子的方案数为 <span class="math inline">\(b_i\)</span>，往格子里填数的方案数为 <span class="math inline">\(h_i\)</span>。</p>
<p>对于 <span class="math inline">\(g\)</span>，有 <span class="math inline">\(g_i=N-(n-i)(m-i)(l-i)\)</span>，即用所有数减去三维坐标都不与任何一个点相同的点的个数。</p>
<p>显然 <span class="math inline">\(b_i=\frac{\prod\limits_{j=0}^{i-1}(n-j)(m-j)(l-j)}{i!}\)</span>，也就是你选第 <span class="math inline">\(j\)</span> 个数时候的三维坐标的方案数，因为极大点是无编号的所以要除以 <span class="math inline">\(i!\)</span>，或者可以写成 <span class="math inline">\(\binom{n}{i}\binom{m}{i}\binom{l}{i}(i!)^2\)</span>。</p>
<p>对于 <span class="math inline">\(h\)</span>，我们考虑按照极大点上的数的大小从小到大添加极大点和与其关联的点。即我们考虑从 <span class="math inline">\(h_{i-1}\)</span> 递推出 <span class="math inline">\(h_i\)</span>。首先由于我们强制从小到大填极大点，所以当前填的极大点上的数一定比任何其它点的数都大的，然后我们考虑新关联的点的填法（注意有的点可能与不止一个极大点某一维坐标相同），具体地，如果我们知道一开始有 <span class="math inline">\(s\)</span> 个点，这次新增的有关联的点（不包括极大点）的个数为 <span class="math inline">\(r\)</span>，则有 <span class="math display">\[
h_i=i(s+1)^{\overline{r}}h_{i-1}
\]</span> 其中 <span class="math inline">\((s+1)^{\overline{r}}\)</span> 表示 <span class="math inline">\(s+1\)</span> 的 <span class="math inline">\(r\)</span> 次上升幂，即 <span class="math inline">\((s+1)(s+2)\dots (s+r)\)</span></p>
<p>因为我们这里要填的所有点和之前的点以及这次新增的点（除了极大点）之间都没有大小要求，所以我们可以任意插空，这样插入第一个点有 <span class="math inline">\(s+1\)</span> 个空，第二个有 <span class="math inline">\(s+2\)</span> 个，以此类推。然后要乘一个 <span class="math inline">\(i\)</span> 是因为我们这里固定了大小顺序，需要补上。</p>
<p>我们注意到，其实 <span class="math inline">\(s=g_{i-1}\)</span>，<span class="math inline">\(r=g_i-g_{i-1}-1\)</span>，注意有个 <span class="math inline">\(-1\)</span> 是因为要去掉极大点。这样就有 <span class="math display">\[
h_i=i\frac{(g_i-1)!}{g_{i-1}!}h_{i-1}
\]</span> 然后我们一路推下去，可以得到 <span class="math inline">\(h\)</span> 的通项公式 <span class="math display">\[
h_i=i!(g_i-1)!\prod\limits_{j=1}^{i-1}\frac{1}{g_j}
\]</span> 把 <span class="math inline">\(b,h\)</span> 带入，则有 <span class="math display">\[
f_i=\frac{N!}{g_i!(N-g_i)!}(N-g_i)!\frac{\prod\limits_{j=0}^{i-1}(n-j)(m-j)(l-j)}{i!}i!(g_i-1)!\prod\limits_{j=1}^{i-1}\frac{1}{g_j}
\]</span> 为了方便我们在这里就把 <span class="math inline">\(N!\)</span> 除掉，并且化简可得 <span class="math display">\[
f_i=\prod_{j=0}^{i-1}(n-j)(m-j)(l-j)\prod_{j=1}^{i}\frac{1}{g_j}
\]</span> 这个式子很好从 <span class="math inline">\(f_{i-1}\)</span> 递推出来。然后如果对于每个 <span class="math inline">\(i\)</span> 都用快速幂求出 <span class="math inline">\(g_i\)</span> 的逆元，总复杂度是 <span class="math inline">\(O(Tn\log p)\)</span> 的，难以通过，我们考虑先算出来 <span class="math inline">\(\prod g_i\)</span> 的逆元，然后算一下前缀积和后缀积一乘就可以 <span class="math inline">\(O(1)\)</span> 求出 <span class="math inline">\(\frac{1}{g_i}\)</span> 了。</p>
<p>据同机房神仙 <span class="citation" data-cites="jiqimao">@jiqimao</span> 说可以把不等关系转化成一个外向树的拓扑序个数问题，这样可以简化推出 <span class="math inline">\(h\)</span> 的过程，本质上是一样的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">5000005</span>],inv[<span class="number">5000005</span>],prod[<span class="number">5000005</span>],prod2[<span class="number">5000005</span>],f[<span class="number">5000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5000000</span>;i++)fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    inv[<span class="number">5000000</span>]=pw(fac[<span class="number">5000000</span>],p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4999999</span>;i&gt;=<span class="number">1</span>;i--)inv[i]=<span class="number">1l</span>l*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,l,k,N,I;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;l,&amp;k);</span><br><span class="line">        N=<span class="number">1l</span>l*n*m%p*l%p;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m)swap(n,m);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;l)swap(n,l);</span><br><span class="line">        prod[<span class="number">0</span>]=prod2[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            prod[i]=<span class="number">1l</span>l*prod[i<span class="number">-1</span>]*(N<span class="number">-1l</span>l*(n-i)*(m-i)%p*(l-i)%p+p)%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">            prod2[i]=<span class="number">1l</span>l*prod2[i+<span class="number">1</span>]*(N<span class="number">-1l</span>l*(n-i)*(m-i)%p*(l-i)%p+p)%p;</span><br><span class="line">        I=pw(prod[n],p<span class="number">-2</span>);</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i]=<span class="number">1l</span>l*f[i<span class="number">-1</span>]*(n-i+<span class="number">1</span>)%p*(m-i+<span class="number">1</span>)%p*(l-i+<span class="number">1</span>)%p*prod[i<span class="number">-1</span>]%p*prod2[i+<span class="number">1</span>]%p*I%p;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">            ans=(ans+<span class="number">1l</span>l*fac[i]*inv[k]%p*inv[i-k]%p*(((i-k)&amp;<span class="number">1</span>)?(p<span class="number">-1</span>):<span class="number">1</span>)%p*f[i]%p)%p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>「2017 山东一轮集训 Day5」苹果树</title>
    <url>/2020/07/24/%C2%96%E3%80%8C2017%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%ADDay5%E3%80%8D%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6072" target="_blank" rel="noopener">题目链接</a></p>
<p>很巧妙的一道小清新题。</p>
<a id="more"></a>
<p>首先请搞明白“好苹果”，“坏苹果”，“有用的苹果”的定义，不要混了。</p>
<p>有一个很重要的结论，我们发现我们可以把树的形态和权值分开算。</p>
<p>那么我们设 <span class="math inline">\(f(s)\)</span> 为恰好有 <span class="math inline">\(s\)</span> 个好的但是没有用的苹果的树的数量，<span class="math inline">\(r(s)\)</span> 为选出 <span class="math inline">\(s\)</span> 个权值使得权值之和不大于 <span class="math inline">\(limit\)</span> 的方案数，那么 <span class="math inline">\(ans=\sum\limits_{s=0}^k\frac{f(k-s)r(s)}{\binom{k}{s}}\)</span>，这里要除一个组合数因为如果我们在选权值的时候选出了某些点作为有用的苹果，那么有用的苹果的集合是固定的，而按照 <span class="math inline">\(f\)</span> 的定义，任何一种大小为 <span class="math inline">\(s\)</span> 的没用的点的集合都被算了一遍，所以要除以选择大小为 <span class="math inline">\(s\)</span> 的集合的方案数。</p>
<p>我们先来算比较好算的 <span class="math inline">\(r(s)\)</span> 部分，注意到 <span class="math inline">\(n\leqslant 40\)</span>，这启发我们用折半搜索，和 <a href="https://www.luogu.com.cn/problem/P4799" target="_blank" rel="noopener">这题</a> 类似，把数分为两部分，然后分别算出所有子集的和，对于前半部分直接按权值和排序，对于后半部分先把它放在子集大小对应的桶里每个桶里分别排序，然后双指针，复杂度依旧为 <span class="math inline">\(O(n2^{\frac{n}{2}})\)</span>。</p>
<p>然后我们来算 <span class="math inline">\(f(s)\)</span> 部分，看到求生成树的数量和较小的数据范围，不难想到使用矩阵树定理，但是我们直接做肯定是不能算出来恰好 <span class="math inline">\(s\)</span> 个有用的苹果的。所以我们考虑钦定 <span class="math inline">\(s\)</span> 个然后二项式反演，如果钦定有用的苹果，那么还需要考虑内部连边和连通块的方案，难以计算。所以我们钦定好的但是没有用的苹果，因为这一部分一定只和坏苹果连边。这样的话假设钦定了 <span class="math inline">\(s\)</span> 个好的但是没有用的苹果，连边就是 <span class="math inline">\([1,s]\)</span> 向 <span class="math inline">\([1,s]\cup [k+1,n]\)</span> 连边，<span class="math inline">\([s+1,k]\)</span> 向 <span class="math inline">\([k+1,n]\)</span> 连边，<span class="math inline">\([k+1,n]\)</span> 向 <span class="math inline">\([k+1,n]\)</span> 连边。</p>
<p>然后这个地方的二项式反演和普通的钦定二项式反演不太一样，如果我们按照上面的方法求出行列式，实际上求出的不是 <span class="math inline">\(g(s)\)</span>，而是 <span class="math inline">\(g&#39;(s)\)</span>，其中满足 <span class="math inline">\(g(s)=\binom{k}{s}g&#39;(s)\)</span>。因为行列式是强制了钦定集合为 <span class="math inline">\([k-s+1,k]\)</span>，而正常我们二项式反演时所有大小为 <span class="math inline">\(s\)</span> 的集合都会被钦定，而对于任何一个集合连边的方案都是相同的，所以要成上组合数。</p>
<p>那么对于 <span class="math inline">\(f(s)\)</span> 和 <span class="math inline">\(g(s)\)</span> 它们的关系和正常的钦定型二项式反演一样，满足： <span class="math display">\[
f(s)=\sum\limits_{i=s}^k\binom{i}{s}(-1)^{i-s}g(i)
\]</span> 这样这道题就做完了。总复杂度 <span class="math inline">\(O(n2^{\frac{n}{2}}+n^4)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;<span class="keyword">if</span>(x&gt;=p)x-=p;&#125;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">45</span>],head[<span class="number">25</span>],r[<span class="number">45</span>],g[<span class="number">45</span>],c[<span class="number">45</span>][<span class="number">45</span>],e[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">2</span>],buc[<span class="number">25</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;e[x][y]--,e[y][x]--,e[x][x]++,e[y][y]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>((!e[i][i])&amp;&amp;e[j][i])&#123;swap(e[i],e[j]);ans=p-ans;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> inv=pw(e[i][i],p<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="number">1l</span>l*e[j][i]*inv%p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;n;k++)</span><br><span class="line">                e[j][k]-=<span class="number">1l</span>l*e[i][k]*t%p,e[j][k]+=p,mod(e[j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)ans=<span class="number">1l</span>l*ans*e[i][i]%p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> limit,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;limit);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=<span class="number">-1</span>)k++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(k&gt;&gt;<span class="number">1</span>);i++)v[<span class="number">0</span>].pb(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(k&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;i&lt;=k;i++)v[<span class="number">1</span>].pb(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;v[<span class="number">0</span>].size());i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.pb(mp(<span class="number">0</span>,__builtin_popcount(i)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v[<span class="number">0</span>].size();j++)</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))q[i].first+=v[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q.begin(),q.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;v[<span class="number">1</span>].size());i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=__builtin_popcount(i);</span><br><span class="line">        buc[t].pb(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v[<span class="number">1</span>].size();j++)</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))buc[t][buc[t].size()<span class="number">-1</span>]+=v[<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=v[<span class="number">1</span>].size();i++)</span><br><span class="line">        sort(buc[i].begin(),buc[i].end()),head[i]=buc[i].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=v[<span class="number">1</span>].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(head[j]&amp;&amp;buc[j][head[j]<span class="number">-1</span>]+q[i].first&gt;limit)head[j]--;</span><br><span class="line">            r[j+q[i].second]+=head[j],mod(r[j+q[i].second]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=k;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k-s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=k-s;j++)</span><br><span class="line">                add(i,j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                add(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k-s+<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                add(i,j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                add(i,j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(e[i][j]&lt;<span class="number">0</span>)e[i][j]+=p;</span><br><span class="line">        g[s]=<span class="number">1l</span>l*det()*c[k][s]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=k;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=k;i++)</span><br><span class="line">            res+=<span class="number">1l</span>l*c[i][s]*(((i-s)&amp;<span class="number">1</span>)?p<span class="number">-1</span>:<span class="number">1</span>)%p*g[i]%p,mod(res);</span><br><span class="line">        ans+=<span class="number">1l</span>l*res*r[k-s]%p*pw(c[k][s],p<span class="number">-2</span>)%p,mod(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>矩阵树定理</tag>
        <tag>搜索</tag>
        <tag>容斥</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>「JOISC 2017 Day 1」烟花棒</title>
    <url>/2020/07/23/%E3%80%8CJOISC-2017-Day-1%E3%80%8D%E7%83%9F%E8%8A%B1%E6%A3%92/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/2392" target="_blank" rel="noopener">题意</a></p>
<a id="more"></a>
<p>这题真的强orz</p>
<p>不难发现这个问题答案具有单调性，可以二分最小的速度 <span class="math inline">\(v\)</span>，所以我们只需要判断当速度为 <span class="math inline">\(v\)</span> 时是否可以点燃所有的烟花棒。</p>
<p>首先不难发现，所有没点燃的人一定可以一直以最高速度向点燃的人跑，而且只会在碰到一个人时掉头。然后我们有一个重要结论：如果一个烟花棒点燃的人和没有点燃的人相遇，那么之后他们一定可以在一起跑，直到点燃的人的烟花棒熄灭，这时续给下一个人。</p>
<p>对于证明，我们考虑相遇后两人跑的方向是否相同：如果相同显然等一个人的灭的那一刻点燃不会劣；如果不同，设正在燃烧的烟花棒时间还剩 <span class="math inline">\(c\)</span> 秒，位置为 <span class="math inline">\(x\)</span>，我们强制认为不同的话正在燃烧的那个人向右走。那么如果点燃然后分开跑，能扩展到的区间为 <span class="math inline">\([x-Tv,x+cv]\)</span>；如果我们让没有点燃的人先跟着点燃的人跑 <span class="math inline">\(c\)</span>，然后再向回跑，这样能扩展的区间为 <span class="math inline">\([x+(T-c)v,x+cv]\)</span>。看似变少了，但是我们注意到第二种情况没被点燃的人跑到区间左端点的时间比第一种情况晚了 <span class="math inline">\(c\)</span> 秒，而在这段时间内所有比左端点还靠左的人可以向右跑 <span class="math inline">\(cv\)</span> 的距离，根据相对运动的思想，他们之间的相对距离没有变化。</p>
<p>这样的话，当两个人相遇的时候，我们可以认为是给烟花棒的延长时间续了 <span class="math inline">\(T\)</span> 秒。</p>
<p>同时，我们注意到，如果两个人走的方向相同，那么他们的相对位置不变，即如果某一刻掉头去点燃另外一边的人，所用时是不会因为你之前的选择而变化。这样的话，我们定义两个数列 <span class="math inline">\(a_i=\frac{X_{i+1}-X_i}{2v},i&lt;k\)</span>，<span class="math inline">\(b_i=\frac{X_i-X_{i-1}}{2v},i&gt;k\)</span>，即一开始从 <span class="math inline">\(X_{i+1/i-1}\)</span> 到 <span class="math inline">\(X_i\)</span> 的用时。则问题被转化为：你需要删掉这两个数列的所有数，且数列内部要按顺序删，每删掉一个数将先减少 <span class="math inline">\(a_i/b_i\)</span> 的剩余时间然后增加 <span class="math inline">\(T\)</span> 秒剩余时间，问是否存在一个方案使得任何时刻剩余时间都非负。</p>
<p>我们尝试把数列缩成若干段，使得每一段都有总获得时间大于等于总消耗时间，且对于该段不存在同样满足该性质的前缀（认为 <span class="math inline">\(a_{k-1}\)</span> 是头，<span class="math inline">\(a_1\)</span> 是尾）。这样每一段都可以用一个二元组 <span class="math inline">\((c,val)\)</span> 表示消完这一组至少需要 <span class="math inline">\(c\)</span> 秒，消完后可以获得 <span class="math inline">\(val\)</span> 秒时间，显然我们一次只会消去一整组而不是某个前缀。</p>
<p>如果我们能把两个序列都分为这样的一些组，我们可以每次贪心选 <span class="math inline">\(c\)</span> 较小的然后看能不能全部选完，如果可以删完那么这个 <span class="math inline">\(v\)</span> 就合法，反之不合法。</p>
<p>如果某个序列不能，说明这个序列存在某个后缀，使得对任意该后缀的前缀，总消耗时间都大于总获得时间。我们发现实际上我们是知道最后的剩余时间的，所以我们考虑时间倒流，这样的话删掉一个数等价于先消耗 <span class="math inline">\(T\)</span> 时间再获得 <span class="math inline">\(a_i/b_i\)</span> 的时间，依旧是任何时刻剩余时间非负。由该后缀的性质可知反过来做不会再遇到一个这样的后缀了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,t,x[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;a,b;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; &gt;c,d;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> eps=<span class="number">1e-12</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.clear(),b.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)a.push_back(<span class="number">0.5</span>*(x[i+<span class="number">1</span>]-x[i])/v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;=n;i++)b.push_back(<span class="number">0.5</span>*(x[i]-x[i<span class="number">-1</span>])/v);</span><br><span class="line">    <span class="keyword">double</span> now=<span class="number">0</span>,minn=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp1=<span class="number">-1</span>,tmp2=<span class="number">-1</span>;</span><br><span class="line">    c.clear(),d.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now-=a[i];</span><br><span class="line">        minn=min(minn,now);</span><br><span class="line">        now+=t;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;-eps)c.push_back(make_pair(-minn,now)),minn=<span class="number">1e18</span>,now=<span class="number">0</span>,tmp1=i;</span><br><span class="line">    &#125;</span><br><span class="line">    now=<span class="number">0</span>,minn=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now-=b[i];</span><br><span class="line">        minn=min(minn,now);</span><br><span class="line">        now+=t;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;-eps)d.push_back(make_pair(-minn,now)),minn=<span class="number">1e18</span>,now=<span class="number">0</span>,tmp2=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    now=t;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;c.size()||q&lt;d.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;c.size()&amp;&amp;now&gt;=c[p].first)now+=c[p].second,p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q&lt;d.size()&amp;&amp;now&gt;=d[q].first)now+=d[q].second,q++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c.clear(),d.clear();</span><br><span class="line">    now=<span class="number">0</span>,minn=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;tmp1;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        now-=t;</span><br><span class="line">        minn=min(minn,now);</span><br><span class="line">        now+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(now&gt;-eps)c.push_back(make_pair(-minn,now)),minn=<span class="number">1e18</span>,now=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now=<span class="number">0</span>,minn=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=b.size()<span class="number">-1</span>;i&gt;tmp2;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        now-=t;</span><br><span class="line">        minn=min(minn,now);</span><br><span class="line">        now+=b[i];</span><br><span class="line">        <span class="keyword">if</span>(now&gt;-eps)d.push_back(make_pair(-minn,now)),minn=<span class="number">1e18</span>,now=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    now=t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)now-=a[i],now+=t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.size();i++)now-=b[i],now+=t;</span><br><span class="line">    <span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;c.size()||q&lt;d.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;c.size()&amp;&amp;now&gt;=c[p].first)now+=c[p].second,p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q&lt;d.size()&amp;&amp;now&gt;=d[q].first)now+=d[q].second,q++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x[i]);</span><br><span class="line">        <span class="keyword">if</span>(x[i]!=x[i<span class="number">-1</span>])flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;<span class="built_in">puts</span>(<span class="string">"0"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「WC2019」数树</title>
    <url>/2020/07/22/%E3%80%8CWC2019%E3%80%8D%E6%95%B0%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5206" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>对于确定的边集 <span class="math inline">\(E_1,E_2\)</span>，显然方案数等于 <span class="math inline">\(y^{n-|E_1\cap E_2|}\)</span>（因为如果一条边都出现那么两个端点取值相同）。</p>
<h3 id="subtask-0">Subtask 0</h3>
<p>两棵树都给定，只需要开一个 <code>set&lt;pair&lt;int,int&gt;&gt;</code> 然后数一下重边数目快速幂输出一下就可以了。</p>
<h3 id="subtask-1">Subtask 1</h3>
<p>首先，为了方便，我们取 <span class="math inline">\(y\)</span> 的逆元，以后说的 <span class="math inline">\(y\)</span> 均为取逆元之后的，然后我们只需要只计算 <span class="math inline">\(\sum y^{|E_1\cap E_2|}\)</span> 的值，以下认为我们求的 <span class="math inline">\(ans\)</span> 均为取完逆元后 <span class="math inline">\(\sum y^{|E_1\cap E_2|}\)</span> 的值 ，然后把求出的结果再乘上 <span class="math inline">\(y^n\)</span>（这里的 <span class="math inline">\(y\)</span> 是最初输入的）就可以了。</p>
<p>我们考虑枚举 <span class="math inline">\(E=E_1\cap E_2\)</span>，然后再计算包含边集 <span class="math inline">\(E\)</span> 的方案数。为了计算这个，我们需要先考虑子问题：现在给定 <span class="math inline">\(m\)</span> 个连通块，第 <span class="math inline">\(i\)</span> 个连通块的大小为 <span class="math inline">\(siz_i\)</span>，求把它们联通成一棵树的方案数。</p>
<p>我们考虑 prufer 序列。首先，一个 prufer 序列对应一棵无根树；另外，对于树中的任意一点 <span class="math inline">\(i\)</span>，若其在 prufer 序列中出现了 <span class="math inline">\(d_i\)</span> 次，则 <span class="math inline">\(x\)</span> 的度数为 <span class="math inline">\(d_i+1\)</span>。这样的话，我们枚举每个连通块在 prufer 序列中出现了几次，式子如下： <span class="math display">\[
(m-2)!\sum\limits_{d_1+d_2+\dots+d_{m}=m-2}\prod_{i=1}^{m}\frac{siz_i^{d_i+1}}{d_i!}
\]</span> 这个式子的意思是枚举每个数的出现次数，然后每一条出边都可以连连通块内的任何一个点，方案数为 <span class="math inline">\(siz_i\)</span>，有 <span class="math inline">\(d_i+1\)</span> 条出边总方案数为 <span class="math inline">\(siz_i^{d_i+1}\)</span>。然后因为是一个排列，所以要做一个多重集排列。</p>
<p>为了上下统一，我们提出一个 <span class="math inline">\(\prod\limits_{i=1}^msiz_i\)</span>，那么就变成了 <span class="math display">\[
(m-2)!\left(\prod\limits_{i=1}^msiz_i\right)\sum\limits_{d_1+d_2+\dots+d_{m}=m-2}\prod_{i=1}^{m}\frac{siz_i^{d_i}}{d_i!}
\]</span> 我们注意到 <span class="math inline">\(\frac{siz_i^{d_i}}{d_i!}\)</span>，这等于 <span class="math inline">\([x^{d_i}]e^{siz_ix}\)</span>，又看到乘积与 <span class="math inline">\(\sum d_i=m-2\)</span> ，这提示我们写成 EGF 相乘，那么就可以化成 <span class="math display">\[
\begin{aligned}
&amp;(m-2)!\left(\prod\limits_{i=1}^msiz_i\right)[x^{m-2}]\prod\limits_{i=1}^me^{siz_ix}\\
=&amp;(m-2)!\left(\prod\limits_{i=1}^msiz_i\right)[x^{m-2}]e^{\sum\limits_{i=1}^msiz_ix}\\
=&amp;(m-2)!\left(\prod\limits_{i=1}^msiz_i\right)[x^{m-2}]e^{nx}\\
=&amp;(m-2)!\left(\prod\limits_{i=1}^msiz_i\right)\frac{n^{m-2}}{(m-2)!}\\
=&amp;n^{m-2}\prod\limits_{i=1}^msiz_i
\end{aligned}
\]</span></p>
<p>（注：这个式子也可以通过其它方法得到）发现这个式子竟然惊人的简洁，我们尝试来计算答案。如果你直接枚举重合的边集，然后计算方案数再乘上权值，你不难得到这个式子： <span class="math display">\[
ans=\sum\limits_{E\subseteq E_1}y^{|E|}n^{n-|E|-2}\prod\limits_{i=1}^{n-|E|}siz_i
\]</span> 如果你直接写一个枚举边集的指数暴力，你会发现你 WA 的很惨，是哪里出了问题呢？我们发现我们现在是钦定了一些重边然后剩下的随便连，但是如果你随便连的边又和 <span class="math inline">\(T_1\)</span> 里的边重复了，那权值就不是 <span class="math inline">\(y^{|E|}\)</span> 了。</p>
<p>怎么办？其实解决方法很简单（这里指式子的变化很少而不是很好想到 /kk）：我们注意到，对于某种方案，假设我们钦定的边集大小为 <span class="math inline">\(|E|\)</span>，实际上重合的边集为 <span class="math inline">\(E&#39;\)</span>，那么实际上 <span class="math inline">\(E&#39;\)</span> 的权值一共被算了 <span class="math inline">\(\binom{|E&#39;|}{|E|}\)</span> 次。也就是说一种方案，实际被算的贡献为 <span class="math inline">\(\sum\limits_{i=0}^{|E&#39;|}\binom{|E&#39;|}{i}y^i\)</span>，不难发现这是一个二项式定理的形式，它等于 <span class="math inline">\((y+1)^{|E&#39;|}\)</span>。那么如果我们让 <span class="math inline">\(y\)</span> 减去 <span class="math inline">\(1\)</span>，算的就是正确的了。</p>
<p>所以我们直接 <code>y--</code>，就可以继续用上面那个式子了。（注意从现在开始包括下一个子任务我们所说的 <span class="math inline">\(y\)</span> 都是取完逆元再减 <span class="math inline">\(1\)</span> 之后的）</p>
<p>到目前为止，算法依旧是指数级的，我们考虑用树形 dp 来计算边集的贡献。</p>
<p>首先，为了方便后续计算，我们提一个 <span class="math inline">\(n^{n-2}\)</span> 出来。</p>
<p>有一个比较好想的朴素方法：设 <span class="math inline">\(f[i][j]\)</span> 表示以 <span class="math inline">\(i\)</span> 为根的子树，目前以 <span class="math inline">\(i\)</span> 为根的连通块大小为 <span class="math inline">\(j\)</span> 的所有贡献。那么转移枚举当前点和某个儿子之间的边选不选：如果选加上对应的连通块大小，并且因为多选了一条边乘上 <span class="math inline">\(yn^{-1}\)</span>，如果不选就把儿子的连通块大小乘进去。</p>
<p>这样做是 <span class="math inline">\(O(n^2)\)</span> 的，无法通过。我们考虑一个等价关系：选若干个连通块，再把每个联通块的 <span class="math inline">\(siz\)</span> 相乘，这等价于选若干个连通块，并且在每个连通块内选出一个代表点的方案数。所以我们可以优化状态：设 <span class="math inline">\(f[i][0/1]\)</span> 为以 <span class="math inline">\(i\)</span> 为根的子树，<span class="math inline">\(i\)</span> 所在的连通块内是否选了代表点的方案数乘上对应的权值。这样的话转移我们枚举边连不连，代表点选不选，具体方程如下： <span class="math display">\[
\begin{aligned}
&amp;f[i][0]=yn^{-1}f[i][0]f[to][0]+f[i][0]f[to][1]\\
&amp;f[i][1]=yn^{-1}(f[i][0]f[to][1]+f[i][1]f[to][0])+f[i][1]f[to][1]
\end{aligned}
\]</span> 注意一下等号右边的 <span class="math inline">\(f[i][x]\)</span> 指的是算这个儿子之前的。这样 <span class="math inline">\(f[1][1]\)</span> 乘上我们之前说的就是答案。</p>
<h3 id="subtask-2">Subtask 2</h3>
<p>为了方便，我们设 <span class="math inline">\(f(E)=n^{m-2}\prod\limits_{i=1}^msiz_i,m=n-|E|\)</span>，即确定了 <span class="math inline">\(E\)</span> 中的边剩下连成一棵树的方案数。那么答案即为 <span class="math display">\[
\sum\limits_Ef^2(E)y^{|E|}
\]</span> 即钦定重边的边集，并且计算贡献，上一个子任务的关于 <span class="math inline">\(y\)</span> 的容斥在这里依旧是适用的，因为我们之前 <code>y--</code> 过了所以这里没有 <span class="math inline">\(-1\)</span>。</p>
<p>我们枚举连通块的个数，设 <span class="math inline">\(g(i)=\sum\limits_{|E|=i}f^2(E)\)</span>，则 <span class="math inline">\(ans=\sum\limits_{i=0}^{n-1}g(i)y^i\)</span>。我们尝试计算 <span class="math inline">\(g(i)\)</span>，这可以通过枚举每个连通块的大小来实现，下面先给出式子： <span class="math display">\[
g(s)=\sum\limits_{a_1+a_2+\dots+a_{n-s}=n}\frac{n!}{(n-s)!}\prod_{i=1}^{n-s}\frac{a_i^{a_i-2}}{a_i!}\left(n^{n-s-2}\prod\limits_{j=1}^{n-s}a_j\right)^2
\]</span> 这个式子的意义是，首先枚举集合大小，然后计算所有满足连通块大小等于所枚举的森林的方案数：这等于先划分集合，这是一个多重集划分，方案数为 <span class="math inline">\(\frac{n!}{\prod\limits_{i=1}^{n-s}a_i!}\)</span>。然后因为集合是无序的，所以需要再除掉 <span class="math inline">\((n-s)!\)</span>，即集合的全排列数，最后括号里的内容即为 <span class="math inline">\(f^2(E)\)</span>。我们把括号展开，然后尝试化简 <span class="math display">\[
\begin{aligned}
g(s)&amp;=\sum\limits_{a_1+a_2+\dots+a_{n-s}=n}\frac{n!}{(n-s)!}\prod_{i=1}^{n-s}\frac{a_i^{a_i-2}}{a_i!}n^{2n-2s-4}\prod\limits_{j=1}^{n-s}a_j^2\\
&amp;=n^{2n-2s-4}\frac{n!}{(n-s)!}\sum\limits_{a_1+a_2+\dots+a_{n-s}=n}\prod_{i=1}^{n-s}\frac{a_i^{a_i}}{a_i!}\\
\end{aligned}
\]</span> 然后枚举答案 <span class="math display">\[
\begin{aligned}
ans&amp;=\sum_{s=0}^{n-1}y^sn^{2n-2s-4}n!\sum\limits_{a_1+a_2+\dots+a_{n-s}=n}\frac{1}{(n-s)!}\prod_{i=1}^{n-s}\frac{a_i^{a_i}}{a_i!}\\
&amp;=n!\sum_{s=0}^{n-1}y^sn^{2n-2s-4}\frac{1}{(n-s)!}\sum\limits_{a_1+a_2+\dots+a_{n-s}=n}\prod_{i=1}^{n-s}\frac{a_i^{a_i}}{a_i!}\\
\end{aligned}
\]</span> 然后我们用 <span class="math inline">\(n-s\)</span> 替换 <span class="math inline">\(s\)</span> <span class="math display">\[
\begin{aligned}
ans&amp;=n!\sum_{s=1}^{n}y^{n-s}n^{2s-4}\frac{1}{s!}\sum\limits_{a_1+a_2+\dots+a_s=n}\prod_{i=1}^s\frac{a_i^{a_i}}{a_i!}\\
&amp;=\frac{n!y^n}{n^4}\sum_{s=1}^{n}y^{-s}n^{2s}\frac{1}{s!}\sum\limits_{a_1+a_2+\dots+a_s=n}\prod_{i=1}^s\frac{a_i^{a_i}}{a_i!}\\
\end{aligned}
\]</span> 和我们上面推出生成树计数的式子一样，后面的求和+连乘积也可以写成 EGF 的形式，即 <span class="math display">\[
\begin{aligned}
ans&amp;=\frac{n!y^n}{n^4}\sum_{s=1}^{n}y^{-s}n^{2s}\frac{1}{s!}[x^n]\left( \sum\limits_ {i=1}^{\infty}\frac{(ix)^i}{i!}\right)^s
\end{aligned}
\]</span> 然后我们把枚举的 <span class="math inline">\(s\)</span> 也丢进去 <span class="math display">\[
\begin{aligned}
ans&amp;=\frac{n!y^n}{n^4}[x^n]\sum\limits_{s=1}^n\frac{\left(\frac{n^2}{y}\sum\limits_{i=1}^{\infty}\frac{i^i}{i!}x^i\right)^s}{s!}\\
&amp;=\frac{n!y^n}{n^4}[x^n]e^{\left(\frac{n^2}{y}\sum\limits_{i=1}^{\infty}\frac{i^i}{i!}x^i\right)}
\end{aligned}
\]</span> 需要一个多项式 exp，这样这道题就做完了。</p>
<p>其实最后一部分也可以先写出树贡献的 EGF 然后根据 exp 的组合意义直接得到森林的 EGF。</p>
<p>最后还有一点，对于子任务1,2，因为我们 <code>y--</code> 过，所以当输入的 <span class="math inline">\(y=1\)</span> 的时候会出现奇怪的问题，我们需要特判一下。</p>
<p>题解可能和 <span class="citation" data-cites="Zhang_RQ">@Zhang_RQ</span> 的比较像，因为他是我们学长，这题是他讲的，借鉴了一部分他的博客。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> p=<span class="number">998244353</span>,g=<span class="number">3</span>,gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,y,op;</span><br><span class="line"><span class="keyword">namespace</span> subtask0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;s;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">"1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> a,b,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b)swap(a,b);</span><br><span class="line">            s.insert(make_pair(a,b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b)swap(a,b);</span><br><span class="line">            <span class="keyword">if</span>(s.find(make_pair(a,b))!=s.end())cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,pw(y,n-cnt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> subtask1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> target[<span class="number">200005</span>],pre[<span class="number">200005</span>],last[<span class="number">100005</span>],tot,f[<span class="number">100005</span>][<span class="number">2</span>],</span><br><span class="line">    tmp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        target[++tot]=y;</span><br><span class="line">        pre[tot]=last[x];</span><br><span class="line">        last[x]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f[x][<span class="number">0</span>]=f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tar=target[i];</span><br><span class="line">            <span class="keyword">if</span>(tar==fa)<span class="keyword">continue</span>;</span><br><span class="line">            dfs(tar,x);</span><br><span class="line">            <span class="keyword">int</span> t0=f[x][<span class="number">0</span>],t1=f[x][<span class="number">1</span>];</span><br><span class="line">            f[x][<span class="number">0</span>]=(<span class="number">1l</span>l*tmp*t0%p*f[tar][<span class="number">0</span>]%p+<span class="number">1l</span>l*t0*f[tar][<span class="number">1</span>]%p)%p;</span><br><span class="line">            f[x][<span class="number">1</span>]=(<span class="number">1l</span>l*tmp*(<span class="number">1l</span>l*t0*f[tar][<span class="number">1</span>]%p+<span class="number">1l</span>l*t1*f[tar][<span class="number">0</span>]%p)%p</span><br><span class="line">                    +<span class="number">1l</span>l*t1*f[tar][<span class="number">1</span>]%p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,pw(n,n<span class="number">-2</span>));<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> Y=y;</span><br><span class="line">        y=pw(y,p<span class="number">-2</span>);</span><br><span class="line">        y+=p<span class="number">-1</span>,y%=p;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        tmp=<span class="number">1l</span>l*y*pw(n,p<span class="number">-2</span>)%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b),add(a,b),add(b,a);</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,<span class="number">1l</span>l*f[<span class="number">1</span>][<span class="number">1</span>]*pw(Y,n)%p*pw(n,n<span class="number">-2</span>)%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> subtask2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">400005</span>],X[<span class="number">400005</span>],Y[<span class="number">400005</span>],Z[<span class="number">400005</span>],f[<span class="number">400005</span>],G[<span class="number">400005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">            x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">            y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>,wn=pw((op==<span class="number">1</span>)?g:gi,(p<span class="number">-1</span>)/len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i,w=<span class="number">1</span>;j&lt;i+q;j++,w=<span class="number">1l</span>l*w*wn%p)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> d=<span class="number">1l</span>l*f[j+q]*w%p;</span><br><span class="line">                    f[j+q]=(f[j]-d+p)%p;</span><br><span class="line">                    f[j]+=d,f[j]%=p;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=pw(n,p<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i]=<span class="number">1l</span>l*f[i]*t%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=pw(f[<span class="number">0</span>],p<span class="number">-2</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        getinv(f,g,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)X[i]=f[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++)X[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">        getrev(len);</span><br><span class="line">        ntt(X,len,<span class="number">1</span>),ntt(g,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)g[i]=<span class="number">1l</span>l*g[i]*(<span class="number">2l</span>l<span class="number">-1l</span>l*X[i]*g[i]%p+p)%p;</span><br><span class="line">        ntt(g,len,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++)g[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)f[i]=<span class="number">1l</span>l*(i+<span class="number">1</span>)*f[i+<span class="number">1</span>]%p;</span><br><span class="line">        f[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inte</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)f[i]=<span class="number">1l</span>l*pw(i,p<span class="number">-2</span>)*f[i<span class="number">-1</span>]%p;</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getln</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        getinv(f,g,n);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)Y[i]=f[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++)Y[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">        dir(Y,n);</span><br><span class="line">        getrev(len);</span><br><span class="line">        ntt(Y,len,<span class="number">1</span>),ntt(g,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)g[i]=<span class="number">1l</span>l*Y[i]*g[i]%p;</span><br><span class="line">        ntt(g,len,<span class="number">-1</span>);</span><br><span class="line">        inte(g,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++)g[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getexp</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        getexp(f,g,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)Z[i]=<span class="number">0</span>;</span><br><span class="line">        getln(g,Z,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)Z[i]=(f[i]-Z[i]+p)%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++)Z[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">        Z[<span class="number">0</span>]=(Z[<span class="number">0</span>]+<span class="number">1</span>)%p;</span><br><span class="line">        getrev(len);</span><br><span class="line">        ntt(Z,len,<span class="number">1</span>),ntt(g,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)g[i]=<span class="number">1l</span>l*g[i]*Z[i]%p;</span><br><span class="line">        ntt(g,len,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++)g[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,pw(n,<span class="number">2</span>*n<span class="number">-4</span>));<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> Y=y;</span><br><span class="line">        y=pw(y,p<span class="number">-2</span>);</span><br><span class="line">        y+=p<span class="number">-1</span>,y%=p;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">1l</span>l*n*n%p*pw(y,p<span class="number">-2</span>)%p,inv=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            inv=<span class="number">1l</span>l*inv*pw(i,p<span class="number">-2</span>)%p,f[i]=<span class="number">1l</span>l*c*pw(i,i)%p*inv%p;</span><br><span class="line">        getexp(f,G,n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,<span class="number">1l</span>l*G[n]*pw(inv,p<span class="number">-2</span>)%p*pw(y,n)%p*pw(pw(n,<span class="number">4</span>),p<span class="number">-2</span>)%p*pw(Y,n)%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;y,&amp;op);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">0</span>)subtask0::main();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">1</span>)subtask1::main();</span><br><span class="line">    <span class="keyword">else</span> subtask2::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>容斥</tag>
        <tag>多项式</tag>
        <tag>prufer 序列</tag>
      </tags>
  </entry>
  <entry>
    <title>「USACO19FEB」Mowing Mischief P</title>
    <url>/2020/07/21/%E3%80%8CUSACO19FEB%E3%80%8DMowing_Mischief_P/</url>
    <content><![CDATA[<p>给你一个长、宽均为 <span class="math inline">\(T\)</span> 的网格图，左下角坐标为 <span class="math inline">\((0,0)\)</span>，右上角坐标为 <span class="math inline">\((T,T)\)</span>。现在图上面有 <span class="math inline">\(n\)</span> 个点（一定在格点上），你需要选择一些点，使得你选择的点按 <span class="math inline">\(x\)</span> 从小到大排序后 <span class="math inline">\(y\)</span> 也单调上升。最大化选的点的数量；在此基础上，让排序好的相邻的两点形成的矩形的面积之和最小。输出最小面积和。<span class="math inline">\(T\leqslant 10^6,N\leqslant 2\times 10^5\)</span>。</p>
<a id="more"></a>
<p>首先，对于最大化选点的数量，这可以看作按 <span class="math inline">\(x\)</span> 排好序之后求一遍 LIS。为了方便，我们把按 <span class="math inline">\(x\)</span> 排完序的点重编号，以后认为 <span class="math inline">\(i&lt;j\)</span> 等价于 <span class="math inline">\(x_i&lt;x_j\)</span>（题目保证了不存在两个点使得 <span class="math inline">\(x\)</span> 或 <span class="math inline">\(y\)</span> 相等）。我们设 <span class="math inline">\(l_i\)</span> 为以 <span class="math inline">\(i\)</span> 结尾的 LIS 的长度。</p>
<p>第二问比较明显还需要 dp 求解，为了保证选的点数最多，我们只能在 <span class="math inline">\(l\)</span> 值相差为 <span class="math inline">\(1\)</span> 的点之间进行转移。具体地，设 <span class="math inline">\(f[i]\)</span> 为选择了以 <span class="math inline">\(i\)</span> 为结尾的 <span class="math inline">\(l_i\)</span> 个点矩形面积和的最小值，那么转移显然： <span class="math display">\[
f[i]=\min_{l_i=l_j+1,j&lt;i,y_j&lt;y_i}f[j]+(x_i-x_j)(y_i-y_j)
\]</span> 这样就有了一个 <span class="math inline">\(O(n^2)\)</span> 的朴素算法。</p>
<p>这个东西可能看起来有一些像斜率优化，但是并不行，因为拆开括号以后既有 <span class="math inline">\(x_iy_j\)</span> 项又有 <span class="math inline">\(x_jy_i\)</span> 项，斜率优化做不了这个。</p>
<p>我们考虑另外一个优化办法——决策单调性。我们先把括号拆开： <span class="math display">\[
f[i]=\min_{l_i=l_j+1,j&lt;i,y_j&lt;y_i}f[j]+x_iy_i-x_iy_j-x_jy_i+x_jy_j
\]</span> 假设现在有两个决策点 <span class="math inline">\(j,k\ (j&lt;k)\)</span>，正在进行决策的是 <span class="math inline">\(i\)</span>，那么 <span class="math inline">\(j\)</span> 比 <span class="math inline">\(k\)</span> 优当且仅当 <span class="math display">\[
f[j]+x_iy_i-x_iy_j-x_jy_i+x_jy_j\leq f[k]+x_iy_i-x_iy_k-x_ky_i+x_ky_k\\
f[j]-x_iy_j-x_jy_i+x_jy_j\leq f[k]-x_iy_k-x_ky_i+x_ky_k\\
(y_k-y_j)x_i+(x_k-x_j)y_i\leq f[k]-f[j]+x_ky_k-x_jy_j
\]</span> 我们注意到，对于两个 <span class="math inline">\(l\)</span> 相同的点 <span class="math inline">\(j,k\)</span>，若 <span class="math inline">\(x_j&lt;x_k\)</span>，那么一定有 <span class="math inline">\(y_j&gt;y_k\)</span>。因为如果依旧有 <span class="math inline">\(y_j&lt;y_k\)</span> 那么 <span class="math inline">\(l_k\)</span> 就可以从 <span class="math inline">\(l_j\)</span> 转移过来，它们的 <span class="math inline">\(l\)</span> 就不相等了。反过来同理。</p>
<p>那么如果我们把 <span class="math inline">\(x_i\)</span>，<span class="math inline">\(y_i\)</span> 看作变量，那么 <span class="math inline">\(j\)</span> 比 <span class="math inline">\(k\)</span> 优的情况对应了坐标系里的一个半平面（也就是不等式的解集），而且因为我们钦定 <span class="math inline">\(j&gt;k\)</span>，那么这个半平面一定长这个样子</p>
<p><img src="/2020/07/21/%E3%80%8CUSACO19FEB%E3%80%8DMowing_Mischief_P/1.png"></p>
<p>其中蓝色为解集部分，解集一定是一条斜率为正的直线的下方。那么要更新的点一定被这条直线分为了两部分。那么如果在 <span class="math inline">\(i\)</span> 时，<span class="math inline">\(j\)</span> 比 <span class="math inline">\(k\)</span> 优（即点 <span class="math inline">\(i\)</span> 在蓝色区域内），那么对于 <span class="math inline">\(u&gt;i\)</span>，<span class="math inline">\(j\)</span> 也一定比 <span class="math inline">\(k\)</span> 优。这样的话对于一组 <span class="math inline">\(l\)</span> 相同的询问，他们的最优决策位置一定是单调不增的。这就可以决策单调性了。</p>
<p>注意一下上面的分析都忽略了 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的限制，那么如何满足呢？注意到对于任何一个点，可行的决策点都是一个区间，所以对每一排开一个线段树，线段树分治一下，把询问丢到所有符合要求的区间内，这样如果一个询问被挂在了某个区间内，区间内的点都可以转移到它，最后把答案取 <span class="math inline">\(\max\)</span> 就好了。如果以分治或者二分+单调队列计算决策单调性，总的复杂度为 <span class="math inline">\(O\left(n(\log^2n+\log T)\right)\)</span>。</p>
<p>需要特殊注意的是每次计算一个区间时，不要直接和 <span class="math inline">\(f[mid]\)</span> 比较，需要再开一个变量记录只包含这段区间中的决策点时的最小值，要不然有时已经算过的 <span class="math inline">\(f[mid]\)</span> 比整个区间的决策都优，这样就会错误。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flower</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,ans;</span><br><span class="line">&#125;c[<span class="number">200015</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll <span class="keyword">const</span> inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1000005</span>],T;</span><br><span class="line">ll f[<span class="number">200015</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;x++;<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=T+<span class="number">1</span>;i+=(i&amp;(-i)))tree[i]=max(tree[i],y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;x++;<span class="keyword">int</span> res=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=(i&amp;(-i)))res=max(res,tree[i]);<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(flower x,flower y)</span></span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">200015</span>],buc[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> id,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[v[d<span class="number">-1</span>][l]].x&gt;c[id].x||c[v[d<span class="number">-1</span>][r]].y&gt;c[id].y)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(c[v[d<span class="number">-1</span>][l]].x&lt;c[id].x&amp;&amp;c[v[d<span class="number">-1</span>][l]].y&lt;c[id].y&amp;&amp;</span><br><span class="line">       c[v[d<span class="number">-1</span>][r]].x&lt;c[id].x&amp;&amp;c[v[d<span class="number">-1</span>][r]].y&lt;c[id].y)&#123;buc[x].pb(id);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    insert(l,mid,x*<span class="number">2</span>,id,d);insert(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,id,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,id=<span class="number">0</span>;</span><br><span class="line">    ll val=inf;<span class="comment">//注意这里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ql;i&lt;=qr;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[v[d<span class="number">-1</span>][i]]+<span class="number">1l</span>l*(c[buc[x][mid]].x-c[v[d<span class="number">-1</span>][i]].x)*</span><br><span class="line">        (c[buc[x][mid]].y-c[v[d<span class="number">-1</span>][i]].y)&lt;val)</span><br><span class="line">            val=f[v[d<span class="number">-1</span>][i]]+<span class="number">1l</span>l*(c[buc[x][mid]].x-c[v[d<span class="number">-1</span>][i]].x)*</span><br><span class="line">        (c[buc[x][mid]].y-c[v[d<span class="number">-1</span>][i]].y),id=i;</span><br><span class="line">    f[buc[x][mid]]=min(f[buc[x][mid]],val);</span><br><span class="line">    solve(id,qr,l,mid<span class="number">-1</span>,x,d);solve(ql,id,mid+<span class="number">1</span>,r,x,d);<span class="comment">//注意x是不变的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve(l,r,<span class="number">0</span>,buc[x].size()<span class="number">-1</span>,x,d);</span><br><span class="line">    buc[x].clear();</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    dfs(l,mid,x*<span class="number">2</span>,d),dfs(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch<span class="number">-48</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n=read(),T=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)c[i].x=read(),c[i].y=read();</span><br><span class="line">    n+=<span class="number">2</span>;</span><br><span class="line">    c[n].x=c[n].y=T;</span><br><span class="line">    sort(c+<span class="number">1</span>,c+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[i].ans=ask(c[i].y)+<span class="number">1</span>,modify(c[i].y,c[i].ans),v[c[i].ans].pb(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)t=max(t,c[i].ans),f[i]=(c[i].ans==<span class="number">1</span>?<span class="number">0</span>:inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=t;i++)<span class="comment">//处理第i层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:v[i])insert(<span class="number">0</span>,v[i<span class="number">-1</span>].size()<span class="number">-1</span>,<span class="number">1</span>,j,i);<span class="comment">//线段树分治</span></span><br><span class="line">        dfs(<span class="number">0</span>,v[i<span class="number">-1</span>].size()<span class="number">-1</span>,<span class="number">1</span>,i);<span class="comment">//计算答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(c[i].ans==t)ans=min(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>线段树</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>/2020/07/14/Min_25%E7%AD%9B/</url>
    <content><![CDATA[<p>一种亚线性复杂度求积性函数前缀和的筛法。</p>
<a id="more"></a>
<p>适用条件：</p>
<ul>
<li><p><span class="math inline">\(f(p)\)</span> 为多项式（除代码外，本文 <span class="math inline">\(p\)</span> 均指质数）</p></li>
<li><p><span class="math inline">\(f(p^k)\)</span> 便于计算</p></li>
</ul>
<p>我们以 LuoguP5325 为例简单介绍。</p>
<p>求 <span class="math inline">\(\sum\limits_{i=1}^nf(i)\)</span>，其中 <span class="math inline">\(f\)</span> 是一个积性函数，且 <span class="math inline">\(f(p^k)=p^k(p^k-1)\)</span>。<span class="math inline">\(n\leqslant10^{10}\)</span>。</p>
<p>Min_25筛的主要思想是把要求的前缀和转化为质数和非质数两部分进行计算。</p>
<h5 id="第一部分">第一部分</h5>
<p>对于质数部分，我们定义以下函数： <span class="math display">\[
g(n,j)=\sum\limits_{i=2}^n[i\ \text{is a prime or}\ \text{minp}(i)&gt;p_j]i^k
\]</span> 其中，<span class="math inline">\(p_j\)</span> 表示第 <span class="math inline">\(j\)</span> 个质数，<span class="math inline">\(\text{minp}(i)\)</span> 表示 <span class="math inline">\(i\)</span> 的最小质因子。翻译成中文就是对所有质数和最小质因子大于第 <span class="math inline">\(j\)</span> 个质数的 <span class="math inline">\(k\)</span> 次幂求和。</p>
<p>这里需要注意，如果我们求的 <span class="math inline">\(f(p)\)</span> 是一个多项式，就拆成单项式。比如这题就是 <span class="math inline">\(p^2-p\)</span>，那么我们就计算 <span class="math inline">\(g_1\)</span> 和 <span class="math inline">\(g_2\)</span> 分别代表一次项的和以及二次项的和，这里先不管系数，会在后面算上。</p>
<p>我们考虑计算 <span class="math inline">\(g(n,j)\)</span>，这是一个比较明显的可以递推的式子，于是我们尝试从 <span class="math inline">\(g(n,j-1)\)</span> 递推到 <span class="math inline">\(g(n,j)\)</span>。</p>
<p>发现 <span class="math inline">\(g(n,j-1)\)</span> 和 <span class="math inline">\(g(n,j)\)</span> 实际上只差了最小质因子为 <span class="math inline">\(p_j\)</span>（不包括 <span class="math inline">\(p_j\)</span> 本身）的函数值，所以我们只需要减掉这些多出来的值就可以了，下面先给出式子： <span class="math display">\[
g(n,j)=g(n,j-1)-p_j^k\left(g(\frac{n}{p_j},j-1)-g(p_{j-1},j-1)\right)
\]</span> 注意一下这里除法为了美观没有写取整。我们发现 <span class="math inline">\(i^k\)</span> 是一个完全积性函数，所以对于所有最小质因子为 <span class="math inline">\(p_j\)</span> 的数，我们都可以提一个 <span class="math inline">\(p_j\)</span> 出来而且不需要管是否互质（也就是剩下的仍有 <span class="math inline">\(p_j\)</span> 这个因子），然后剩下的数一定小于等于 <span class="math inline">\(\frac{n}{p_j}\)</span> 且最小质因子仍大于等于 <span class="math inline">\(p_j\)</span>，所以就是 <span class="math inline">\(g(\frac{n}{p_j},j-1)\)</span>。然后发现所有小于 <span class="math inline">\(p_j\)</span> 的质数都被多减掉了，所以再用 <span class="math inline">\(g(p_{j-1},j-1)\)</span>，即所有小于等于 <span class="math inline">\(p_{j-1}\)</span> 的质数的幂次和。</p>
<p>我们注意到小于等于 <span class="math inline">\(n\)</span> 的合数，它的最小质因子一定小于等于 <span class="math inline">\(\sqrt n\)</span>，即如果 <span class="math inline">\(p_j&gt;\sqrt n\)</span> 那么 <span class="math inline">\(g(n,j)=g(n,j-1)\)</span>，所以我们只需要枚举小于等于 <span class="math inline">\(\sqrt n\)</span> 的质数。然后我们发现 <span class="math inline">\(g(p_{j-1},j-1)\)</span> 求的就是所有小于等于 <span class="math inline">\(p_{j-1}\)</span> 的质数的幂次和，而且 <span class="math inline">\(p_{j-1}\)</span> 是小于等于 <span class="math inline">\(\sqrt n\)</span> 的。所以我们一开始线性筛到 <span class="math inline">\(\sqrt n\)</span> 求出每个质数的这个东西，我们设它为 <span class="math inline">\(sp(j-1)\)</span>。然后对于 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(k\)</span> 次方和，也即是 <span class="math inline">\(g(n,\text{maxp}(n))\)</span>，其中 <span class="math inline">\(p_{\text{maxp}(n)}\)</span> 是小于等于 <span class="math inline">\(n\)</span> 的最大质数。</p>
<p>但是这样枚举量还是太大，我们发现一个很重要的式子：<span class="math inline">\(\lfloor\frac{\lfloor\frac{n}{a}\rfloor}{b}\rfloor=\lfloor\frac{n}{ab}\rfloor\)</span>。所以所有能用到的第一个数值都形如 <span class="math inline">\(\lfloor\frac{n}{a}\rfloor\)</span>，而众所周知这样的数只有 <span class="math inline">\(O(\sqrt n)\)</span> 个，所以我们只需要求出这样的 <span class="math inline">\(g\)</span> 就可以了。具体实现因为下标还是很大，用 <code>map</code> 和 <code>unordered_map</code> 都比较慢。根据那个 <span class="math inline">\(O(\sqrt n)\)</span> 的证明，我们手动离散化一下：记 <code>id1[x]</code> 为 <span class="math inline">\(x\)</span> 离散化的下标，<code>id2[x]</code> 为 <span class="math inline">\(\lfloor\frac{n}{x}\rfloor\)</span> 的下标，可以看代码。</p>
<p>这一部分的复杂度是 <span class="math inline">\(O(\frac{n^{\frac{3}{4}}}{\log n})\)</span> 的。</p>
<h5 id="第二部分">第二部分</h5>
<p>接下来，我们计算所有数的和，记 <span class="math inline">\(s(n,j)\)</span> 为 <span class="math inline">\(\sum\limits_{i=2}^n[\text{minp}(i)&gt;j]f(i)\)</span>，即所有最小质因子大于 <span class="math inline">\(p_j\)</span> 的 <span class="math inline">\(f\)</span> 的和。</p>
<p>我们依旧尝试递推，首先，我们把所有大于 质数的函数和 <span class="math inline">\(\sum g(n,\text{maxp}(n))-sp(j)\)</span> 算上（这里带上系数，比如板子题就是 <span class="math inline">\(g2(n,\text{maxp}(n))-sp2(j)-(g1(n,\text{maxp}(n))-sp1(j))\)</span> ，那么剩下合数部分枚举提出一个最小质因子，先看式子： <span class="math display">\[
s(n,j)=\sum(g(n,\text{maxp}(n))-sp(j))+\sum\limits_{c&gt;j,p_c^e\leqslant n}f(p_c^e)\left(s(\frac{n}{p_c^e},c)+[e\not=1]\right)
\]</span> 因为这一次并不是完全积性函数了，所以我们要一次把最小质因子提全，这样的话剩下的最小质因子都大于 <span class="math inline">\(p_c\)</span>，然后因为我们没算 <span class="math inline">\(1\)</span>，所以当 <span class="math inline">\(e\not=1\)</span> 的时候 <span class="math inline">\(f(p_c^e)\)</span> 没有算进去，当 <span class="math inline">\(e=1\)</span> 时会在前面质数部分算到。</p>
<p>则 <span class="math inline">\(s(n,0)+f(1)\)</span> 即为答案。这里直接递归计算，不需要记忆化。</p>
<p>这一部分的复杂度据说是 <span class="math inline">\(O(n^{1-\epsilon})\)</span> 的，即大于任何一个 <span class="math inline">\(O(n^k),k&lt;1\)</span>，但是常数很小。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll <span class="keyword">const</span> p=<span class="number">1e9</span>+<span class="number">7</span>,inv2=<span class="number">500000004</span>,inv6=<span class="number">166666668</span>;</span><br><span class="line">ll n,pr[<span class="number">100005</span>],cnt,sp1[<span class="number">100005</span>],sp2[<span class="number">100005</span>],tot,bas[<span class="number">300005</span>],g1[<span class="number">300005</span>],</span><br><span class="line">g2[<span class="number">300005</span>],sqr;</span><br><span class="line"><span class="keyword">int</span> id1[<span class="number">100005</span>],id2[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mod</span><span class="params">(ll <span class="keyword">const</span> &amp;x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">s</span><span class="params">(ll i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pr[j]&gt;=i)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t=(i&lt;=sqr)?id1[i]:id2[n/i];</span><br><span class="line">    <span class="keyword">if</span>(sp1[j]&lt;<span class="number">0</span>||sp2[j]&lt;<span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    ll res=(g2[t]-sp2[j]-(g1[t]-sp1[j])+p+p)%p;<span class="comment">//part1:质数部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=j+<span class="number">1</span>;c&lt;=cnt&amp;&amp;pr[c]*pr[c]&lt;=i;c++)<span class="comment">//part2 注意这里依旧只需要消去 sqrti 的最小质因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll now=pr[c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;now&lt;=i;e++,now*=pr[c])</span><br><span class="line">        &#123;</span><br><span class="line">            ll tmp=now%p;</span><br><span class="line">            res=(res+tmp*(tmp<span class="number">-1</span>+p)%p*(s(i/now,c)+(<span class="keyword">int</span>)(e!=<span class="number">1</span>)))%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    sqr=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=sqr;i++)<span class="comment">//get prime</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])pr[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=sqr;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*pr[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%pr[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)<span class="comment">//计算sp</span></span><br><span class="line">        sp1[i]=mod(sp1[i<span class="number">-1</span>]+pr[i]),</span><br><span class="line">        sp2[i]=mod(sp2[i<span class="number">-1</span>]+pr[i]*pr[i]%p);</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//计算 g(x,0)，因为 g(n,j) 总是由 g(xxx,j-1) 推出而且后面只需要 g(n,maxp(n)) 所以滚动掉一维</span></span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        bas[++tot]=n/l;<span class="comment">//这一次计算 g(n/l,0) 也就是 2 到 n/l 的幂次和</span></span><br><span class="line">        g1[tot]=bas[tot]%p;<span class="comment">//因为减少取模所以暂时借用一下这个数</span></span><br><span class="line">        g2[tot]=(g1[tot]*(g1[tot]+<span class="number">1</span>)%p*(<span class="number">2</span>*g1[tot]+<span class="number">1</span>)%p*inv6+p<span class="number">-1</span>)%p;</span><br><span class="line">        g1[tot]=mod((g1[tot]+<span class="number">1</span>)*g1[tot]%p*inv2%p+p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(bas[tot]&lt;=sqr)id1[bas[tot]]=tot;</span><br><span class="line">        <span class="keyword">else</span> id2[l]=tot;<span class="comment">//此时一定有 l=r</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)<span class="comment">//为了和写的式子一样换了一下内外层变量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot&amp;&amp;pr[j]*pr[j]&lt;=bas[i];i++)<span class="comment">//递推 g(bas[i],j)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll t=bas[i]/pr[j];</span><br><span class="line">            t=(t&lt;=sqr)?id1[t]:id2[n/t];<span class="comment">//找到 bas[i]/pr[j] 对应的下标</span></span><br><span class="line">            g1[i]=mod(g1[i]-pr[j]*(g1[t]-sp1[j<span class="number">-1</span>]+p)%p+p);</span><br><span class="line">            g2[i]=mod(g2[i]-pr[j]*pr[j]%p*(g2[t]-sp2[j<span class="number">-1</span>]+p)%p+p);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,mod(s(n,<span class="number">0</span>)+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>「IOI2018」会议</title>
    <url>/2020/07/04/%E3%80%8CIOI2018%E3%80%8D%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<p>给定长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(h\)</span>，有 <span class="math inline">\(q\)</span> 次询问，每次询问在 <span class="math inline">\([l,r]\)</span> 内找一个点 <span class="math inline">\(x\)</span>，使得 <span class="math inline">\([l,r]\)</span> 内每个点到 <span class="math inline">\(x\)</span> 之间最大值的和（即 <span class="math inline">\(\sum\limits_{i=l}^x\max\limits_{j=i}^xh_j+\sum\limits_{i=x+1}^r\max\limits_{j=x}^ih_j\)</span>）最小。<span class="math inline">\(n,q\leqslant 750000,h\leqslant 10^9\)</span> 。</p>
<a id="more"></a>
<p>发现这个东西没有什么一般性结论，所以我们考虑dp求解。</p>
<p>设 <span class="math inline">\(f[l,r]\)</span> 为 <span class="math inline">\([l,r]\)</span> 的答案。首先我们有一个结论，当区间内值不唯一时，区间的最大值的位置一定不为最优解（因为这样每一个元素的贡献都是最大值）。所以我们可以得到转移方程：</p>
<p><span class="math display">\[
f[l,r]=\min(f[l,mid-1]+(r-mid+1)h[mid],f[mid+1,r]+(mid-l+1)h[mid])
\]</span> 其中 <span class="math inline">\(mid\)</span> 是最大值的位置（有多个时任何一个都可以）。即我们枚举最优解的位置在最大值的左边/右边。这样就有一个 <span class="math inline">\(n^2\)</span> 的朴素算法。</p>
<p>我们发现转移方程和区间内的最大值有关系，所以我们尝试用笛卡尔树来优化dp。我们对序列建权值为大根堆的笛卡尔树，并且对每个 <span class="math inline">\([l,r]\)</span> 的询问暴力展开一次，即求 <span class="math inline">\(f[l,mid-1]\)</span> 和 <span class="math inline">\(f[mid+1,r]\)</span>。这时我们发现对于每一个 <span class="math inline">\(f[l,mid-1]\)</span> 的询问，都可以找到一个笛卡尔树中的点 <span class="math inline">\(c\)</span>，使得 <span class="math inline">\(c\)</span> 对应的右端点也为 <span class="math inline">\(mid-1\)</span>（证明可以考虑 <span class="math inline">\(mid-1\)</span> 和 <span class="math inline">\(mid\)</span> 的位置关系）。同理对于每个 <span class="math inline">\(f[mid+1,r]\)</span> 的询问，都可以找到笛卡尔树中左端点为 <span class="math inline">\(mid+1\)</span> 的点（如果不展开不一定能找到这个点，这就是为什么要展开的原因）。明显这两类询问是类似的，所以我们只考虑处理 <span class="math inline">\(f[mid+1,r]\)</span> 这一类，对于 <span class="math inline">\(f[l,mid-1]\)</span> 这一类可以反转数组和询问以后求得。</p>
<p>根据上面的结论，我们发现对于笛卡尔树中的每一个点，如果它对应的区间是 <span class="math inline">\([l,r]\)</span>，我们只需要求出 <span class="math inline">\(f[l,l],f[l,l+1]\dots f[l,r]\)</span> 的值。具体地，如果这个节点对应的点为 <span class="math inline">\(mid\)</span>，我们先递归左子树和右子树求出 <span class="math inline">\(f[l,l]\dots f[l,mid-1]\)</span> 和 <span class="math inline">\(f[mid+1,mid+1]\dots f[mid+1,r]\)</span> 然后考虑推出 <span class="math inline">\(f[l,mid]\dots f[l,r]\)</span>。</p>
<p>让我们再看一遍转移方程： <span class="math display">\[
f[l,r]=\min(f[l,mid-1]+(r-mid+1)h[mid],f[mid+1,r]+(mid-l+1)h[mid])
\]</span> 左边部分随着 <span class="math inline">\(r\)</span> 的增加，每次增加 <span class="math inline">\(h[mid]\)</span>，右边部分随着 <span class="math inline">\(r\)</span> 的增加每次增加量都小于等于 <span class="math inline">\(h[mid]\)</span>（因为 <span class="math inline">\(h[mid]\)</span> 是区间内最大的值了）所以说如果某一刻左边的值大于了右边，那么再往后左边的值都会大于右边。</p>
<p>所以我们可以维护一棵线段树，当我们在笛卡尔树上 dfs 完某个点的时候，线段树上位置 <span class="math inline">\(r\)</span> 存的东西就是 <span class="math inline">\(f[l,r]\)</span> （<span class="math inline">\(l\)</span> 是 dfs 到的节点代表区间的左端点）。我们在线段树上二分来找到第一个左边&gt;右边的位置，设为 <span class="math inline">\(pos\)</span>。那么对于小于 <span class="math inline">\(pos\)</span> 的位置，相当于先区间覆盖一次再区间加等差数列（换句话说就是用一次函数覆盖）；右边的部分就是一个区间加了。</p>
<p>所以我们的线段树需要支持区间覆盖和区间加等差数列（加一个数也是等差数列啦）。对于询问，找到我们所说的那个点 <span class="math inline">\(c\)</span> 然后把它丢进对应的桶里，dfs 完一个点的时候计算所有询问的答案。</p>
<p>至于实现我们并不需要显式地建出笛卡尔树，我们开一个 st 表然后 dfs 的时候只需要记录当前区间，递归左右儿子就在 st 表里查询区间最大值的位置就可以了。至于如何把询问挂到节点上，我们只需要把左端点相同的询问放到一个桶里，当 dfs 到一个点时，如果它是父亲的右儿子或者是根节点，那么它就是所有与它 <span class="math inline">\(l\)</span> 相同的节点中 <span class="math inline">\(r\)</span> 最大的那个，所以只需要在这类点回答询问就好了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r;ll ans[<span class="number">2</span>];&#125;c[<span class="number">750005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">3000005</span>];</span><br><span class="line"><span class="keyword">int</span> now,n,f[<span class="number">2000005</span>][<span class="number">20</span>],lg[<span class="number">750005</span>];</span><br><span class="line">ll h[<span class="number">750005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[x]!=h[y])<span class="keyword">return</span> h[x]&gt;h[y]?x:y;</span><br><span class="line">    <span class="keyword">if</span>(now)<span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=lg[y-x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> merge(f[x][t],f[y-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll tree[<span class="number">3000005</span>],cov[<span class="number">3000005</span>],addk[<span class="number">3000005</span>],addb[<span class="number">3000005</span>];</span><br><span class="line">    <span class="comment">//加一个(x-a)*c+d的等差数列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="built_in">memset</span>(cov,<span class="number">0x80</span>,<span class="keyword">sizeof</span>(cov));</span><br><span class="line">        <span class="built_in">memset</span>(addk,<span class="number">0</span>,<span class="keyword">sizeof</span>(addk));</span><br><span class="line">        <span class="built_in">memset</span>(addb,<span class="number">0</span>,<span class="keyword">sizeof</span>(addb));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cov[x]!=<span class="number">-2139062144</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[x]=cov[x];</span><br><span class="line">            <span class="keyword">if</span>(l!=r)cov[x*<span class="number">2</span>]=cov[x],cov[x*<span class="number">2</span>+<span class="number">1</span>]=cov[x],addk[x*<span class="number">2</span>]=addb[x*<span class="number">2</span>]=addk[x*<span class="number">2</span>+<span class="number">1</span>]=addb[x*<span class="number">2</span>+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            cov[x]=<span class="number">-2139062144</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(addk[x]||addb[x])</span><br><span class="line">        &#123;</span><br><span class="line">            tree[x]+=addb[x]+addk[x]*(r-l);</span><br><span class="line">            <span class="keyword">if</span>(l!=r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                addk[x*<span class="number">2</span>]+=addk[x],addb[x*<span class="number">2</span>]+=addb[x];</span><br><span class="line">                addk[x*<span class="number">2</span>+<span class="number">1</span>]+=addk[x],addb[x*<span class="number">2</span>+<span class="number">1</span>]+=addb[x]+(mid+<span class="number">1</span>-l)*addk[x];</span><br><span class="line">            &#125;</span><br><span class="line">            addk[x]=addb[x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,ll c,ll d)</span><span class="comment">//a恰好加上d</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pushdown(l,r,x);</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=a&amp;&amp;r&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            addk[x]+=c,addb[x]+=(l-a)*c+d;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)add(l,mid,x*<span class="number">2</span>,a,b,c,d);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;mid)add(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b,c,d);</span><br><span class="line">        pushdown(l,mid,x*<span class="number">2</span>),pushdown(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        tree[x]=tree[x*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,ll c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pushdown(l,r,x);</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=a&amp;&amp;r&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            cov[x]=c;</span><br><span class="line">            addk[x]=addb[x]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)modify(l,mid,x*<span class="number">2</span>,a,b,c);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;mid)modify(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b,c);</span><br><span class="line">        pushdown(l,mid,x*<span class="number">2</span>),pushdown(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        tree[x]=tree[x*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pushdown(l,r,x);</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tree[x];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)<span class="keyword">return</span> query(l,mid,x*<span class="number">2</span>,a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,ll c,ll d,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pushdown(l,r,x);</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid&amp;&amp;b&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            pushdown(l,mid,x*<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(c+(mid-(a<span class="number">-1</span>)+<span class="number">1</span>)*d&gt;tree[x*<span class="number">2</span>]+((a<span class="number">-1</span>)-e+<span class="number">1</span>)*d)</span><br><span class="line">                <span class="keyword">return</span> get(l,mid,x*<span class="number">2</span>,a,b,c,d,e);</span><br><span class="line">            <span class="keyword">return</span> get(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b,c,d,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=mid)<span class="keyword">return</span> get(l,mid,x*<span class="number">2</span>,a,b,c,d,e);</span><br><span class="line">        <span class="keyword">return</span> get(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b,c,d,e);</span><br><span class="line">    &#125;</span><br><span class="line">    ll <span class="keyword">operator</span> [](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> query(<span class="number">1</span>,n,<span class="number">1</span>,x);&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">bool</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=ask(l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(l,mid<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        T.modify(<span class="number">1</span>,n,<span class="number">1</span>,mid,mid,T[mid<span class="number">-1</span>]+h[mid]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> T.modify(<span class="number">1</span>,n,<span class="number">1</span>,mid,mid,h[mid]);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(mid+<span class="number">1</span>,r,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        ll tmp=(l&lt;mid)?T[mid<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(T[r]+(mid-l+<span class="number">1</span>)*h[mid]&gt;=tmp+(r-mid+<span class="number">1</span>)*h[mid])</span><br><span class="line">            t=r+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=T.get(<span class="number">1</span>,n,<span class="number">1</span>,mid+<span class="number">1</span>,r,tmp,h[mid],l);</span><br><span class="line">        <span class="comment">//t为第一个使得左&gt;右的位置</span></span><br><span class="line">        <span class="keyword">if</span>(t!=mid+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T.modify(<span class="number">1</span>,n,<span class="number">1</span>,mid+<span class="number">1</span>,t<span class="number">-1</span>,tmp);</span><br><span class="line">            T.add(<span class="number">1</span>,n,<span class="number">1</span>,mid+<span class="number">1</span>,t<span class="number">-1</span>,h[mid],<span class="number">2</span>*h[mid]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t!=r+<span class="number">1</span>)T.add(<span class="number">1</span>,n,<span class="number">1</span>,t,r,<span class="number">0</span>,(mid-l+<span class="number">1</span>)*h[mid]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[l].size();i++)</span><br><span class="line">            c[v[l][i]].ans[now]=T[c[v[l][i]].r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;h[i]),f[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c[i].l,&amp;c[i].r),c[i].l++,c[i].r++;</span><br><span class="line">    again:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i].clear();</span><br><span class="line">    T.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">19</span>;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i][k]=merge(f[i][k<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=ask(c[i].l,c[i].r);</span><br><span class="line">        <span class="keyword">if</span>(t!=c[i].r)v[t+<span class="number">1</span>].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!now)</span><br><span class="line">    &#123;</span><br><span class="line">        now=<span class="number">1</span>;</span><br><span class="line">        reverse(h+<span class="number">1</span>,h+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">            c[i].l=n-c[i].l+<span class="number">1</span>,c[i].r=n-c[i].r+<span class="number">1</span>,swap(c[i].l,c[i].r);</span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=ask(c[i].l,c[i].r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,min(c[i].ans[<span class="number">0</span>]+(c[i].r-t+<span class="number">1</span>)*h[t],c[i].ans[<span class="number">1</span>]+(t-c[i].l+<span class="number">1</span>)*h[t]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>笛卡尔树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2011」阿狸的打字机</title>
    <url>/2020/07/04/%E3%80%8CNOI2011%E3%80%8D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2414" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<p>首先我们发现按这个样子生成字符串的话总长可能很长，但是它们所构成的trie树节点个数最多只有 <span class="math inline">\(n+1\)</span> 个，这样的话我们考虑在trie树上来做这个问题。</p>
<p>发现这是一个字符串匹配问题，单纯的trie肯定是很难处理，所以我们把trie建成AC自动机。我们考虑AC自动机fail边的含义，它实际上指向了这个节点的存在于这个trie树中的最长的真后缀，那么如果字符串 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(y\)</span> 的某一位出现（设这位为 <span class="math inline">\(c\)</span> 则 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(y[1,c]\)</span> 的后缀）我们从这一位在AC自动机上对应的节点一直跳fail，那么一定是可以跳到 <span class="math inline">\(x\)</span> 的终止节点的。换句话说，这一位的节点在fail树中 <span class="math inline">\(x\)</span> 的子树内。</p>
<p>这样的话我们就有了一个暴力算法，对于每组询问，我们把 <span class="math inline">\(y\)</span> 的所有前缀代表的节点都打上标记，然后询问 <span class="math inline">\(x\)</span> 在fail树的子树内有多少标记。</p>
<p>（从现在开始请注意<strong>trie树</strong>和<strong>fail树</strong>的区别）我们考虑优化，首先我们可以把询问离线下来，对于 <span class="math inline">\(y\)</span> 相同的一起处理。具体地，我们计算出fail树的dfs序，那么 <span class="math inline">\(x\)</span> 在fail中的子树对应了一段dfs序的区间。我们用树状数组维护单点修改标记和区间查询就可以了。但是这样对于每一个 <span class="math inline">\(y\)</span> 还是要暴力跳前缀，复杂度还是不对，怎么办？我们只需要在trie树上dfs（注意这里是trie树！而之前和一会说的dfs序都是fail树的！），当一个节点进栈时给其fail树的dfs这个位置加上1，然后处理这个点的询问（我们给每个点开个桶，对于每个询问把它扔到 <span class="math inline">\(y\)</span> 的终止节点的桶里），出栈时再-1，这样的话复杂度就是 <span class="math inline">\(O(n\log n)\)</span> 的了。加减询问仍旧用一个树状数组就好了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">100005</span>][<span class="number">26</span>],fail[<span class="number">100005</span>],fa[<span class="number">100005</span>],ed[<span class="number">100005</span>],cnt,</span><br><span class="line">target[<span class="number">100005</span>],pre[<span class="number">100005</span>],last[<span class="number">100005</span>],tot,dfn[<span class="number">100005</span>],</span><br><span class="line">tree[<span class="number">100005</span>],ans[<span class="number">100005</span>],c,er[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=cnt+<span class="number">2</span>;i+=(i&amp;(-i)))tree[i]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=(i&amp;(-i)))res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> x,y,id;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;query&gt;v[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;to[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)<span class="keyword">if</span>(ch[<span class="number">0</span>][i])q.push(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][i])fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]);</span><br><span class="line">            <span class="keyword">else</span> ch[now][i]=ch[fail[now]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target[++tot]=y;</span><br><span class="line">    pre[tot]=last[x];</span><br><span class="line">    last[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])dfs(target[i]);</span><br><span class="line">    er[x]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mod(dfn[x],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> tar:to[x])dfs2(tar);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[x].size();i++)</span><br><span class="line">        ans[v[x][i].id]=ask(er[ed[v[x][i].x]])</span><br><span class="line">                       -ask(dfn[ed[v[x][i].x]]<span class="number">-1</span>);</span><br><span class="line">    mod(dfn[x],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">int</span> n=str.size(),m=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'B'</span>)now=fa[now];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'P'</span>)ed[++m]=now;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=str[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ch[now][c])ch[now][c]=++cnt,fa[ch[now][c]]=now;</span><br><span class="line">            now=ch[now][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)</span><br><span class="line">            <span class="keyword">if</span>(ch[i][k])to[i].push_back(ch[i][k]);</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)add(fail[i],i);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        query t;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t.x&gt;&gt;t.y;</span><br><span class="line">        t.id=i;</span><br><span class="line">        v[ed[t.y]].push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2006」网络收费</title>
    <url>/2020/06/29/%E3%80%8CNOI2006%E3%80%8D%E7%BD%91%E7%BB%9C%E6%94%B6%E8%B4%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4297" target="_blank" rel="noopener">题目链接</a></p>
<p>神仙题Orz</p>
<a id="more"></a>
<p>一开始以为是个最小割结果发现不太可做，这题的压缩祖先状态的方法真的神。</p>
<p>我们发现<strong>点对</strong>的贡献不是很好计算，所以我们考虑计算<strong>点</strong>的贡献。我们发现本质上付费系数只与 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> <strong>分别</strong>与lca的关系有关，也就是这条链的贡献可以转化为两个点对lca的贡献，即链的贡献与 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 的关系无关。具体贡献看下面。</p>
<p>首先，我们计算一个数组 <span class="math inline">\(s[i][j]\)</span>，它的值为 <span class="math inline">\(\sum\limits_{k,lca(i,k)=j}F_{i,k}\)</span> （<span class="math inline">\(i\)</span> 是叶子），我们可以通过枚举点对求出这个数组。那么某一种方案的费用我们就可以用 <span class="math inline">\(s\)</span> 的和来表示。我们现在给非叶子节点也定义状态：对于这个节点的子树，当 <span class="math inline">\(n_A\geqslant n_B\)</span> 时为状态A，当 <span class="math inline">\(n_A&lt;n_B\)</span> 时为状态 B。那么我们观察收费表可知，当 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 状态不同（<span class="math inline">\(i\)</span> 是叶子，<span class="math inline">\(j\)</span> 是 <span class="math inline">\(i\)</span> 的祖先）时，<span class="math inline">\(s[i][j]\)</span> 的贡献系数为 <span class="math inline">\(1\)</span>，状态相同时为 <span class="math inline">\(0\)</span>。举个例子，如果现在 <span class="math inline">\(n_A&lt;n_B\)</span> 而且 <span class="math inline">\(i\)</span> 选择的付费方式为 <span class="math inline">\(A\)</span> ，那么 <span class="math inline">\(s[i][j]\)</span> 对答案造成的贡献就是 <span class="math inline">\(s[i][j]\)</span> ，如果是 <span class="math inline">\(B\)</span> ，那么贡献就是 <span class="math inline">\(0\)</span>。如果我们知道了所有点的状态，对每个点和它的所有祖先都这么算一遍，我们就会不重不漏地计算出所有链的贡献（贡献系数为2就是在两个端点处都计算了一次）。</p>
<p>但是如果你直接暴力枚举状态和最朴素的暴力没有区别，我们这么计算贡献是为了方便dp。我们设 <span class="math inline">\(f[i][j][k]\)</span> 为当前dfs到节点 <span class="math inline">\(i\)</span> ，它的子树内共有 <span class="math inline">\(j\)</span> 个选了 <span class="math inline">\(B\)</span> 的叶子节点，它到根节点路径上每个点的状态为 <span class="math inline">\(k\)</span> 。那么当我们dfs到叶子节点时，所有祖先的状态都已知，我们把 <span class="math inline">\(\sum s[i][t]\)</span> 按照贡献系数加入到 <span class="math inline">\(f\)</span> 中，对于非叶子节点，我们只需要枚举左子树内有多少个 <span class="math inline">\(B\)</span> 来更新就好了。就是要注意如果你枚举这个点哪种方案多的时候要保证 <span class="math inline">\(B\)</span> 的个数合法。</p>
<p>这样的话有一个问题：我们开不下数组！所以我们直接在dfs的时候把状态记下来，也就不用开第三维了，也就是我们现在dfs到了一个非叶子节点，我们先把状态设为0，然后dfs子树，更新对应的值，再把状态设为1再dfs一遍子树，给个伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dfs(x,l,r)</span><br><span class="line">    if l&#x3D;&#x3D;r</span><br><span class="line">        calculate f[x][0] and f[x][1]</span><br><span class="line">        return</span><br><span class="line">    now[x]&#x3D;0</span><br><span class="line">    dfs(lson[x])</span><br><span class="line">    dfs(rson[x])</span><br><span class="line">    calculate f[x][0]-&gt;f[x][(r-l+1)&#x2F;2]</span><br><span class="line">    now[x]&#x3D;1</span><br><span class="line">    dfs(lson[x])</span><br><span class="line">    dfs(rson[x])</span><br><span class="line">    calculate f[x][(r-l+1)&#x2F;2+1]-&gt;f[x][r-l+1]</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>
<p>这样的话复杂度为 <span class="math inline">\(T(n)=4T(\frac{n}{2})+\Theta(n^2)\)</span> ，根据主定理知 <span class="math inline">\(T(n)=\Theta(n^2\log n)\)</span> ，用这道题里的 <span class="math inline">\(n\)</span> 也就是 <span class="math inline">\(\Theta(n2^{2n})\)</span> 。</p>
<p>感觉讲的不是很清楚（我语文不好），大家有问题的话看下代码或者留个言，代码还是很好写的就50多行。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2100</span>],t[<span class="number">2100</span>],s[<span class="number">2100</span>][<span class="number">2100</span>],f[<span class="number">2100</span>][<span class="number">2100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=y)x&gt;&gt;=<span class="number">1</span>,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> now,<span class="keyword">int</span> dep)</span><span class="comment">//0-&gt;0多  1-&gt;1多</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[x]==<span class="number">0</span>)f[x][<span class="number">0</span>]=<span class="number">0</span>,f[x][<span class="number">1</span>]=c[x];<span class="comment">//f[x][k] k个1</span></span><br><span class="line">        <span class="keyword">else</span> f[x][<span class="number">1</span>]=<span class="number">0</span>,f[x][<span class="number">0</span>]=c[x];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=x&gt;&gt;<span class="number">1</span>;i&lt;dep;i++,j&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(now&amp;(<span class="number">1</span>&lt;&lt;i))f[x][<span class="number">0</span>]+=s[x][j];</span><br><span class="line">            <span class="keyword">else</span> f[x][<span class="number">1</span>]+=s[x][j];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,sum=r-l+<span class="number">1</span>;</span><br><span class="line">    dfs(l,mid,x*<span class="number">2</span>,now*<span class="number">2</span>,dep+<span class="number">1</span>);</span><br><span class="line">    dfs(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,now*<span class="number">2</span>,dep+<span class="number">1</span>);<span class="comment">// 0 多</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=sum/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x][i]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            f[x][i]=min(f[x][i],f[x*<span class="number">2</span>][j]+f[x*<span class="number">2</span>+<span class="number">1</span>][i-j]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(l,mid,x*<span class="number">2</span>,now*<span class="number">2</span>+<span class="number">1</span>,dep+<span class="number">1</span>);</span><br><span class="line">    dfs(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,now*<span class="number">2</span>+<span class="number">1</span>,dep+<span class="number">1</span>);<span class="comment">// 1 多</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sum/<span class="number">2</span>+<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x][i]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sum/<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(i-j&lt;=sum/<span class="number">2</span>)f[x][i]=min(f[x][i],f[x*<span class="number">2</span>][j]+f[x*<span class="number">2</span>+<span class="number">1</span>][i-j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    m=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;<span class="number">2</span>*m;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;<span class="number">2</span>*m;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;<span class="number">2</span>*m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">2</span>*m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="keyword">int</span> g=lca(i,j);</span><br><span class="line">            s[i][g]+=x,s[j][g]+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,m,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)ans=min(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>「省选联考2020A卷」作业题</title>
    <url>/2020/06/29/%E3%80%8C%E7%9C%81%E9%80%89%E8%81%94%E8%80%832020A%E5%8D%B7%E3%80%8D%E4%BD%9C%E4%B8%9A%E9%A2%98/</url>
    <content><![CDATA[<p>给定一张带边权的简单无向连通图，定义一棵生成树 <span class="math inline">\(T\)</span> 的权值为 <span class="math display">\[
val(T)=\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
\]</span> 求所有生成树的权值之和。 <a id="more"></a> <span class="math inline">\(n\leqslant 30 , m\leqslant\frac{n(n-1)}{2},1\leqslant w_i\leqslant 152501\)</span> 。</p>
<p>首先我们把碍事的 <span class="math inline">\(\gcd\)</span> 消掉，这里通过欧拉反演，即 <span class="math inline">\(\varphi*I=id\)</span> （证明的话把 <span class="math inline">\(1\dots n\)</span> 的数按与 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\gcd\)</span> 分类）。当然也可以直接减掉倍数好像还更方便。那么简单推下式子： <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_T\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})（现在开始设\gcd 为 g）\\
=&amp;\sum\limits_T\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\sum\limits_{d|g}\varphi(d)\\
=&amp;\sum\limits_{d=1}^{w_{max}}\varphi(d)\sum\limits_{ T\wedge\forall i,d|w_{e_i}}\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)
\end{aligned}
\]</span> 我们枚举 <span class="math inline">\(d\)</span> ，每次找出所有 <span class="math inline">\(w_i\)</span> 为 <span class="math inline">\(d\)</span> 的倍数的边，我们现在需要求出仅由这些边构成的生成树的边权和的和。对于这个，我们构造一个模 <span class="math inline">\(x^2\)</span> 意义下的多项式矩阵，对每条边重新定义边权为 <span class="math inline">\(1+w_ix\)</span> 。基尔霍夫矩阵的主余子式等于 <span class="math inline">\(\sum\limits_T\prod\limits_{i=1}^{n-1}w_i\)</span> （这个我不会证明），那么我们把重新定义的边权带进去发现一次项系数就是我们要求的边权和之和。</p>
<p>然后我们考虑 <span class="math inline">\(\bmod x^2\)</span> 意义下的多项式四则运算，加减法没有区别，乘法：<span class="math inline">\((a+bx)(c+dx)=ac+(ad+bc)x\)</span>，除法：<span class="math inline">\(\frac{a+bx}{c+dx}=\frac{a}{c}+\frac{bc-ad}{c^2}x\)</span> （证明的话乘一个 <span class="math inline">\(c+dx\)</span> 就好了）。当 <span class="math inline">\(c=0\)</span> 怎么办？对于选取每一行的主元，我们找到不为0的次数最低的那一项，如果次数为0那么就直接做，如果为1说明这一列在当前行后面的常数项都为0，此时除法应该特判为 <span class="math inline">\(\frac{bx}{dx}=\frac{b}{d}\)</span>（我不是很确定这里的必要性，代码是否特判都过了）。这样的话对 <span class="math inline">\(1-w_{max}\)</span> 都做一遍矩阵树复杂度是 <span class="math inline">\(O(wn^3)\)</span> 的，我们可以做一个剪枝，当添加入的边大于等于 <span class="math inline">\(n-1\)</span> 时才去做矩阵树，这样的复杂度是 <span class="math inline">\(O(n^3\max\sigma_0w)\)</span> 即 <span class="math inline">\(144\times n^3\)</span> ，可以通过本题。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> N=<span class="number">152501</span>,p=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,u[<span class="number">2505</span>],v[<span class="number">2505</span>],w[<span class="number">2505</span>],phi[N+<span class="number">5</span>],pr[<span class="number">50005</span>],cnt;</span><br><span class="line"><span class="keyword">bool</span> flag[N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])pr[++cnt]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*pr[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%pr[j]))&#123;phi[i*pr[j]]=phi[i]*pr[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*pr[j]]=phi[i]*(pr[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x0,x1;</span><br><span class="line">    poly()&#123;x0=x1=<span class="number">0</span>;&#125;</span><br><span class="line">    poly(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;x0=a,x1=b;&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> +(poly a,poly b)</span><br><span class="line">        &#123;<span class="keyword">return</span> poly(mod(a.x0+b.x0),mod(a.x1+b.x1));&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> -(poly a,poly b)</span><br><span class="line">        &#123;<span class="keyword">return</span> poly(mod(a.x0-b.x0+p),mod(a.x1-b.x1+p));&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> *(poly a,poly b)</span><br><span class="line">        &#123;<span class="keyword">return</span> poly(<span class="number">1l</span>l*a.x0*b.x0%p,mod(<span class="number">1l</span>l*a.x0*b.x1%p+<span class="number">1l</span>l*a.x1*b.x0%p));&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> /(poly a,poly b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x0==<span class="number">0</span>&amp;&amp;b.x0==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> inv=pw(b.x1,p<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">return</span> poly(<span class="number">1l</span>l*a.x1*inv%p,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> inv=pw(b.x0,p<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> poly(<span class="number">1l</span>l*a.x0*inv%p,((<span class="number">1l</span>l*a.x1*b.x0<span class="number">-1l</span>l*a.x0*b.x1)%p*inv%p*inv%p+p)%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mat[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deg</span><span class="params">(poly a)</span></span>&#123;<span class="keyword">return</span> a.x0?<span class="number">0</span>:(a.x1?<span class="number">1</span>:<span class="number">2</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(deg(mat[j][i])&lt;deg(mat[c][i]))c=j;</span><br><span class="line">        <span class="keyword">if</span>(c!=i)swap(mat[i],mat[c]),f*=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg(mat[i][i])==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            poly t=mat[j][i]/mat[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                mat[j][k]=mat[j][k]-mat[i][k]*t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    poly res;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>)res=poly(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> res=poly(p<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)res=res*mat[i][i];</span><br><span class="line">    <span class="keyword">return</span> res.x1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> m,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u[i],&amp;v[i],&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(!(w[j]%i))</span><br><span class="line">            &#123;</span><br><span class="line">                mat[u[j]][v[j]]=mat[u[j]][v[j]]-poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                mat[v[j]][u[j]]=mat[v[j]][u[j]]-poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                mat[u[j]][u[j]]=mat[u[j]][u[j]]+poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                mat[v[j]][v[j]]=mat[v[j]][v[j]]+poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;n)<span class="keyword">continue</span>;</span><br><span class="line">        ans=mod(ans+<span class="number">1l</span>l*det()*phi[i]%p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title>「BJOI2020」封印</title>
    <url>/2020/06/28/%E3%80%8CBJOI2020%E3%80%8D%E5%B0%81%E5%8D%B0/</url>
    <content><![CDATA[<p>给出只包含小写字母 <span class="math inline">\(a,b\)</span> 的字符串 <span class="math inline">\(s,t\)</span>，<span class="math inline">\(q\)</span> 次询问，每次询问 <span class="math inline">\(s[l,r]\)</span> 和 <span class="math inline">\(t\)</span> 的最长公共子串长度。<span class="math inline">\(|s|,|t|,q\leqslant 2\times 10^5\)</span>。</p>
<a id="more"></a>
<p>首先，我们有一个很经典的套路就是用SA或者SAM求出 <span class="math inline">\(s\)</span> 每个位置最多能向前扩展多长，使得这个子串是 <span class="math inline">\(t\)</span> 的子串。</p>
<p>说一下用SAM实现的做法：先把 <span class="math inline">\(t\)</span> 的自动机建出来，然后让 <span class="math inline">\(s\)</span> 在 <span class="math inline">\(t\)</span> 的自动机上匹配。我们设每一位的答案为 <span class="math inline">\(ans_i\)</span> ，再开一个变量 <span class="math inline">\(now\)</span> 表示当前在哪个节点。</p>
<p>我们一位一位添加进 <span class="math inline">\(s\)</span> ，假设本次添加的字符为 <span class="math inline">\(c\)</span>，当 <span class="math inline">\(now\)</span> 有 <span class="math inline">\(c\)</span> 的出边时，让 <span class="math inline">\(ans_i=ans_{i-1}+1\)</span> （注意这里并不是 <span class="math inline">\(len_{now}+1\)</span> ，因为当前匹配上的串不一定是 <span class="math inline">\(now\)</span> 节点代表的最长串），然后 <span class="math inline">\(now=ch[now][c]\)</span>；</p>
<p>如果没有，我们沿着后缀链接向上跳 <span class="math inline">\(fa\)</span> ，直到跳到虚拟节点或者找到了一个有 <span class="math inline">\(c\)</span> 的出边的节点。</p>
<p>如果跳到了虚拟节点，即 <span class="math inline">\(t\)</span> 根本就不含 <span class="math inline">\(c\)</span> 这个字符，那么使 <span class="math inline">\(ans[i]=0,now=0\)</span> （<span class="math inline">\(0\)</span> 为根节点，<span class="math inline">\(-1\)</span> 为虚拟节点）；</p>
<p>如果找到了 <span class="math inline">\(c\)</span> 的出边，则 <span class="math inline">\(ans_i=len_{now}+1,now=ch[now][c]\)</span> （此处的 <span class="math inline">\(now\)</span> 是你跳到的那个点）。这里为什么是 <span class="math inline">\(len_{now}+ 1\)</span> 呢？因为我们是从某一个儿子节点跳到这里的，而儿子节点代表的子串都严格比父节点的子串长，所以只要跳一次开始，就包含了这个节点的所有串。这样的总复杂度是线性的，因为匹配长度最多只增加 <span class="math inline">\(|s|\)</span> 次，所以跳 <span class="math inline">\(fa\)</span> 的总复杂度也是 <span class="math inline">\(O(|s|)\)</span> 的。</p>
<p>现在我们有了 <span class="math inline">\(ans\)</span> 数组，怎么求出真正的答案呢？不难发现答案就是 <span class="math inline">\(\max\limits_{i=l}^r\min(ans_i,i-l+1)\)</span> ，我们把所有位置按取得 <span class="math inline">\(\min\)</span> 的是哪一种分成两类，我们发现随着 <span class="math inline">\(l\)</span> 的增加，会由 <span class="math inline">\(ans_i\)</span> 取得 <span class="math inline">\(\min\)</span> 变为 <span class="math inline">\(i-l+1\)</span> 取得 <span class="math inline">\(\min\)</span> ，而这个位置为 <span class="math inline">\(i-ans_i+1\)</span> ，所以我们可以按 <span class="math inline">\(l\)</span> 离线下来所有询问，开两棵线段树维护两种的答案（单点修改和查询区间 <span class="math inline">\(\max\)</span>），再给每个位置开个桶，把 <span class="math inline">\(k-ans_k+1=i\)</span> 的都扔进去，然后当 <span class="math inline">\(l\)</span> 扫到这个位置就更改就好了。当然你也可以用可持久化线段树来在线处理询问，就是空间多了个 <span class="math inline">\(\log\)</span> ，代码采用的是离线方法。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;c[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query x,query y)</span></span>&#123;<span class="keyword">return</span> x.l&lt;y.l;&#125;</span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="keyword">namespace</span> Suffix_Automaton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">400005</span>][<span class="number">2</span>],len[<span class="number">400005</span>],fa[<span class="number">400005</span>],tot,last,ans[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np=++tot,p=last;</span><br><span class="line">        last=tot,len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;p!=<span class="number">-1</span>&amp;&amp;(!ch[p][c]);p=fa[p])ch[p][c]=np;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)&#123;fa[np]=q;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> nq=++tot;</span><br><span class="line">        ch[nq][<span class="number">0</span>]=ch[q][<span class="number">0</span>],ch[nq][<span class="number">1</span>]=ch[q][<span class="number">1</span>];</span><br><span class="line">        fa[nq]=fa[q];</span><br><span class="line">        len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">        fa[q]=fa[np]=nq;</span><br><span class="line">        <span class="keyword">for</span>(;p!=<span class="number">-1</span>&amp;&amp;ch[p][c]==q;p=fa[p])ch[p][c]=nq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=s[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][c])now=ch[now][c],ans[i+<span class="number">1</span>]=ans[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(now&amp;&amp;(!ch[now][c]))now=fa[now];</span><br><span class="line">                <span class="keyword">if</span>(!ch[now][c])ans[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[i+<span class="number">1</span>]=len[now]+<span class="number">1</span>,now=ch[now][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tree[<span class="number">800005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;tree[x]=b;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)modify(l,mid,x*<span class="number">2</span>,a,b);</span><br><span class="line">        <span class="keyword">else</span> modify(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b);</span><br><span class="line">        tree[x]=max(tree[x*<span class="number">2</span>],tree[x*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=a&amp;&amp;r&lt;=b)<span class="keyword">return</span> tree[x];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)ans=query(l,mid,x*<span class="number">2</span>,a,b);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;mid)ans=max(ans,query(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Suffix_Automaton;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> anss[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> n=s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)extend(t[i]-<span class="string">'a'</span>);</span><br><span class="line">    get_ans();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i-ans[i]+<span class="number">1</span>].push_back(i),t1.modify(<span class="number">1</span>,n,<span class="number">1</span>,i,ans[i]);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c[i].l,&amp;c[i].r),c[i].id=i;</span><br><span class="line">    sort(c+<span class="number">1</span>,c+q+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> nowl=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nowl&lt;=c[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v[nowl].size();j++)</span><br><span class="line">                t1.modify(<span class="number">1</span>,n,<span class="number">1</span>,v[nowl][j],<span class="number">0</span>),t2.modify(<span class="number">1</span>,n,<span class="number">1</span>,v[nowl][j],v[nowl][j]);</span><br><span class="line">            nowl++;</span><br><span class="line">        &#125;</span><br><span class="line">        anss[c[i].id]=max(t2.query(<span class="number">1</span>,n,<span class="number">1</span>,c[i].l,c[i].r)-c[i].l+<span class="number">1</span>,t1.query(<span class="number">1</span>,n,<span class="number">1</span>,c[i].l,c[i].r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>后缀数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round &amp;#35;652 (Div. 2)简要题解</title>
    <url>/2020/06/27/Codeforces%20Round%20652(Div.%202)/</url>
    <content><![CDATA[<h3 id="a.-fashionablee">A. <a href="https://codeforces.com/contest/1369/problem/A" target="_blank" rel="noopener">FashionabLee</a></h3>
<p>问是否可以通过旋转使得在平面直角坐标系中的正 <span class="math inline">\(n\)</span> 边形同时有至少一条边与 X 轴平行，有至少一条边与 Y 轴平行。</p>
<a id="more"></a>
<p>显然，当且仅当 <span class="math inline">\(n\bmod 4=0\)</span> 时有解，因为通过轴对称性可知可以被分为全等的四份（我一开始没看清题WA了一次/dk）</p>
<p>提交记录：<a href="https://codeforces.com/problemset/submission/1369/84757021" target="_blank" rel="noopener">#84757021</a></p>
<h3 id="b.-accuratelee">B. <a href="https://codeforces.com/contest/1369/problem/B" target="_blank" rel="noopener">AccurateLee</a></h3>
<p>给定一个01串 <span class="math inline">\(s\)</span> ，如果 <span class="math inline">\(s_i=1\)</span> 且 <span class="math inline">\(s_{i+1}=0\)</span> 那么可以选择这两个数中的一个删除，然后后面的串向前补全。问这个串经过若干操作后最短的长度是多少，如果有多个最短的，输出字典序最小的。</p>
<p>我们考虑 <span class="math inline">\(1...0...1... 0\)</span> 这样的串，我们可以把它消到只剩下一个 <span class="math inline">\(0\)</span> （先用每个0前面的1消掉0，留下最后一个0消掉前面的所有1）。</p>
<p>对于含有前缀0和后缀1的情况，显然它们都不能被消去，所以最后答案为 前缀0的个数+[除去前缀0和后缀1后不是空串] 个0 和 后缀1的个数 个1。</p>
<p>提交记录：<a href="https://codeforces.com/problemset/submission/1369/84770401" target="_blank" rel="noopener">#84770401</a></p>
<h3 id="c.-rationallee">C. <a href="https://codeforces.com/contest/1369/problem/C" target="_blank" rel="noopener">RationalLee</a></h3>
<p>给定 <span class="math inline">\(n\)</span> 个元素，<span class="math inline">\(k\)</span> 个集合，你需要把每个元素恰好放在一个集合内。第 <span class="math inline">\(i\)</span> 个集合需要放进恰好 <span class="math inline">\(w_i\)</span> 个元素，第 <span class="math inline">\(j\)</span> 个元素的价值为 <span class="math inline">\(a_j\)</span> ，每个集合的价值为它包含的元素的价值的最大值和最小值之和（如果只有一个元素计算两次），求所有集合的价值之和的最大值。<span class="math inline">\(k\leqslant n\leqslant 2\times 10^5\)</span>。</p>
<p>考虑贪心，如果我们有 <span class="math inline">\(w=1\)</span> 的集合，那么一定优先把最大的元素放到这种集合里。我们把元素按价值从大到小排序，把集合按大小从小到大排序，那么首先往第 <span class="math inline">\(i\)</span> 个集合内放入第 <span class="math inline">\(i\)</span> 个元素，然后贪心把价值小的元素放入大的集合中（比如说剩下的元素为 <span class="math inline">\(5,3,1\)</span> 集合大小为 <span class="math inline">\(2,1\)</span>，那么就分成 <span class="math inline">\(\{3,1\},\{5\}\)</span> ，这样就是答案。</p>
<p>提交记录：<a href="https://codeforces.com/problemset/submission/1369/84777478" target="_blank" rel="noopener">#84777478</a></p>
<h3 id="d.-tediouslee">D. <a href="https://codeforces.com/contest/1369/problem/D" target="_blank" rel="noopener">TediousLee</a></h3>
<p>给定一种有根树的构造方式，版本1为一个单独的节点，对于版本 <span class="math inline">\(i\)</span> ，我们从版本 <span class="math inline">\(i-1\)</span> 递推：对于版本 <span class="math inline">\(i-1\)</span> 的每个节点，如果它没有儿子，那么长出一个儿子；如果有一个儿子，那么再长出两个新的儿子；如果有三个儿子，那么不变。</p>
<p>现在给定版本 <span class="math inline">\(n\)</span> 的树，每个节点一开始都是绿色，如果一个节点有三个儿子，且它们和这个节点本身都是绿色，那么可以把这四个点染成黄色，问最多能染出多少黄色的节点，答案 <span class="math inline">\(\bmod 10^9+7\)</span>。<span class="math inline">\(n\leqslant2\times 10^6\)</span>。</p>
<p>我们发现对于版本 <span class="math inline">\(i(i\geqslant3)\)</span> ，它实际上由一个根接上两个版本 <span class="math inline">\(i-2\)</span> 的树再接上一个版本 <span class="math inline">\(i-1\)</span> 的树构成，那么我们可以考虑递推。发现这实际上在求一个类似最大独立集的东西，设 <span class="math inline">\(f[n][0/1]\)</span> 为版本 <span class="math inline">\(n\)</span> ，是否染了根节点的色的答案，那么对于 <span class="math inline">\(n\geqslant 3\)</span> 则有 <span class="math display">\[
\left\{
\begin{aligned}
&amp;f[n][0]=2*\max(f[n-2][0],f[n-2][1])+\max(f[n-1][0],f[n-1][1])\\
&amp;f[n][1]=2*f[n-2][0]+f[n-1][0]+4
\end{aligned}
\right.
\]</span> 这个东西在取模意义下是会WA的，因为取模后的 <span class="math inline">\(\max\)</span> 不一定是取模前的 <span class="math inline">\(\max\)</span> ，但是如果你直接这样交上去是会AC的，因为 <span class="math inline">\(f[n][0]\)</span> 和 <span class="math inline">\(f[n][1]\)</span> 的差实际上很小，在 <span class="math inline">\(n\leqslant 2\times 10^6\)</span> 的情况下不会出现两个数取模次数不一样的情况。</p>
<p>考虑能不能不用 <span class="math inline">\(\max\)</span> 来做，我们设 <span class="math inline">\(f_n\)</span> 表示 <span class="math inline">\(n\)</span> 的答案，<span class="math inline">\(r_i\)</span> 表示是否可以在不染根节点的情况下让答案达到 <span class="math inline">\(f_n\)</span> （对应到我们刚才的想法就是若 <span class="math inline">\(f[n][0]\geqslant f[n][1]\)</span> 则 <span class="math inline">\(r_n=1\)</span>），那么有 <span class="math inline">\(r_0=r_1=1\)</span> ，我们发现当 <span class="math inline">\(r_{n-1}=r_{n-2}=1\)</span> 时，我们可以把根节点染色，这时候染色的答案是不染色的答案+4，所以此时 <span class="math inline">\(r_n=0\)</span> ，其他时刻如果我们强制染根节点，最多只会让答案+4，但是子树的答案至少少了4，所以不优，这时 <span class="math inline">\(r_n=1\)</span>。简单归纳就知道当且仅当 <span class="math inline">\(n\bmod 3=0\)</span> 时 <span class="math inline">\(r_n=0\)</span> ，所以有 <span class="math inline">\(f_n=f_{n-1}+2*f_{n-2}+4[n\bmod 3=0]\)</span> ，这样就避免了同时取模和取 <span class="math inline">\(\max\)</span> ，然后这题也可以用矩阵快速幂或者其他方法加速到 <span class="math inline">\(n=10^{18}\)</span>。</p>
<p>提交记录（第一种方法）：<a href="https://codeforces.com/problemset/submission/1369/84785701" target="_blank" rel="noopener">#84785701</a></p>
<h3 id="e.-deadlee">E. <a href="https://codeforces.com/contest/1369/problem/E" target="_blank" rel="noopener">DeadLee</a></h3>
<p>你有 <span class="math inline">\(n\)</span> 种菜和 <span class="math inline">\(m\)</span> 个朋友。每种菜有 <span class="math inline">\(w_i\)</span> 份，每个朋友有两种喜欢的菜（不会相同）。你需要安排朋友来的顺序，每个朋友来了会吃掉他喜欢的菜各一份（如果某一种没有就不吃那一种），问是否有一种顺序使得每个朋友都能吃到至少一种他喜欢的菜，有的话输出任意一种方案。<span class="math inline">\(n,m\leqslant 2\times 10^5\)</span>。</p>
<p>我们把菜看成点，对每个朋友喜欢的两种菜之间连上一条边，设每个点的度数为 <span class="math inline">\(d_i\)</span>，即喜欢吃这种菜的朋友的个数。</p>
<p>首先，我们发现如果 <span class="math inline">\(\forall i,d_i&gt;w_i\)</span> 则无解（证明待补），如果 <span class="math inline">\(\exist i,w_i\geqslant d_i\)</span> ，那么对于所有与 <span class="math inline">\(i\)</span> 相连的边都可以吃 <span class="math inline">\(i\)</span> ，我们把这些边放到栈中，并且将与这些边相连的点的 <span class="math inline">\(d\)</span> 都减去1（重边减去多次）。重复这个步骤如果最终所有边都被访过那么就合法，这时从栈顶一个一个输出就是答案。</p>
<p>提交记录：<a href="https://codeforces.com/contest/1369/submission/84807161" target="_blank" rel="noopener">#84807161</a></p>
<h3 id="f.-barelee">F. <a href="https://codeforces.com/contest/1369/problem/F" target="_blank" rel="noopener">BareLee</a></h3>
<p>鸽了。</p>
]]></content>
      <tags>
        <tag>套题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>HEOI2020 退役记</title>
    <url>/2020/06/21/HEOI2020%20%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="写在之前">写在之前</h4>
<p>说起来这次省选真是命运多舛/kk ，反复横跳/kk。举行地点从燕大变成了二中，又说取消了，结果在家长的请（堵）求（门）下又复活了，举行地点又从SX变成了HA又变回了二中，真是奇幻。</p>
<a id="more"></a>
<h4 id="day1">Day1</h4>
<p>前一天晚上彻底自闭，抱着退役心态去的。8:05 左右就进了考场，坐在对面机房（是的我没有打错我们机房就在比赛机房的对面）比赛的感觉真是奇特。8:29左右瞬间干掉半瓶运动饮料，紧接着发解压密码，似乎是随机生成的。</p>
<p>飞快输了密码然后看题（后排的同学还在听监考读密码我已经看题了/kel），发现T1不吸氧T2,T3吸氧可还行。简单读了一下题开始按顺序做，T1发现求个前缀和后缀和就是个求类似交点的东西，有一个二分+树状数组的做法似乎比较显然然后就新建了文件名为 <code>icefirebf.cpp</code> 的文件准备拿60，花了半个小时码完一遍过样例和大样例，然后造了个maker，一开始没保证 <span class="math inline">\(x_i\not=0\)</span> 结果死循环吓了一跳，结果发现这份代码竟然惊人的快？完全没卡常的情况下过 <span class="math inline">\(n,x=2\times10^6\)</span> 只用了5s，于是果断放弃剩下10分（我考场上都没想那10分结果考后才发现加个离散化就好了）开始卡常，花了大约15分钟全部都是添加的数据要跑3.05s左右（本机是 i5-6400）感觉在ccf少爷机上能过就封题了。</p>
<p>紧接着看T2，先套路把 <span class="math inline">\(f\)</span> 带进去对每个 <span class="math inline">\(k^i\)</span> 算答案。结果发现后面的东西两个幂很像之前斯特林数降幂的方法（寒假就写了两个的学习笔记之一没白写）然后把两个幂都先拆开了，然后发现只用拆一个又把另一个还原回去了。这时最戏剧性的一幕发现了：我推式子的时候忘了乘上 <span class="math inline">\(j!\)</span>，结果写中间代码测试是否正确的时候又多写了 <span class="math inline">\(j!\)</span>，反而对了。后来走下一步后发现答案不对了对着刚才的代码调发现多乘个 <span class="math inline">\(j!\)</span> 就对了，然后就把推的式子上加了个阶乘（考完才发现我在哪一步漏的），剩下就很顺利了，过了大样例直接封题。这个时候还剩大约1小时45分钟，此时心情高涨，又秒干了一罐咖啡，于是开T3结果发现完全不会，彻底自闭，硬磕了一个多小时没有任何进度，任何一个性质或者暴力都不会，最后写了个玄学枚举 <span class="math inline">\(v_i\)</span> 和 <span class="math inline">\(m=1\)</span> （虽然估计没有这样的数据）。然后T1剩下的10分也忘了再看看。</p>
<p>Day1估分：<span class="math inline">\(60\sim 90 + 100 + 0\sim 15\)</span></p>
<h4 id="day2">Day2</h4>
<p>自闭场，T2不会</p>
<p>开局先看三道题结果感觉T2最可做？？？（幸亏最后还是先开的T1）一开始想了半天都没啥头绪，大约1个小时15分钟才想到T1算元素贡献状压，于是就很好写啦，但是我的辅助转移数组是 <span class="math inline">\(O(m2^m)\)</span> 的，<span class="math inline">\(m=23\)</span> 刚刚MLE，只好先开到了22，大概有个优化想法但是看时间不多先去开T2T3了。结果T2爆肝90分钟想dsu on tree和树剖啥都没出来，结果自闭去看T3了，直接写了前三个subtask的暴力应该有50分，最后T2写了一个暴力跳fa和" <code>pushdown</code> 的时候如果儿子有标记就 <code>pushdown</code> 儿子"的神奇树剖写法，结果深度大一点依旧暴毙。最后还剩20分钟想起了还没有优化空间的T1，结果没调出来失败了，自闭了。</p>
<p>Day2估分：<span class="math inline">\(80+10+50\)</span></p>
<p>退役了，下午回到了南校（我们明天就回家上网课），准备文化课，希望明年能考好点/dk 。有几位高二神仙考爆炸了，前两天还热闹的北校机房已经空荡荡了，或许这就是所谓的分别吧。</p>
<h4 id="update-on-2020.6.25">Update on 2020.6.25</h4>
<p>今天名单公示，标准分HE#11，省选分HE#5，蹭进了个B队，还是太菜了，csp被其他人吊打50分起步/kk</p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>CF235D Graph Game</title>
    <url>/2020/06/13/CF235D/</url>
    <content><![CDATA[<p>求基环树随机点分治总遍历次数期望</p>
<a id="more"></a>
<p>基环树随机点分治步骤：</p>
<p>①遍历当前分治区域所有点一次</p>
<p>②在当前分治区域随机选择一个点 <span class="math inline">\(x\)</span></p>
<p>③将 <span class="math inline">\(x\)</span> 删掉，产生的所有连通块递归处理。</p>
<p><span class="math inline">\(n\leqslant 3000\)</span></p>
<p>按照套路，我们先考虑如果是一棵树的情况，再扩展到基环树的情况。不难发现如果我们把分治过程建成点分树，那么我们实际上求的是 <span class="math inline">\(\sum\limits_xsize_x\)</span> 的期望，其中 <span class="math inline">\(size_x\)</span> 是 <span class="math inline">\(x\)</span> 子树的大小。 根据期望的线性性，我们考虑计算点的贡献，每个点会被计算 <span class="math inline">\(deep_x\)</span> 次，那么答案就化为 <span class="math inline">\(\sum\limits_xdeep_x\)</span> ， 再进行一步转化， <span class="math inline">\(deep_x\)</span> 等价于 <span class="math inline">\(\sum_\limits y[y是x的祖先]\)</span> （当 <span class="math inline">\(x=y\)</span> 时也成立） 。我们可以画图发现，点对 <span class="math inline">\((x,y)\)</span> 会产生贡献当且仅当 <span class="math inline">\(y\)</span> 被选中时 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在一个连通块内，也就是 <span class="math inline">\(y\)</span> 是在原树中 <span class="math inline">\(x\rightarrow y\)</span> 路径（包括端点）上第一个被选中的点，举个例子</p>
<p><img src="/2020/06/13/CF235D/1.png"></p>
<p>我们现在考虑 <span class="math inline">\((3,1)\)</span> 的贡献，如果我们按照 <span class="math inline">\(1,2,3\)</span> 或 <span class="math inline">\(1,3,2\)</span> 的顺序，那么1就是3的祖先，会产生贡献，而如果是 <span class="math inline">\(2,1,3\)</span> <span class="math inline">\(2,3,1\)</span> <span class="math inline">\(3,1,2\)</span> <span class="math inline">\(3,2,1\)</span> 就都不会产生贡献（点对是有序的）。</p>
<p>显然，这个的概率是 <span class="math inline">\(\frac{1}{dis(x,y)}\)</span> 所以答案就是 <span class="math inline">\(\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac{1}{dis(i,j)}\)</span> 。</p>
<p>接下来我们把树上的做法扩展到基环树上，我们仍旧考虑点对对答案的贡献，分类讨论一下：</p>
<ul>
<li>当 <span class="math inline">\(x,y\)</span> 在同一棵树内，概率仍为 <span class="math inline">\(\frac{1}{dis(x,y)}\)</span></li>
<li>当路径 <span class="math inline">\(x\rightarrow y\)</span> 经过环上的点时，有两种情况可以造成贡献，分别是直接删掉 <span class="math inline">\(y\)</span> 或者先删掉环上的某一个点再删掉 <span class="math inline">\(y\)</span> ，如图</li>
</ul>
<p><img src="/2020/06/13/CF235D/2.png"></p>
<p>我们考虑点对 <span class="math inline">\((1,7)\)</span> 设两个点到对应的树根的距离之和为 <span class="math inline">\(a\)</span> （蓝色区域），两个点对应的树根将环切为两条链，链长为 <span class="math inline">\(b,c\)</span> （绿色区域和黄色区域）。那么直接删掉 <span class="math inline">\(y\)</span> 的概率为 <span class="math inline">\(\frac{1}{a+b+c}\)</span> ，先切掉绿色区域后，剩余的绿色区域就已经不在 <span class="math inline">\(x\rightarrow y\)</span> 这条路径上了，不会对后面造成影响 ，所以我们不需要管剩余的绿色区域，只需要看 <span class="math inline">\(y\)</span> 是否是蓝色+黄色区域中第一个被切掉的点，这样总概率为 <span class="math inline">\(\frac{b}{a+b+c} \cdot \frac{1}{a+c}\)</span> 。类似，先切掉黄色，再切掉 <span class="math inline">\(y\)</span> 的概率为 <span class="math inline">\(\frac{c}{a+b+c}\cdot \frac{1}{a+b}\)</span> 。</p>
<p>所以总概率为 <span class="math inline">\(\frac{1}{a+b+c}(1+\frac{b}{a+c}+\frac{c}{a+b})\)</span> 。实现上我们只需要找到环然后暴力枚举计算答案就可以了。还需要写一个lca，代码中用倍增实现，所以复杂度为 <span class="math inline">\(O(n^2\log n)\)</span></p>
<h5 id="code">code:</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">6005</span>],pre[<span class="number">6005</span>],last[<span class="number">3005</span>],tot,fa[<span class="number">3005</span>],belong[<span class="number">3005</span>],</span><br><span class="line">deep[<span class="number">3005</span>],f[<span class="number">3005</span>][<span class="number">12</span>],index[<span class="number">3005</span>];</span><br><span class="line"><span class="keyword">bool</span> cir[<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target[++tot]=y;</span><br><span class="line">    pre[tot]=last[x];</span><br><span class="line">    last[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cir[x])&#123;index[x]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(tar,x);</span><br><span class="line">        <span class="keyword">if</span>(cir[tar])cir[x]=<span class="number">1</span>,index[x]=index[tar]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deep[x]=deep[fa]+<span class="number">1</span>;belong[x]=z;</span><br><span class="line">    f[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa||cir[tar])<span class="keyword">continue</span>;</span><br><span class="line">        dfs2(tar,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&lt;deep[y])swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">11</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(deep[f[x][k]]&gt;=deep[y])x=f[x][k];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">11</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(f[x][k]!=f[y][k])x=f[x][k],y=f[y][k];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y,len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        x++,y++;</span><br><span class="line">        <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)fa[fx]=fy;</span><br><span class="line">        <span class="keyword">else</span> cir[y]=<span class="number">1</span>,dfs(x,<span class="number">0</span>),len=index[x];</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(cir[i])dfs2(i,<span class="number">0</span>,i); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">11</span>;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i][k]=f[f[i][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(belong[i]==belong[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=lca(i,j);</span><br><span class="line">                ans+=<span class="number">1.0</span>/(deep[i]+deep[j]<span class="number">-2</span>*deep[l]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a=deep[i]+deep[j],b=<span class="built_in">abs</span>(index[belong[i]]-index[belong[j]])<span class="number">-1</span>,c=len-b<span class="number">-2</span>;</span><br><span class="line">                ans+=<span class="number">1.0</span>/(a+b+c)*(<span class="number">1</span>+<span class="number">1.0</span>*b/(a+c)+<span class="number">1.0</span>*c/(a+b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>概率论</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT学习笔记</title>
    <url>/2020/01/29/fwt/</url>
    <content><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>给定长度为 <span class="math inline">\(2^n\)</span> 两个序列 <span class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>，设 <span class="math display">\[
C_i=\sum_{j\oplus k = i}A_j \times B_k
\]</span></p>
<p>分别当<span class="math inline">\(\oplus\)</span>是<span class="math inline">\(\text{or}\)</span>,<span class="math inline">\(\text{and}\)</span>和<span class="math inline">\(\text{xor}\)</span>时求出<span class="math inline">\(C\)</span></p>
<a id="more"></a>
<h3 id="什么是fwt">什么是FWT</h3>
<p>FWT（快速沃尔什变换）是一种类似FFT的优化卷积运算的算法，只不过卷积时下标由<span class="math inline">\(+\)</span>变成了位运算。类似FFT，我们需要找到一种变换方式，设<span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>为原序列，<span class="math inline">\(FWT(A)\)</span>，<span class="math inline">\(FWT(B)\)</span>变换后的序列，<span class="math inline">\(\otimes\)</span>为卷积运算，<span class="math inline">\(*\)</span>为对应下标相乘的运算，使得 <span class="math display">\[
FWT(A\otimes B)=FWTA*FWTB
\]</span> （想想FFT，通过变换为点值表达使得卷积运算可以变为对应下标相乘，两者实际上思想一样！）</p>
<p>接下来说一下如何实现</p>
<h4 id="or">OR</h4>
<p>设<span class="math inline">\(A\)</span>为原序列，<span class="math inline">\(FWT_A\)</span>为变换后序列，则有 <span class="math display">\[
FWT_A[i]=\sum\limits_{i|j=i}A[j]
\]</span> 考虑为什么是对的，我们考虑两个变换后的数组按位相乘后的结果 <span class="math display">\[
FWT_A[i]*FWT_B[i]=(\sum\limits_{i|j=i}A[j])*(\sum\limits_{i|k=i}B[k])\\
=\sum\limits_{i|(j|k)=i}A[j]*B[k]
\]</span> 这正是<span class="math inline">\(FWT_{A*B}\)</span>！</p>
<p>但是不能直接这么求，像FFT，我们是否可以把原序列分为两半，通过子问题的解合并出问题的解呢？是可以的，下面给出式子 <span class="math display">\[
FWT_A=
\begin{cases}
A &amp;     &amp;|A|=1\\
merge(FWT_{A_0},FWT_{A_0}+FWT_{A_1})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span></p>
<p>其中，<span class="math inline">\(merge\)</span>为把两个序列拼接起来（左面的序列拼合完成后下标较小），<span class="math inline">\(A_0\)</span>，<span class="math inline">\(A_1\)</span>分别为序列的前半部分（下标较小的部分）和后半部分，<span class="math inline">\(+\)</span>为对应下标的值相加。</p>
<p>考虑正确性，当<span class="math inline">\(|A|=1\)</span>时，显然只有这一个元素，当<span class="math inline">\(|A|\not =1\)</span>时，我们按下标的最高位分为<span class="math inline">\(0\)</span>与<span class="math inline">\(1\)</span>两部分，递归处理左右两边，再考虑这一位的影响，因为只有<span class="math inline">\(0|0=0\)</span>，所以<span class="math inline">\(0\)</span>只有自己的贡献，而<span class="math inline">\(0|1=1,1|1=1\)</span>，所以<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>都有贡献。</p>
<p>或者换种想法，最初定义<span class="math inline">\(FWT\)</span>的式子，如果我们把下标看作集合的状压表示，那么<span class="math inline">\(FWT_A[i]\)</span>实际上是<span class="math inline">\(i\)</span>所有子集对应值的和，我们按位相加时，保证除了最高位，其他低位都是相等的（低位的子集已经递归算过），所以我们只关注最高位，而这一位下标为0或者为1都是这一位为1的子集，所以右边是左右相加，而左边只有0是0的子集，所以只有左边一半。</p>
<p>接下来考虑逆变换，也就是把<span class="math inline">\(FWT\)</span>序列还原为原序列。其实很简单，就是解方程，下面直接给出式子，不做解释 <span class="math display">\[
IFWT_A=
\begin{cases}
FWT_A &amp;     &amp;|A|=1\\
merge(IFWT{A_0},IFWT{A_1}-IFWT{A_0})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span> 然后对于整个序列，<span class="math inline">\(IFWT_A\)</span>就是它自己了</p>
<p>下面是<span class="math inline">\(or\)</span>的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">1</span>)f[j+(len&gt;&gt;<span class="number">1</span>)]+=f[j],f[j+(len&gt;&gt;<span class="number">1</span>)]%=p;</span><br><span class="line">                <span class="keyword">else</span> f[j+(len&gt;&gt;<span class="number">1</span>)]+=(p-f[j]),f[j+(len&gt;&gt;<span class="number">1</span>)]%=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(p\)</span>是板子题的模数，op==1时是正变换，其它时为逆变换，采用像FFT一样的迭代实现</p>
<h4 id="and">AND</h4>
<p>and操作和or操作类似，下面只给出式子和代码 <span class="math display">\[
FWT_A[i]=\sum\limits_{i\&amp;j=i}A[j]
\]</span> <span class="math display">\[
FWT_A=
\begin{cases}
A &amp;     &amp;|A|=1\\
merge(FWT_{A_0+A_1},FWT_{A_0})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtand</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">1</span>)f[j]+=f[j+(len&gt;&gt;<span class="number">1</span>)],f[j]%=p;</span><br><span class="line">                <span class="keyword">else</span> f[j]+=(p-f[j+(len&gt;&gt;<span class="number">1</span>)]),f[j]%=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xor">XOR</h4>
]]></content>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2015」地震后的幻想乡</title>
    <url>/2020/01/21/%E3%80%8CZJOI2015%E3%80%8D%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
    <content><![CDATA[<p>给定一张无向图，边权在<span class="math inline">\([0,1]\)</span>之间随机均匀分布，求这张图的最小生成树边权最大值的期望。</p>
<a id="more"></a>
<p><span class="math inline">\(1\leqslant n\leqslant 10\)</span>，<span class="math inline">\(1\leqslant m\leqslant \frac{n(n-1)}{2}\)</span>（分别是点数与边数）</p>
<p>提示：对于<span class="math inline">\(n\)</span>个<span class="math inline">\([0,1]\)</span>之间的随机变量<span class="math inline">\(x1\)</span>,<span class="math inline">\(x2\)</span>,...,<span class="math inline">\(xn\)</span>，第<span class="math inline">\(k\)</span>小的那个的期望值是<span class="math inline">\(\frac{k}{n+1}\)</span>。</p>
<p>如果我们按照边权从小到大加入边，那么最下生成树边权的最大值也就是加入某一条边使得图恰好联通的那条边的权值。于是我们只需计算这张图是从小到大加了第<span class="math inline">\(i\)</span>条边后恰好联通的概率，记为<span class="math inline">\(P[i]\)</span>，则 <span class="math display">\[
ans=\sum\limits_{i=1}^{m}P[i]E[i]
\]</span> 其中<span class="math inline">\(E[i]\)</span>是这条边的边权期望，由提示我们知道<span class="math inline">\(E[i]=\frac{i}{m+1}\)</span>，那么 <span class="math display">\[
ans=\frac{1}{m+1}\sum\limits_{i=1}^m iP[i]\\
=\frac{1}{m+1}\sum\limits_{i=1}^m\sum\limits_{j=i}^mP[j]
\]</span> 我们设<span class="math inline">\(p[i]=\sum\limits_{j=i}^mP[j]\)</span>那么<span class="math inline">\(ans=\frac{1}{m+1}\sum\limits_{i=1}^m p[i]\)</span>，而<span class="math inline">\(p[i]\)</span>的意义是加入至少<span class="math inline">\(i\)</span>条边才联通的概率，这显然比<span class="math inline">\(P\)</span> 要好计算！</p>
<p>我们考虑如何计算<span class="math inline">\(p\)</span>，不难发现这等价于加了<span class="math inline">\(i-1\)</span>条边还没有联通的概率，可以用不连通方案数除以总方案数来计算概率。于是我们成功的把一个期望问题转化为了计数问题！</p>
<p>考虑状压计算方案，设<span class="math inline">\(f[i][s]\)</span>和<span class="math inline">\(g[i][s]\)</span>为当前点集为<span class="math inline">\(s\)</span>，内部连了<span class="math inline">\(i\)</span>条边，联通/不连通的方案数，那么有 <span class="math display">\[
f[i][s]+g[i][s]=\binom{size[s]}{i}\\
f[i][s]=\sum\limits_{j=0}^{i-1}\sum\limits_{t\subsetneqq s且r\in t}g[j][t]*\binom{size[s-t]}{i-j}
\]</span> 第一条，不连通+联通=总方案数，其中<span class="math inline">\(size[s]\)</span>为子图<span class="math inline">\(s\)</span>中的边数</p>
<p>第二条，<span class="math inline">\(r\)</span>是<span class="math inline">\(s\)</span>中的第一个点（其实可以是任何一个但是在枚举<span class="math inline">\(j\)</span>和<span class="math inline">\(t\)</span>中不能变），这样的话通过枚举这个点所在的连通块大小，可以不重不漏计算出所有不连通图的数量（连通图计数貌似有很多类似的trick，可惜我并没做过）</p>
<p>最后答案式子就不列了，直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">int</span> ss[<span class="number">46</span>],tt[<span class="number">46</span>],cnt[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line">ll f[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">46</span>],g[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">46</span>],c[<span class="number">46</span>][<span class="number">46</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ss[i],&amp;tt[i]),ss[i]--,tt[i]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;ss[j]))&amp;&amp;(i&amp;(<span class="number">1</span>&lt;&lt;tt[j])))cnt[i]++;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">45</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==(s&amp;(-s)))&#123;g[s][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> lowbit=(s&amp;(-s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=s&amp;(s<span class="number">-1</span>);t;t=s&amp;(t<span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(t&amp;lowbit))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[t];i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt[s^t];j++)</span><br><span class="line">                    f[s][i+j]+=g[t][i]*c[cnt[s^t]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[s];i++)g[s][i]=c[cnt[s]][i]-f[s][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)ans+=<span class="number">1.0</span>*f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]/c[cnt[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6Lf"</span>,ans/(m+<span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里更新方式和上面长得不太一样，但实际上是一个东西。复杂度为<span class="math inline">\(O(3^nm)\)</span></p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>K-Dtree学习笔记</title>
    <url>/2020/01/17/KDtree/</url>
    <content><![CDATA[<h3 id="什么是k-dtree">什么是K-Dtree</h3>
<blockquote>
<p>在计算机科学里，<strong>k-d树</strong>（ <strong>k-维树</strong>的缩写）是在<strong>k</strong>维欧几里德空间组织点的数据1结构。<strong>k-d</strong>树可以使用在多种应用场合，如多维键值搜索（例：范围搜寻及最邻近搜索）。<strong>k-d树</strong>是空间二分树（Binary space partitioning ）的一种特殊情况。</p>
</blockquote>
<a id="more"></a>
<hr>
<h3 id="如何构造k-dtree">如何构造K-Dtree</h3>
<h4 id="节点存储">节点存储</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,minx,miny,maxx,maxy;</span><br><span class="line">    node *ch[<span class="number">2</span>];</span><br><span class="line">    node (point a)</span><br><span class="line">    &#123;</span><br><span class="line">        x=minx=maxx=a.x;</span><br><span class="line">        y=miny=maxy=a.y;</span><br><span class="line">        ch[<span class="number">0</span>]=ch[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br></pre></td></tr></table></figure>
<p>可以看到代码是<strong>2-Dtree</strong>，没有使用一个数组存放每个维度的位置而是直接开了<strong>x</strong>和<strong>y</strong>两个变量。<strong>minx</strong>,<strong>miny</strong>,<strong>maxx</strong>,<strong>maxy</strong>存放了以这个节点为根的树中的点的覆盖范围，当维数增大时依然可以使用数组存放更加方便。<strong>ch[2]</strong>是儿子，这里使用了指针，也可使用数组。</p>
<h4 id="build函数">build函数</h4>
<p>参考当<span class="math inline">\(k=2\)</span>时的特殊数据结构——二叉查找树的构造方法，确定一个当前要排序的维度，对所有的数据以这一维排序，并递归到两边的数据继续这样的操作，直到只有一个点直接 return 。</p>
<p>如何确定当前划分维度？有三种方法：按顺序一维一维划分，rand()和按每维度方差。三种方法各有各的好处。</p>
<p>以下是一个rand划分的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dim)</span><span class="comment">//l和r为划分的点在序列中的位置，dim为当前划分的维度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        node* t=<span class="keyword">new</span> node(p[l]);<span class="comment">//这个点自己的信息</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    nth_element(p+l,p+mid,p+r,dim?cmpy:cmpx);<span class="comment">//找到区间内这一维的中位数，小于中位数的在左边，大于的在右边</span></span><br><span class="line">    node *t=<span class="keyword">new</span> node(p[mid]);</span><br><span class="line">    <span class="keyword">int</span> nxt=rand()%<span class="number">2</span>;<span class="comment">//rand划分</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;mid)t-&gt;ch[<span class="number">0</span>]=build(l,mid<span class="number">-1</span>,nxt);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)t-&gt;ch[<span class="number">1</span>]=build(mid+<span class="number">1</span>,r,nxt);</span><br><span class="line">    pushup(t);<span class="comment">//更新minx等数据</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造好的<strong>K-Dtree</strong>大概长这个样子：</p>
<p>待更新qwq</p>
]]></content>
      <tags>
        <tag>K-Dtree</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2014」力</title>
    <url>/2019/12/29/%E3%80%8CZJOI2014%E3%80%8D%E5%8A%9B/</url>
    <content><![CDATA[<p>给出n个数<span class="math inline">\(q_i\)</span>，给出<span class="math inline">\(F_j\)</span>的定义如下： <span class="math display">\[
F_j = \sum_{i&lt;j}\frac{q_i q_j}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i q_j}{(i-j)^2 }
\]</span></p>
<p>令<span class="math inline">\(E_i=\frac{F_i}{q_i}\)</span>，求<span class="math inline">\(E_i\)</span></p>
<a id="more"></a>
<p><span class="math display">\[
E_j=\sum_{i&lt;j}\frac{q_i}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i}{(i-j)^2 }
\]</span></p>
<p>设<span class="math inline">\(f[i]=q[i],g[i]=\frac{1}{i^2}\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i&lt;j}f[i]g[j-i]-\sum\limits_{i&gt;j}f[i]g[i-j]\\
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=j+1}^nf[i]g[i-j]
\]</span> 设<span class="math inline">\(f&#39;[i]=f[n-i+1]\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=1}^{n-j}f&#39;[i]g[j-i]
\]</span> 直接卷积就好</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> +(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r+y.r,x.i+y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> -(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r-y.r,x.i-y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> *(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r&#125;;&#125;</span><br><span class="line">&#125;q[<span class="number">400005</span>],qq[<span class="number">400005</span>],f[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp* f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        comp wn=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*pi/len),op*<span class="built_in">sin</span>(<span class="number">2</span>*pi/len)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            comp w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                comp d=f[j+q]*w;</span><br><span class="line">                f[j+q]=f[j]-d;</span><br><span class="line">                f[j]=f[j]+d;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;q[i].r),qq[n-i+<span class="number">1</span>].r=q[i].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i].r=(((<span class="keyword">double</span>)<span class="number">1.0</span>)/(<span class="keyword">double</span>)i/(<span class="keyword">double</span>)i);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    getrev(len);</span><br><span class="line">    fft(q,len,<span class="number">1</span>),fft(qq,len,<span class="number">1</span>),fft(f,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)q[i]=q[i]*f[i],qq[i]=qq[i]*f[i];</span><br><span class="line">    fft(q,len,<span class="number">-1</span>),fft(qq,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>,(q[i].r-qq[n-i+<span class="number">1</span>].r)/len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>csp2019游记</title>
    <url>/2019/12/29/csp2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>咕咕咕了一个多月的游记qwq</p>
<a id="more"></a>
<h3 id="day-8">Day-8</h3>
<p>期中考完了开始快乐的停课生活qwq</p>
<h3 id="day0">Day0</h3>
<p>如果没有记错的话下午到了秦皇岛，试完机后就去酒店放行李（其实就两个包），晚上和同机房的同学们一起去吃了酸菜鱼（味道还不错qwq），本来还想吃冰激淋的可是想到去年noip的惨痛经历就忍住了没吃。回到酒店开始颓Terraria。晚上本来和我一个房间的AlanSP去找家长住了，第一次一个人睡双人间。自我感觉良好。</p>
<h3 id="day1">Day1</h3>
<p>不喜欢吃酒店的早餐，简单吃了点找别人借了本李煜东看了会exgcd和exbsgs，然后就去燕大了。</p>
<p>到考场上丝毫不慌，反正我退役稳了，然后就一直盯着前面的表看时间。</p>
<p>终于开考了，一遍输对了密码（据说有人输了三遍才对）。先看一遍题，感觉不是很难的样子，于是就以正常顺序开题。T1不是**题嘛，花5分钟写好结果大样例过不去，调了10分钟才发现写的是1而不是1ull，在此之前还发现输出锅了，还好我记得 <code>unsigned long long</code> 输出是 <code>%llu</code> （其实也可以用cout的）。大概在开考后30分钟过了大样例然后造了一下64 2^64-1没有问题就封题了。</p>
<p>T2第一眼看眼前一亮，前两天模拟赛不是考过合法括号序列嘛，所以”很快“的码完了，但中间 windows 下爆栈了，不慌不忙开了虚拟机，果然在 linux 下就没啥问题，顺便也把T1又测了一下，过了114514后就封题了（我考场上竟然没看出来114514）。</p>
<p>还有将近两个小时，我过不了T3，这个T3长得这么水，我要是过不了，我当场！就把这个电脑屏幕吃掉！</p>
<p>1 hour left：woc我觉得不行，先把10分暴力打了，看看能不能把链和菊花图做了</p>
<p>45 mins left：我想到链怎么做了！开始码！</p>
<p>20 mins left： woc怎么一直RE，dev的调试功能是什么毒瘤（我之前看了gdb怎么用但是考场上一慌就忘了）。</p>
<p>10 mins left： 标准结局，自闭了。封题检查文件。</p>
<p>出考场问了问其他人，大概都是100+100+10？感觉是个大众分鸭，今年说不定能上400呢。</p>
<p>颓了一下午和一晚上，我昨天跟AlanSP说要打过亵渎天神，晚上又是我一个人睡的，不知道为什么感觉走廊有人走路，有点吓人。</p>
<h3 id="day2">Day2</h3>
<p>自闭日。</p>
<p>先看了一遍题，感觉T1最不可做？？？（出考场后发现读题出锅了）然后T3 送了40分就先码完了40。接着自闭了一个小时来回看三道题都觉得不可做。大概还剩1个小时10分钟想了下并码了T2的 <span class="math inline">\(n^3\)</span>，发现可以二分转移就优化到了<span class="math inline">\(n^2\log n\)</span>，这个时候大概还剩25分钟，赶紧码了T1爆搜结果样例2过不去？？？调了10分钟没出来，然后就彻底自闭了。最后还剩下5分钟只得放弃，开始建文件夹。</p>
<p>出了考场发现其他人都比我高（，自闭了，Eta估分100+64+55，jiqimao神仙切了两道，然后就在遗憾中回了学校。</p>
<p>估分100+100+10+0+64+40</p>
<p>最后得分100+80+10+8+64+40，D1T2没来longlong见祖宗/(ㄒoㄒ)/~~，差了8分进WC，还好我这种菜鸡进了也是爆零，也没有太大遗憾。jiqimao神仙HE rank2 orz。</p>
<p>感觉这次败在了D2T1上，要多做做DP了（</p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>bsgs</title>
    <url>/2019/12/26/bsgs-exbsgs/</url>
    <content><![CDATA[<h3 id="bsgs">BSGS</h3>
<p>求<span class="math inline">\(a^x\equiv b\space( \mod p)\)</span> 的解，保证<span class="math inline">\(gcd(a,p)=1\)</span>。</p>
<a id="more"></a>
<p>我们设<span class="math inline">\(x=i*m-j\)</span> ，其中<span class="math inline">\(0\leqslant j &lt;m\)</span> 。那么原式可转化为<span class="math inline">\(a^{im}\equiv b*a^j\pmod p\)</span>的解。我们预处理出<span class="math inline">\(b*a^0,b*a^1,...,b*a^{m-1}\)</span>的值，将它们存入哈希表中，枚举<span class="math inline">\(i\)</span>的值，每次查看<span class="math inline">\(a^{im}\)</span>在表中是否出现。</p>
<p>由费马小定理可知，等号左边是有循环节<span class="math inline">\(p-1\)</span>的，所以只需要从<span class="math inline">\(1\)</span>到<span class="math inline">\(\frac{p}{m}\)</span>枚举<span class="math inline">\(i\)</span> ，则不包含哈希表的时间复杂度在当<span class="math inline">\(m=\lceil\sqrt{n}\rceil\)</span>时最优，为<span class="math inline">\(O(\sqrt{p})\)</span>，在实际中常使用<code>std::map</code>作为哈希表，时间复杂度为<span class="math inline">\(O(\sqrt p\log_2p)\)</span></p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(ll a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>((<span class="keyword">double</span>)p));</span><br><span class="line">    mp.clear();</span><br><span class="line">    ll now=<span class="number">1</span>,t=pw(a,m,p);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++)mp[b*now%p]=i,now*=a,now%=p;</span><br><span class="line">    now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now*=t,now%=p;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(now))&#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,i*m-mp[now]);<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exbsgs">EXBSGS</h3>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/2019/12/22/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>由于我的多项式板子实现不够精细，所以这篇博客中的文章都没有放代码。建议找一个精细实现的板子，速度会快很多。</p>
<a id="more"></a>
<h4 id="任意模数-ntt">任意模数 NTT</h4>
<p>字面意思。</p>
<p>如果不取模，按 OI 常见数据范围来讲两个多项式相乘以后系数不超过 <span class="math inline">\(10^9\times10^9\times10^5=10^{23}\)</span>，如果我们算出该多项式分别 <span class="math inline">\(\bmod\)</span> 3 个 NTT 模数下的值，我们就可以通过 CRT 合并计算出模三个模数之积的值，而这样最高精度能达到 <span class="math inline">\(10^{26}\)</span> 级别，足够应付。但是这种方法一次多项式乘法需要 9 次 DFT，比较慢。下面介绍一下比较常见的优化拆系数 FFT。</p>
<p>众所周知，FFT 中不用取模，只需要结果取一次模就可以了。但是这题最大的系数达到了 <span class="math inline">\(10^{23}\)</span> 级别，直接 FFT 精度不足。对此我们引出拆系数 FFT。</p>
<p>设 <span class="math inline">\(bas\)</span> 为一个 <span class="math inline">\(\sqrt{p}\)</span> 级别的数，<span class="math inline">\(F(x),G(x)\)</span> 为我们要进行乘法的多项式，那么我们可以把 两个多项式表示成以下形式： <span class="math display">\[
F(x)=basA(x)+B(x)\\
G(x)=basC(x)+D(x)
\]</span> 其中，<span class="math inline">\([x^n]A(x)=\lfloor \frac{[x^n]F(x)}{bas} \rfloor\)</span>，<span class="math inline">\([x^n]B(x)=[x^n]F(x)\bmod bas\)</span>，对于 <span class="math inline">\(C(x),D(x)\)</span> 同理。这样系数就被降低到了 <span class="math inline">\(10^5bas^2\)</span> 的级别。那么有 <span class="math display">\[
\begin{aligned}
F(x)G(x)&amp;=(basA(x)+B(x))(basC(x)+D(x))\\
&amp;=bas^2A(x)C(x)+bas(A(x)D(x)+B(x)C(x))+B(x)D(x)
\end{aligned}
\]</span> 这样先算出 <span class="math inline">\(A(x),B(x),C(x),D(x)\)</span> 的点值表示，然后根据乘的系数不同做三次 IDFT，这样一次多项式乘法一共要做 7 次 FFT。</p>
<p>我们发现 DFT 的时候虚部一开始全为 0，可以通过一些方法利用上这里，减少 DFT 次数。</p>
<p>首先我们要明白 DFT 的本质是 <span class="math inline">\(F(w_n^k)=\sum\limits_{i=0}^nf_iw_n^{ki}\)</span> ，假设我们现在要算出 <span class="math inline">\(A(x)\)</span> 与 <span class="math inline">\(B(x)\)</span> 的点值表示。</p>
<p>如果我们知道了一个数组使得 <span class="math inline">\(F[k]=A(w_n^k)+iB(w_n^k)\)</span>，<span class="math inline">\(G[k]=A(w_n^k)-iB(w_n^k)\)</span>，那么我们可以通过解方程组的方式知道 <span class="math inline">\(A(w_n^k)\)</span> 与 <span class="math inline">\(B(w_n^k)\)</span>。</p>
<p>现在我们尝试推导 <span class="math inline">\(F\)</span> 与 <span class="math inline">\(G\)</span> 的关系，通过 DFT 的定义可以知道： <span class="math display">\[
\begin{aligned}
F[k]&amp;=A(w_n^k)+iB(w_n^k)\\
&amp;=\sum\limits_{j=0}^{n-1}a_iw_n^{kj}+i\sum\limits_{j=0}^nb_jw_n^{kj}\\
&amp;=\sum\limits_{j=0}^{n-1}(a_j+ib_j)w_n^{kj}\\
&amp;=\sum\limits_{j=0}^{n-1}(a_j+ib_j)(\cos(X)+i\sin(X))\\
&amp;=\sum\limits_{j=0}^{n-1}(a_j\cos(X)-b_j\sin(X))+i(b_j\cos(X)+a_j\sin(X))\\
\end{aligned}
\]</span> 其中，<span class="math inline">\(X=\frac{2\pi kj}{n}\)</span>。</p>
<p>同时，我们有 <span class="math display">\[
\begin{aligned}
G[n-k]&amp;=A(w_n^{n-k})-iB(w_n^{n-k})\\
&amp;=A(w_n^{-k})-iB(w_n^{-k})\\
&amp;=\sum\limits_{j=0}^{n-1}a_iw_n^{-kj}-i\sum\limits_{j=0}^nb_jw_n^{-kj}\\
&amp;=\sum\limits_{j=0}^{n-1}(a_j-ib_j)w_n^{-kj}\\
&amp;=\sum\limits_{j=0}^{n-1}(a_j-ib_j)(\cos(X)-i\sin(X))\\
&amp;=\sum\limits_{j=0}^{n-1}(a_j\cos(X)-b_j\sin(X))-i(b_j\cos(X)+a_j\sin(X))\\
\end{aligned}
\]</span> 所以，我们发现 <span class="math inline">\(F[k]\)</span> 与 <span class="math inline">\(G[n-k]\)</span> 是共轭的（<span class="math inline">\(k=0\)</span> 时要特判一下放到 <span class="math inline">\(G[0]\)</span> 去），所以我们只需要计算出 <span class="math inline">\(F\)</span>，就可以 <span class="math inline">\(O(n)\)</span> 计算出 <span class="math inline">\(G\)</span>。这样只需要 2 次 FFT，就可以计算出四个多项式的点值。</p>
<p>然后考虑 IDFT 部分，这里也可以省一次 FFT。我们正常求 IDFT 的时候最后结果全部都在实部（不明白去看单位根反演），那么如果我们在最开始每个点值都乘上 <span class="math inline">\(i\)</span>，那么最后出来的结果应该都在虚部，而且数值和放在实部上相等。我们知道 FFT 是一个线性变换，所以我们可以把要求的两个多项式分别放在实部和虚部上，然后 IDFT 之后实部和虚部上就是分别的原多项式了。这样就又省了一次 FFT，一次多项式乘法总共需要 4 次。</p>
<p>实际使用一般设 <span class="math inline">\(bas\)</span> 为 <span class="math inline">\(2\)</span> 的次幂，比较方便提取系数。</p>
<h4 id="多项式求逆乘法逆">多项式求逆（乘法逆）</h4>
<p>给定 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> ，求出 <span class="math inline">\(G(x)\)</span> 使得 <span class="math inline">\(F(x)G(x)\equiv1\pmod{x^n}\)</span>。</p>
<p>我们要注意乘法逆实际是有无穷项的，只不过我们这里只需要保留前 <span class="math inline">\(n\)</span> 项。</p>
<p>首先， <span class="math inline">\(F(x)\)</span> 在系数模质数有逆元的充要条件是 <span class="math inline">\(F(0)\not=0\)</span> ，即常数项 <span class="math inline">\([x^0]F(x)\)</span> 不为 <span class="math inline">\(0\)</span> 。必要性显然因为常数项怎么乘都是 <span class="math inline">\(0\)</span> ，接下来的构造方式证明了这也是充分条件。</p>
<p>我们先考虑朴素的构造方式，假设我们已知 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的值，那么我们算出其与 <span class="math inline">\(F(x)\)</span> 的乘积，设此时 <span class="math inline">\(m+1\)</span> 次项的系数为 <span class="math inline">\(a\)</span> ，那么 <span class="math inline">\(F(0)[x^{m+1}]G(x)=-a\)</span> ，因为 <span class="math inline">\(F(0)\not=0\)</span> ，所以 <span class="math inline">\(F(0)\)</span> 在模 <span class="math inline">\(p\)</span> 意义下存在逆元，所以 <span class="math inline">\([x^{m+1}]G(x)=(-a)*(F(0))^{-1}\)</span> ，这样我们每一次可以计算出一项直到 <span class="math inline">\(n\)</span> 项，复杂度为 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>我们考虑已知 <span class="math inline">\(m\)</span> 项的情况下是否能得到更多项的系数，而不是只推出了后一项。我们考虑倍增，设 <span class="math inline">\(H(x)\)</span> 为 <span class="math inline">\(G(x)\bmod x^m\)</span>，即只含有 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的多项式。</p>
<p>则我们有 <span class="math display">\[
G(x)-H(x)\equiv 0\pmod{x^m}
\]</span></p>
<p>两边同时平方 <span class="math display">\[
(G(x)-H(x))^2\equiv0\pmod{x^{2m}}
\]</span> 平方使得项度增加了一倍 （ 因为 <span class="math inline">\(x^m\)</span> 以下的项都为 <span class="math inline">\(0\)</span>，<span class="math inline">\(x^m\)</span> 以上的项只能和 <span class="math inline">\(x^m\)</span> 以上的项相乘，这样指数是大于等于 <span class="math inline">\(2m\)</span> 的，会被 <span class="math inline">\(\bmod x^{2m}\)</span> 消掉）。</p>
<p>接下来将括号展开 <span class="math display">\[
G^2(x)-2G(x)H(x)+H^2(x)\equiv 0\pmod{x^{2m}}
\]</span> 两边同乘 <span class="math inline">\(F(x)\)</span> <span class="math display">\[
F(x)G^2(x)-2F(x)G(x)H(x)+F(x)H^2(x)\equiv 0\pmod{x^{2m}}
\]</span> 由定义我们有 <span class="math inline">\(F(x)G(x)\equiv 1\pmod{x^{2m}}\)</span> <span class="math display">\[
G(x)-2H(x)+F(x)H^2(x)\equiv 0\pmod{x^{2m}}\\
G(x)\equiv 2H(x)-F(x)H^2(x)\pmod{x^{2m}}
\]</span> 所以我们只需要用三次 NTT 就可以把项数提高一倍。至于递归算还是迭代算，常数应该差距不大，看个人习惯吧。</p>
<h4 id="分治fft">分治FFT</h4>
<p>给定数组 <span class="math inline">\(g[1],...,g[n-1]\)</span>，求 <span class="math inline">\(f[0],...,f[n-1]\)</span>，其中 <span class="math display">\[
f[i]=\sum\limits_{j=1}^i{f[i-j]g[j]}\\f[0]=1
\]</span> 在模 <span class="math inline">\(998244353\)</span> 意义下进行</p>
<p>考虑分治，先计算左半边，再计算左对右贡献，最后计算右半边，复杂度 <span class="math inline">\(O(N\log^2N)\)</span>。</p>
<p>也可以求逆解决，设 <span class="math display">\[
F(x)=\sum\limits_{i=0}^{n-1}f[i]x^i\\G(x)=\sum\limits_{i=0}^{n-1}g[i]x^i
\]</span> 其中，<span class="math inline">\(g[0]=0\)</span></p>
<p>对其卷积（在 <span class="math inline">\(\bmod x^n\)</span> 意义下进行） <span class="math display">\[
F(x)G(x)\sum\limits_{k=0}^{n-1}\sum\limits_{i+j=k}f[i]g[j]x^k\\
F(x)G(x)=\sum\limits_{k=0}^{n-1}f[k]x^k-f[0]\\
F(x)G(x)=F(x)-f[0]\\
F(x)(G(x)-1)=-f[0]\\
F(x)=\frac{f[0]}{1-G(x)}
\]</span> （第二行是因为 <span class="math inline">\(g[0]=0\)</span> ,所以 <span class="math inline">\(f[0]g[0]=0\)</span>）由于 <span class="math inline">\(f[0]=1\)</span>，求逆就好了，复杂度<span class="math inline">\(O(N\log N)\)</span>。</p>
<h4 id="多项式-ln">多项式 <span class="math inline">\(\ln\)</span></h4>
<p>求 <span class="math inline">\(B(x)\)</span> 使得 <span class="math display">\[
B(x)\equiv \ln A(x) \pmod {x^n}
\]</span> 设 <span class="math display">\[
G(x)=\ln(x)
\]</span></p>
<p><span class="math display">\[
B(x)\equiv G(A(x))\pmod {x^n}
\]</span></p>
<p>两边同时求导得 <span class="math display">\[
B&#39;(x)\equiv G&#39;(A(x))A&#39;(x)\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B&#39;(x)\equiv \frac{A&#39;(x)}{A(x)}\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B(x) \equiv \int \frac{A&#39;(x)}{A(x)}dx\pmod {x^n}
\]</span></p>
<p>多项式求导，求逆，积分即可</p>
<p>注：</p>
<p><span class="math display">\[
A&#39;(x)=\sum\limits_{i=1}^{n-1}ia_ix^{i-1}
\]</span></p>
<p><span class="math display">\[
\int A(x)dx=\sum\limits_{i=0}^{n-1}\frac{a_{i}}{i+1}x^{i+1}
\]</span></p>
<h4 id="多项式除法和取模">多项式除法和取模</h4>
<p>首先，已知 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)=\sum\limits_{i=0}^nf_ix^i\)</span> ，则 <span class="math inline">\(x^nF(\frac{1}{x})=F_r(x)\)</span> ，其中 <span class="math inline">\(F_r(x)=\sum\limits_{i=0}^nf_{n-i}x^i\)</span> ，即将 <span class="math inline">\(F(x)\)</span> 系数翻转后的多项式。</p>
<p>现在，给定 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(m\)</span> 次多项式 <span class="math inline">\(G(x)\)</span> <span class="math inline">\((n&gt;m)\)</span> ，求出 <span class="math inline">\(n-m\)</span> 次多项式 <span class="math inline">\(Q(x)\)</span> 和次数小于 <span class="math inline">\(m\)</span> 的多项式 <span class="math inline">\(R(x)\)</span> 使得 <span class="math inline">\(F(x)=G(x)Q(x)+R(x)\)</span></p>
<p>首先两边同乘 <span class="math inline">\(x^n\)</span></p>
<p>则有 <span class="math display">\[
x^nF(x)=x^mG(x)x^{n-m}Q(x)+x^{n-m}x^mR(x)
\]</span> 将 <span class="math inline">\(x\)</span> 替换为 <span class="math inline">\(\frac{1}{x}\)</span> <span class="math display">\[
x^nF(\frac{1}{x})=x^mG(\frac{1}{x})x^{n-m+1}Q(\frac{1}{x})+x^{n-m}x^{m-1}R(\frac{1}{x})
\]</span> 套用上面的公式 <span class="math display">\[
F_r(x)=G_r(x)Q_r(x)+x^{n-m+1}R_r(x)
\]</span> 我们发现 <span class="math inline">\(Q_r(x)\)</span> 刚好是 <span class="math inline">\(n-m\)</span> 次多项式所以两边对 <span class="math inline">\(x^{n-m+1}\)</span> 取模以消掉 <span class="math inline">\(R_r(x)\)</span> 这一项 <span class="math display">\[
F_r(x)\equiv G_r(x)Q_r(x)\pmod{x^{n-m+1}}
\]</span> 所以我们只需要求出 <span class="math inline">\(G_r(x)\)</span> 的逆元，再与 <span class="math inline">\(F_r(x)\)</span> 相乘就得到了 <span class="math inline">\(Q_r(x)\)</span> ，再利用定义计算出 <span class="math inline">\(R(x)\)</span>。复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
</search>
