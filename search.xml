<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「省选联考2020A卷」作业题</title>
    <url>/2020/06/29/%E3%80%8C%E7%9C%81%E9%80%89%E8%81%94%E8%80%832020A%E5%8D%B7%E3%80%8D%E4%BD%9C%E4%B8%9A%E9%A2%98/</url>
    <content><![CDATA[<p>给定一张带边权的简单无向连通图，定义一棵生成树 <span class="math inline">\(T\)</span> 的权值为 <span class="math display">\[
val(T)=\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
\]</span> 求所有生成树的权值之和。</p>
<p><span class="math inline">\(n\leqslant 30 , m\leqslant\frac{n(n-1)}{2},1\leqslant w_i\leqslant 152501\)</span> 。</p>
<p>首先我们把碍事的 <span class="math inline">\(\gcd\)</span> 消掉，这里通过欧拉反演，即 <span class="math inline">\(\varphi*I=id\)</span> （证明的话把 <span class="math inline">\(1\dots n\)</span> 的数按与 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\gcd\)</span> 分类）。当然也可以直接减掉倍数好像还更方便。那么简单推下式子： <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_T\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})（现在开始设\gcd 为 g）\\
=&amp;\sum\limits_T\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\sum\limits_{d|g}\varphi(d)\\
=&amp;\sum\limits_{d=1}^{w_{max}}\varphi(d)\sum\limits_{ T\and\forall i,d|w_{e_i}}\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)
\end{aligned}
\]</span> 我们枚举 <span class="math inline">\(d\)</span> ，每次找出所有 <span class="math inline">\(w_i\)</span> 为 <span class="math inline">\(d\)</span> 的倍数的边，我们现在需要求出仅由这些边构成的生成树的边权和的和。对于这个，我们构造一个模 <span class="math inline">\(x^2\)</span> 意义下的多项式矩阵，对每条边重新定义边权为 <span class="math inline">\(1+w_ix\)</span> 。基尔霍夫矩阵的主余子式等于 <span class="math inline">\(\sum\limits_T\prod\limits_{i=1}^{n-1}w_i\)</span> （这个我不会证明），那么我们把重新定义的边权带进去发现一次项系数就是我们要求的边权和之和。</p>
<p>然后我们考虑 <span class="math inline">\(\bmod x^2\)</span> 意义下的多项式四则运算，加减法没有区别，乘法：<span class="math inline">\((a+bx)(c+dx)=ac+(ad+bc)x\)</span>，除法：<span class="math inline">\(\frac{a+bx}{c+dx}=\frac{a}{c}+\frac{bc-ad}{c^2}x\)</span> （证明的话乘一个 <span class="math inline">\(c+dx\)</span> 就好了）。当 <span class="math inline">\(c=0\)</span> 怎么办？对于选取每一行的主元，我们找到不为0的次数最低的那一项，如果次数为0那么就直接做，如果为1说明这一列在当前行后面的常数项都为0，此时除法应该特判为 <span class="math inline">\(\frac{bx}{dx}=\frac{b}{d}\)</span>（我不是很确定这里的必要性，代码是否特判都过了）。这样的话对 <span class="math inline">\(1-w_{max}\)</span> 都做一遍矩阵树复杂度是 <span class="math inline">\(O(wn^3)\)</span> 的，我们可以做一个剪枝，当添加入的边大于等于 <span class="math inline">\(n-1\)</span> 时才去做矩阵树，这样的复杂度是 <span class="math inline">\(O(n^3\max\sigma_0w)\)</span> 即 <span class="math inline">\(144\times n^3\)</span> ，可以通过本题。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> N=<span class="number">152501</span>,p=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,u[<span class="number">2505</span>],v[<span class="number">2505</span>],w[<span class="number">2505</span>],phi[N+<span class="number">5</span>],pr[<span class="number">50005</span>],cnt;</span><br><span class="line"><span class="keyword">bool</span> flag[N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])pr[++cnt]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*pr[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%pr[j]))&#123;phi[i*pr[j]]=phi[i]*pr[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*pr[j]]=phi[i]*(pr[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x0,x1;</span><br><span class="line">    poly()&#123;x0=x1=<span class="number">0</span>;&#125;</span><br><span class="line">    poly(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;x0=a,x1=b;&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> +(poly a,poly b)</span><br><span class="line">        &#123;<span class="keyword">return</span> poly(mod(a.x0+b.x0),mod(a.x1+b.x1));&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> -(poly a,poly b)</span><br><span class="line">        &#123;<span class="keyword">return</span> poly(mod(a.x0-b.x0+p),mod(a.x1-b.x1+p));&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> *(poly a,poly b)</span><br><span class="line">        &#123;<span class="keyword">return</span> poly(<span class="number">1l</span>l*a.x0*b.x0%p,mod(<span class="number">1l</span>l*a.x0*b.x1%p+<span class="number">1l</span>l*a.x1*b.x0%p));&#125;</span><br><span class="line">    <span class="keyword">friend</span> poly <span class="keyword">operator</span> /(poly a,poly b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x0==<span class="number">0</span>&amp;&amp;b.x0==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> inv=pw(b.x1,p<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">return</span> poly(<span class="number">1l</span>l*a.x1*inv%p,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> inv=pw(b.x0,p<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> poly(<span class="number">1l</span>l*a.x0*inv%p,((<span class="number">1l</span>l*a.x1*b.x0<span class="number">-1l</span>l*a.x0*b.x1)%p*inv%p*inv%p+p)%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mat[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deg</span><span class="params">(poly a)</span></span>&#123;<span class="keyword">return</span> a.x0?<span class="number">0</span>:(a.x1?<span class="number">1</span>:<span class="number">2</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(deg(mat[j][i])&lt;deg(mat[c][i]))c=j;</span><br><span class="line">        <span class="keyword">if</span>(c!=i)swap(mat[i],mat[c]),f*=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg(mat[i][i])==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            poly t=mat[j][i]/mat[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                mat[j][k]=mat[j][k]-mat[i][k]*t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    poly res;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>)res=poly(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> res=poly(p<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)res=res*mat[i][i];</span><br><span class="line">    <span class="keyword">return</span> res.x1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> m,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u[i],&amp;v[i],&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(!(w[j]%i))</span><br><span class="line">            &#123;</span><br><span class="line">                mat[u[j]][v[j]]=mat[u[j]][v[j]]-poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                mat[v[j]][u[j]]=mat[v[j]][u[j]]-poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                mat[u[j]][u[j]]=mat[u[j]][u[j]]+poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                mat[v[j]][v[j]]=mat[v[j]][v[j]]+poly(<span class="number">1</span>,w[j]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;n)<span class="keyword">continue</span>;</span><br><span class="line">        ans=mod(ans+<span class="number">1l</span>l*det()*phi[i]%p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>matrix tree</tag>
      </tags>
  </entry>
  <entry>
    <title>「BJOI2020」封印</title>
    <url>/2020/06/28/%E3%80%8CBJOI2020%E3%80%8D%E5%B0%81%E5%8D%B0/</url>
    <content><![CDATA[<p>给出只包含小写字母 <span class="math inline">\(a,b\)</span> 的字符串 <span class="math inline">\(s,t\)</span>，<span class="math inline">\(q\)</span> 次询问，每次询问 <span class="math inline">\(s[l,r]\)</span> 和 <span class="math inline">\(t\)</span> 的最长公共子串长度。<span class="math inline">\(|s|,|t|,q\leqslant 2\times 10^5\)</span>。</p>
<a id="more"></a>
<p>首先，我们有一个很经典的套路就是用SA或者SAM求出 <span class="math inline">\(s\)</span> 每个位置最多能向前扩展多长，使得这个子串是 <span class="math inline">\(t\)</span> 的子串。</p>
<p>说一下用SAM实现的做法：先把 <span class="math inline">\(t\)</span> 的自动机建出来，然后让 <span class="math inline">\(s\)</span> 在 <span class="math inline">\(t\)</span> 的自动机上匹配。我们设每一位的答案为 <span class="math inline">\(ans_i\)</span> ，再开一个变量 <span class="math inline">\(now\)</span> 表示当前在哪个节点。</p>
<p>我们一位一位添加进 <span class="math inline">\(s\)</span> ，假设本次添加的字符为 <span class="math inline">\(c\)</span>，当 <span class="math inline">\(now\)</span> 有 <span class="math inline">\(c\)</span> 的出边时，让 <span class="math inline">\(ans_i=ans_{i-1}+1\)</span> （注意这里并不是 <span class="math inline">\(len_{now}+1\)</span> ，因为当前匹配上的串不一定是 <span class="math inline">\(now\)</span> 节点代表的最长串），然后 <span class="math inline">\(now=ch[now][c]\)</span>；</p>
<p>如果没有，我们沿着后缀链接向上跳 <span class="math inline">\(fa\)</span> ，直到跳到虚拟节点或者找到了一个有 <span class="math inline">\(c\)</span> 的出边的节点。</p>
<p>如果跳到了虚拟节点，即 <span class="math inline">\(t\)</span> 根本就不含 <span class="math inline">\(c\)</span> 这个字符，那么使 <span class="math inline">\(ans[i]=0,now=0\)</span> （<span class="math inline">\(0\)</span> 为根节点，<span class="math inline">\(-1\)</span> 为虚拟节点）；</p>
<p>如果找到了 <span class="math inline">\(c\)</span> 的出边，则 <span class="math inline">\(ans_i=len_{now}+1,now=ch[now][c]\)</span> （此处的 <span class="math inline">\(now\)</span> 是你跳到的那个点）。这里为什么是 <span class="math inline">\(len_{now}+ 1\)</span> 呢？因为我们是从某一个儿子节点跳到这里的，而儿子节点代表的子串都严格比父节点的子串长，所以只要跳一次开始，就包含了这个节点的所有串。这样的总复杂度是线性的，因为匹配长度最多只增加 <span class="math inline">\(|s|\)</span> 次，所以跳 <span class="math inline">\(fa\)</span> 的总复杂度也是 <span class="math inline">\(O(|s|)\)</span> 的。</p>
<p>现在我们有了 <span class="math inline">\(ans\)</span> 数组，怎么求出真正的答案呢？不难发现答案就是 <span class="math inline">\(\max\limits_{i=l}^r\min(ans_i,i-l+1)\)</span> ，我们把所有位置按取得 <span class="math inline">\(\min\)</span> 的是哪一种分成两类，我们发现随着 <span class="math inline">\(l\)</span> 的增加，会由 <span class="math inline">\(ans_i\)</span> 取得 <span class="math inline">\(\min\)</span> 变为 <span class="math inline">\(i-l+1\)</span> 取得 <span class="math inline">\(\min\)</span> ，而这个位置为 <span class="math inline">\(i-ans_i+1\)</span> ，所以我们可以按 <span class="math inline">\(l\)</span> 离线下来所有询问，开两棵线段树维护两种的答案（单点修改和查询区间 <span class="math inline">\(\max\)</span>），再给每个位置开个桶，把 <span class="math inline">\(k-ans_k+1=i\)</span> 的都扔进去，然后当 <span class="math inline">\(l\)</span> 扫到这个位置就更改就好了。当然你也可以用可持久化线段树来在线处理询问，就是空间多了个 <span class="math inline">\(\log\)</span> ，代码采用的是离线方法。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;c[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query x,query y)</span></span>&#123;<span class="keyword">return</span> x.l&lt;y.l;&#125;</span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="keyword">namespace</span> Suffix_Automaton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">400005</span>][<span class="number">2</span>],len[<span class="number">400005</span>],fa[<span class="number">400005</span>],tot,last,ans[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np=++tot,p=last;</span><br><span class="line">        last=tot,len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;p!=<span class="number">-1</span>&amp;&amp;(!ch[p][c]);p=fa[p])ch[p][c]=np;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)&#123;fa[np]=q;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> nq=++tot;</span><br><span class="line">        ch[nq][<span class="number">0</span>]=ch[q][<span class="number">0</span>],ch[nq][<span class="number">1</span>]=ch[q][<span class="number">1</span>];</span><br><span class="line">        fa[nq]=fa[q];</span><br><span class="line">        len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">        fa[q]=fa[np]=nq;</span><br><span class="line">        <span class="keyword">for</span>(;p!=<span class="number">-1</span>&amp;&amp;ch[p][c]==q;p=fa[p])ch[p][c]=nq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=s[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][c])now=ch[now][c],ans[i+<span class="number">1</span>]=ans[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(now&amp;&amp;(!ch[now][c]))now=fa[now];</span><br><span class="line">                <span class="keyword">if</span>(!ch[now][c])ans[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[i+<span class="number">1</span>]=len[now]+<span class="number">1</span>,now=ch[now][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tree[<span class="number">800005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;tree[x]=b;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)modify(l,mid,x*<span class="number">2</span>,a,b);</span><br><span class="line">        <span class="keyword">else</span> modify(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b);</span><br><span class="line">        tree[x]=max(tree[x*<span class="number">2</span>],tree[x*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=a&amp;&amp;r&lt;=b)<span class="keyword">return</span> tree[x];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)ans=query(l,mid,x*<span class="number">2</span>,a,b);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;mid)ans=max(ans,query(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>,a,b));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Suffix_Automaton;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> anss[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> n=s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)extend(t[i]-<span class="string">'a'</span>);</span><br><span class="line">    get_ans();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i-ans[i]+<span class="number">1</span>].push_back(i),t1.modify(<span class="number">1</span>,n,<span class="number">1</span>,i,ans[i]);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c[i].l,&amp;c[i].r),c[i].id=i;</span><br><span class="line">    sort(c+<span class="number">1</span>,c+q+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> nowl=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nowl&lt;=c[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v[nowl].size();j++)</span><br><span class="line">                t1.modify(<span class="number">1</span>,n,<span class="number">1</span>,v[nowl][j],<span class="number">0</span>),t2.modify(<span class="number">1</span>,n,<span class="number">1</span>,v[nowl][j],v[nowl][j]);</span><br><span class="line">            nowl++;</span><br><span class="line">        &#125;</span><br><span class="line">        anss[c[i].id]=max(t2.query(<span class="number">1</span>,n,<span class="number">1</span>,c[i].l,c[i].r)-c[i].l+<span class="number">1</span>,t1.query(<span class="number">1</span>,n,<span class="number">1</span>,c[i].l,c[i].r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>data structures</tag>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 90 简要题解</title>
    <url>/2020/06/27/Educational%20Codeforces%20Round%2090%20%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>没来得及写，改天再补上QAQ</p>
]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round &amp;#35;652 (Div. 2)简要题解</title>
    <url>/2020/06/27/Codeforces%20Round%20652(Div.%202)/</url>
    <content><![CDATA[<h3 id="a.-fashionablee">A. <a href="https://codeforces.com/contest/1369/problem/A" target="_blank" rel="noopener">FashionabLee</a></h3>
<p>问是否可以通过旋转使得在平面直角坐标系中的正 <span class="math inline">\(n\)</span> 边形同时有至少一条边与 X 轴平行，有至少一条边与 Y 轴平行。</p>
<a id="more"></a>
<p>显然，当且仅当 <span class="math inline">\(n\bmod 4=0\)</span> 时有解，因为通过轴对称性可知可以被分为全等的四份（我一开始没看清题WA了一次/dk）</p>
<p>提交记录：<a href="https://codeforces.com/problemset/submission/1369/84757021" target="_blank" rel="noopener">#84757021</a></p>
<h3 id="b.-accuratelee">B. <a href="https://codeforces.com/contest/1369/problem/B" target="_blank" rel="noopener">AccurateLee</a></h3>
<p>给定一个01串 <span class="math inline">\(s\)</span> ，如果 <span class="math inline">\(s_i=1\)</span> 且 <span class="math inline">\(s_{i+1}=0\)</span> 那么可以选择这两个数中的一个删除，然后后面的串向前补全。问这个串经过若干操作后最短的长度是多少，如果有多个最短的，输出字典序最小的。</p>
<p>我们考虑 <span class="math inline">\(1...0...1... 0\)</span> 这样的串，我们可以把它消到只剩下一个 <span class="math inline">\(0\)</span> （先用每个0前面的1消掉0，留下最后一个0消掉前面的所有1）。</p>
<p>对于含有前缀0和后缀1的情况，显然它们都不能被消去，所以最后答案为 前缀0的个数+[除去前缀0和后缀1后不是空串] 个0 和 后缀1的个数 个1。</p>
<p>提交记录：<a href="https://codeforces.com/problemset/submission/1369/84770401" target="_blank" rel="noopener">#84770401</a></p>
<h3 id="c.-rationallee">C. <a href="https://codeforces.com/contest/1369/problem/C" target="_blank" rel="noopener">RationalLee</a></h3>
<p>给定 <span class="math inline">\(n\)</span> 个元素，<span class="math inline">\(k\)</span> 个集合，你需要把每个元素恰好放在一个集合内。第 <span class="math inline">\(i\)</span> 个集合需要放进恰好 <span class="math inline">\(w_i\)</span> 个元素，第 <span class="math inline">\(j\)</span> 个元素的价值为 <span class="math inline">\(a_j\)</span> ，每个集合的价值为它包含的元素的价值的最大值和最小值之和（如果只有一个元素计算两次），求所有集合的价值之和的最大值。<span class="math inline">\(k\leqslant n\leqslant 2\times 10^5\)</span>。</p>
<p>考虑贪心，如果我们有 <span class="math inline">\(w=1\)</span> 的集合，那么一定优先把最大的元素放到这种集合里。我们把元素按价值从大到小排序，把集合按大小从小到大排序，那么首先往第 <span class="math inline">\(i\)</span> 个集合内放入第 <span class="math inline">\(i\)</span> 个元素，然后贪心把价值小的元素放入大的集合中（比如说剩下的元素为 <span class="math inline">\(5,3,1\)</span> 集合大小为 <span class="math inline">\(2,1\)</span>，那么就分成 <span class="math inline">\(\{3,1\},\{5\}\)</span> ，这样就是答案。</p>
<p>提交记录：<a href="https://codeforces.com/problemset/submission/1369/84777478" target="_blank" rel="noopener">#84777478</a></p>
<h3 id="d.-tediouslee">D. <a href="https://codeforces.com/contest/1369/problem/D" target="_blank" rel="noopener">TediousLee</a></h3>
<p>给定一种有根树的构造方式，版本1为一个单独的节点，对于版本 <span class="math inline">\(i\)</span> ，我们从版本 <span class="math inline">\(i-1\)</span> 递推：对于版本 <span class="math inline">\(i-1\)</span> 的每个节点，如果它没有儿子，那么长出一个儿子；如果有一个儿子，那么再长出两个新的儿子；如果有三个儿子，那么不变。</p>
<p>现在给定版本 <span class="math inline">\(n\)</span> 的树，每个节点一开始都是绿色，如果一个节点有三个儿子，且它们和这个节点本身都是绿色，那么可以把这四个点染成黄色，问最多能染出多少黄色的节点，答案 <span class="math inline">\(\bmod 10^9+7\)</span>。<span class="math inline">\(n\leqslant2\times 10^6\)</span>。</p>
<p>我们发现对于版本 <span class="math inline">\(i(i\geqslant3)\)</span> ，它实际上由一个根接上两个版本 <span class="math inline">\(i-2\)</span> 的树再接上一个版本 <span class="math inline">\(i-1\)</span> 的树构成，那么我们可以考虑递推。发现这实际上在求一个类似最大独立集的东西，设 <span class="math inline">\(f[n][0/1]\)</span> 为版本 <span class="math inline">\(n\)</span> ，是否染了根节点的色的答案，那么对于 <span class="math inline">\(n\geqslant 3\)</span> 则有 <span class="math display">\[
\left\{
\begin{aligned}
&amp;f[n][0]=2*\max(f[n-2][0],f[n-2][1])+\max(f[n-1][0],f[n-1][1])\\
&amp;f[n][1]=2*f[n-2][0]+f[n-1][0]+4
\end{aligned}
\right.
\]</span> 这个东西在取模意义下是会WA的，因为取模后的 <span class="math inline">\(\max\)</span> 不一定是取模前的 <span class="math inline">\(\max\)</span> ，但是如果你直接这样交上去是会AC的，因为 <span class="math inline">\(f[n][0]\)</span> 和 <span class="math inline">\(f[n][1]\)</span> 的差实际上很小，在 <span class="math inline">\(n\leqslant 2\times 10^6\)</span> 的情况下不会出现两个数取模次数不一样的情况。</p>
<p>考虑能不能不用 <span class="math inline">\(\max\)</span> 来做，我们设 <span class="math inline">\(f_n\)</span> 表示 <span class="math inline">\(n\)</span> 的答案，<span class="math inline">\(r_i\)</span> 表示是否可以在不染根节点的情况下让答案达到 <span class="math inline">\(f_n\)</span> （对应到我们刚才的想法就是若 <span class="math inline">\(f[n][0]\geqslant f[n][1]\)</span> 则 <span class="math inline">\(r_n=1\)</span>），那么有 <span class="math inline">\(r_0=r_1=1\)</span> ，我们发现当 <span class="math inline">\(r_{n-1}=r_{n-2}=1\)</span> 时，我们可以把根节点染色，这时候染色的答案是不染色的答案+4，所以此时 <span class="math inline">\(r_n=0\)</span> ，其他时刻如果我们强制染根节点，最多只会让答案+4，但是子树的答案至少少了4，所以不优，这时 <span class="math inline">\(r_n=1\)</span>。简单归纳就知道当且仅当 <span class="math inline">\(n\bmod 3=0\)</span> 时 <span class="math inline">\(r_n=0\)</span> ，所以有 <span class="math inline">\(f_n=f_{n-1}+2*f_{n-2}+4[n\bmod 3=0]\)</span> ，这样就避免了同时取模和取 <span class="math inline">\(\max\)</span> ，然后这题也可以用矩阵快速幂或者其他方法加速到 <span class="math inline">\(n=10^{18}\)</span>。</p>
<p>提交记录（第一种方法）：<a href="https://codeforces.com/problemset/submission/1369/84785701" target="_blank" rel="noopener">#84785701</a></p>
<h3 id="e.-deadlee">E. <a href="https://codeforces.com/contest/1369/problem/E" target="_blank" rel="noopener">DeadLee</a></h3>
<p>你有 <span class="math inline">\(n\)</span> 种菜和 <span class="math inline">\(m\)</span> 个朋友。每种菜有 <span class="math inline">\(w_i\)</span> 份，每个朋友有两种喜欢的菜（不会相同）。你需要安排朋友来的顺序，每个朋友来了会吃掉他喜欢的菜各一份（如果某一种没有就不吃那一种），问是否有一种顺序使得每个朋友都能吃到至少一种他喜欢的菜，有的话输出任意一种方案。<span class="math inline">\(n,m\leqslant 2\times 10^5\)</span>。</p>
<p>我们把菜看成点，对每个朋友喜欢的两种菜之间连上一条边，设每个点的度数为 <span class="math inline">\(d_i\)</span>，即喜欢吃这种菜的朋友的个数。</p>
<p>首先，我们发现如果 <span class="math inline">\(\forall i,d_i&gt;w_i\)</span> 则无解（证明待补），如果 <span class="math inline">\(\exist i,w_i\geqslant d_i\)</span> ，那么对于所有与 <span class="math inline">\(i\)</span> 相连的边都可以吃 <span class="math inline">\(i\)</span> ，我们把这些边放到栈中，并且将与这些边相连的点的 <span class="math inline">\(d\)</span> 都减去1（重边减去多次）。重复这个步骤如果最终所有边都被访过那么就合法，这时从栈顶一个一个输出就是答案。</p>
<p>提交记录：<a href="https://codeforces.com/contest/1369/submission/84807161" target="_blank" rel="noopener">#84807161</a></p>
<h3 id="f.-barelee">F. <a href="https://codeforces.com/contest/1369/problem/F" target="_blank" rel="noopener">BareLee</a></h3>
<p>现在还不是很明白，所以鸽了。</p>
]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>HEOI2020 退役记</title>
    <url>/2020/06/21/HEOI2020%20%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="写在之前">写在之前</h4>
<p>说起来这次省选真是命运多舛/kk ，反复横跳/kk。举行地点从燕大变成了二中，又说取消了，结果在家长的请（堵）求（门）下又复活了，举行地点又从SX变成了HA又变回了二中，真是奇幻。</p>
<a id="more"></a>
<h4 id="day1">Day1</h4>
<p>前一天晚上彻底自闭，抱着退役心态去的。8:05 左右就进了考场，坐在对面机房（是的我没有打错我们机房就在比赛机房的对面）比赛的感觉真是奇特。8:29左右瞬间干掉半瓶运动饮料，紧接着发解压密码，似乎是随机生成的。</p>
<p>飞快输了密码然后看题（后排的同学还在听监考读密码我已经看题了/kel），发现T1不吸氧T2,T3吸氧可还行。简单读了一下题开始按顺序做，T1发现求个前缀和后缀和就是个求类似交点的东西，有一个二分+树状数组的做法似乎比较显然然后就新建了文件名为 <code>icefirebf.cpp</code> 的文件准备拿60，花了半个小时码完一遍过样例和大样例，然后造了个maker，一开始没保证 <span class="math inline">\(x_i\not=0\)</span> 结果死循环吓了一跳，结果发现这份代码竟然惊人的快？完全没卡常的情况下过 <span class="math inline">\(n,x=2\times10^6\)</span> 只用了5s，于是果断放弃剩下10分（我考场上都没想那10分结果考后才发现加个离散化就好了）开始卡常，花了大约15分钟全部都是添加的数据要跑3.05s左右（本机是 i5-6400）感觉在ccf少爷机上能过就封题了。</p>
<p>紧接着看T2，先套路把 <span class="math inline">\(f\)</span> 带进去对每个 <span class="math inline">\(k^i\)</span> 算答案。结果发现后面的东西两个幂很像之前斯特林数降幂的方法（寒假就写了两个的学习笔记之一没白写）然后把两个幂都先拆开了，然后发现只用拆一个又把另一个还原回去了。这时最戏剧性的一幕发现了：我推式子的时候忘了乘上 <span class="math inline">\(j!\)</span>，结果写中间代码测试是否正确的时候又多写了 <span class="math inline">\(j!\)</span>，反而对了。后来走下一步后发现答案不对了对着刚才的代码调发现多乘个 <span class="math inline">\(j!\)</span> 就对了，然后就把推的式子上加了个阶乘（考完才发现我在哪一步漏的），剩下就很顺利了，过了大样例直接封题。这个时候还剩大约1小时45分钟，此时心情高涨，又秒干了一罐咖啡，于是开T3结果发现完全不会，彻底自闭，硬磕了一个多小时没有任何进度，任何一个性质或者暴力都不会，最后写了个玄学枚举 <span class="math inline">\(v_i\)</span> 和 <span class="math inline">\(m=1\)</span> （虽然估计没有这样的数据）。然后T1剩下的10分也忘了再看看。</p>
<p>Day1估分：<span class="math inline">\(60\sim 90 + 100 + 0\sim 15\)</span></p>
<h4 id="day2">Day2</h4>
<p>自闭场，T2不会</p>
<p>开局先看三道题结果感觉T2最可做？？？（幸亏最后还是先开的T1）一开始想了半天都没啥头绪，大约1个小时15分钟才想到T1算元素贡献状压，于是就很好写啦，但是我的辅助转移数组是 <span class="math inline">\(O(m2^m)\)</span> 的，<span class="math inline">\(m=23\)</span> 刚刚MLE，只好先开到了22，大概有个优化想法但是看时间不多先去开T2T3了。结果T2爆肝90分钟想dsu on tree和树剖啥都没出来，结果自闭去看T3了，直接写了前三个subtask的暴力应该有50分，最后T2写了一个暴力跳fa和" <code>pushdown</code> 的时候如果儿子有标记就 <code>pushdown</code> 儿子"的神奇树剖写法，结果深度大一点依旧暴毙。最后还剩20分钟想起了还没有优化空间的T1，结果没调出来失败了，自闭了。</p>
<p>Day2估分：<span class="math inline">\(80+10+50\)</span></p>
<p>退役了，下午回到了南校（我们明天就回家上网课），准备文化课，希望明年能考好点/dk 。有几位高二神仙考爆炸了，前两天还热闹的北校机房已经空荡荡了，或许这就是所谓的分别吧。</p>
<h4 id="update-on-2020.6.25">Update on 2020.6.25</h4>
<p>今天名单公示，标准分HE#11，省选分HE#5，蹭进了个B队，还是太菜了，csp被其他人吊打50分起步/kk</p>
]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>CF235D Graph Game</title>
    <url>/2020/06/13/CF235D%20Graph%20Game/</url>
    <content><![CDATA[<p>求基环树随机点分治总遍历次数期望</p>
<a id="more"></a>
<p>基环树随机点分治步骤：</p>
<p>①遍历当前分治区域所有点一次</p>
<p>②在当前分治区域随机选择一个点 <span class="math inline">\(x\)</span></p>
<p>③将 <span class="math inline">\(x\)</span> 删掉，产生的所有连通块递归处理。</p>
<p><span class="math inline">\(n\leqslant 3000\)</span></p>
<p>按照套路，我们先考虑如果是一棵树的情况，再扩展到基环树的情况。不难发现如果我们把分治过程建成点分树，那么我们实际上求的是 <span class="math inline">\(\sum\limits_xsize_x\)</span> 的期望，其中 <span class="math inline">\(size_x\)</span> 是 <span class="math inline">\(x\)</span> 子树的大小。 根据期望的线性性，我们考虑计算点的贡献，每个点会被计算 <span class="math inline">\(deep_x\)</span> 次，那么答案就化为 <span class="math inline">\(\sum\limits_xdeep_x\)</span> ， 再进行一步转化， <span class="math inline">\(deep_x\)</span> 等价于 <span class="math inline">\(\sum_\limits y[y是x的祖先]\)</span> （当 <span class="math inline">\(x=y\)</span> 时也成立） 。我们可以画图发现，点对 <span class="math inline">\((x,y)\)</span> 会产生贡献当且仅当 <span class="math inline">\(y\)</span> 被选中时 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在一个连通块内，也就是 <span class="math inline">\(y\)</span> 是在原树中 <span class="math inline">\(x\rightarrow y\)</span> 路径（包括端点）上第一个被选中的点，举个例子</p>
<p><img src="/CF235D/1.png" /></p>
<p>我们现在考虑 <span class="math inline">\((3,1)\)</span> 的贡献，如果我们按照 <span class="math inline">\(1,2,3\)</span> 或 <span class="math inline">\(1,3,2\)</span> 的顺序，那么1就是3的祖先，会产生贡献，而如果是 <span class="math inline">\(2,1,3\)</span> <span class="math inline">\(2,3,1\)</span> <span class="math inline">\(3,1,2\)</span> <span class="math inline">\(3,2,1\)</span> 就都不会产生贡献（点对是有序的）。</p>
<p>显然，这个的概率是 <span class="math inline">\(\frac{1}{dis(x,y)}\)</span> 所以答案就是 <span class="math inline">\(\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac{1}{dis(i,j)}\)</span> 。</p>
<p>接下来我们把树上的做法扩展到基环树上，我们仍旧考虑点对对答案的贡献，分类讨论一下：</p>
<ul>
<li>当 <span class="math inline">\(x,y\)</span> 在同一棵树内，概率仍为 <span class="math inline">\(\frac{1}{dis(x,y)}\)</span></li>
<li>当路径 <span class="math inline">\(x\rightarrow y\)</span> 经过环上的点时，有两种情况可以造成贡献，分别是直接删掉 <span class="math inline">\(y\)</span> 或者先删掉环上的某一个点再删掉 <span class="math inline">\(y\)</span> ，如图</li>
</ul>
<p><img src="CF235D/2.png" /></p>
<p>我们考虑点对 <span class="math inline">\((1,7)\)</span> 设两个点到对应的树根的距离之和为 <span class="math inline">\(a\)</span> （蓝色区域），两个点对应的树根将环切为两条链，链长为 <span class="math inline">\(b,c\)</span> （绿色区域和黄色区域）。那么直接删掉 <span class="math inline">\(y\)</span> 的概率为 <span class="math inline">\(\frac{1}{a+b+c}\)</span> ，先切掉绿色区域后，剩余的绿色区域就已经不在 <span class="math inline">\(x\rightarrow y\)</span> 这条路径上了，不会对后面造成影响 ，所以我们不需要管剩余的绿色区域，只需要看 <span class="math inline">\(y\)</span> 是否是蓝色+黄色区域中第一个被切掉的点，这样总概率为 <span class="math inline">\(\frac{b}{a+b+c} \cdot \frac{1}{a+c}\)</span> 。类似，先切掉黄色，再切掉 <span class="math inline">\(y\)</span> 的概率为 <span class="math inline">\(\frac{c}{a+b+c}\cdot \frac{1}{a+b}\)</span> 。</p>
<p>所以总概率为 <span class="math inline">\(\frac{1}{a+b+c}(1+\frac{b}{a+c}+\frac{c}{a+b})\)</span> 。实现上我们只需要找到环然后暴力枚举计算答案就可以了。还需要写一个lca，代码中用倍增实现，所以复杂度为 <span class="math inline">\(O(n^2\log n)\)</span></p>
<h5 id="code">code:</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">6005</span>],pre[<span class="number">6005</span>],last[<span class="number">3005</span>],tot,fa[<span class="number">3005</span>],belong[<span class="number">3005</span>],</span><br><span class="line">deep[<span class="number">3005</span>],f[<span class="number">3005</span>][<span class="number">12</span>],index[<span class="number">3005</span>];</span><br><span class="line"><span class="keyword">bool</span> cir[<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target[++tot]=y;</span><br><span class="line">    pre[tot]=last[x];</span><br><span class="line">    last[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cir[x])&#123;index[x]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(tar,x);</span><br><span class="line">        <span class="keyword">if</span>(cir[tar])cir[x]=<span class="number">1</span>,index[x]=index[tar]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deep[x]=deep[fa]+<span class="number">1</span>;belong[x]=z;</span><br><span class="line">    f[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tar=target[i];</span><br><span class="line">        <span class="keyword">if</span>(tar==fa||cir[tar])<span class="keyword">continue</span>;</span><br><span class="line">        dfs2(tar,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&lt;deep[y])swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">11</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(deep[f[x][k]]&gt;=deep[y])x=f[x][k];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">11</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(f[x][k]!=f[y][k])x=f[x][k],y=f[y][k];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y,len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        x++,y++;</span><br><span class="line">        <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)fa[fx]=fy;</span><br><span class="line">        <span class="keyword">else</span> cir[y]=<span class="number">1</span>,dfs(x,<span class="number">0</span>),len=index[x];</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(cir[i])dfs2(i,<span class="number">0</span>,i); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">11</span>;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i][k]=f[f[i][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(belong[i]==belong[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=lca(i,j);</span><br><span class="line">                ans+=<span class="number">1.0</span>/(deep[i]+deep[j]<span class="number">-2</span>*deep[l]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a=deep[i]+deep[j],b=<span class="built_in">abs</span>(index[belong[i]]-index[belong[j]])<span class="number">-1</span>,c=len-b<span class="number">-2</span>;</span><br><span class="line">                ans+=<span class="number">1.0</span>/(a+b+c)*(<span class="number">1</span>+<span class="number">1.0</span>*b/(a+c)+<span class="number">1.0</span>*c/(a+b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>probablities</tag>
        <tag>graphs</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT学习笔记</title>
    <url>/2020/01/29/fwt/</url>
    <content><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>给定长度为 <span class="math inline">\(2^n\)</span> 两个序列 <span class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>，设 <span class="math display">\[
C_i=\sum_{j\oplus k = i}A_j \times B_k
\]</span></p>
<p>分别当<span class="math inline">\(\oplus\)</span>是<span class="math inline">\(\text{or}\)</span>,<span class="math inline">\(\text{and}\)</span>和<span class="math inline">\(\text{xor}\)</span>时求出<span class="math inline">\(C\)</span></p>
<a id="more"></a>
<h3 id="什么是fwt">什么是FWT</h3>
<p>FWT（快速沃尔什变换）是一种类似FFT的优化卷积运算的算法，只不过卷积时下标由<span class="math inline">\(+\)</span>变成了位运算。类似FFT，我们需要找到一种变换方式，设<span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>为原序列，<span class="math inline">\(FWT(A)\)</span>，<span class="math inline">\(FWT(B)\)</span>变换后的序列，<span class="math inline">\(\otimes\)</span>为卷积运算，<span class="math inline">\(*\)</span>为对应下标相乘的运算，使得 <span class="math display">\[
FWT(A\otimes B)=FWTA*FWTB
\]</span> （想想FFT，通过变换为点值表达使得卷积运算可以变为对应下标相乘，两者实际上思想一样！）</p>
<p>接下来说一下如何实现</p>
<h4 id="or">OR</h4>
<p>设<span class="math inline">\(A\)</span>为原序列，<span class="math inline">\(FWT_A\)</span>为变换后序列，则有 <span class="math display">\[
FWT_A[i]=\sum\limits_{i|j=i}A[j]
\]</span> 考虑为什么是对的，我们考虑两个变换后的数组按位相乘后的结果 <span class="math display">\[
FWT_A[i]*FWT_B[i]=(\sum\limits_{i|j=i}A[j])*(\sum\limits_{i|k=i}B[k])\\
=\sum\limits_{i|(j|k)=i}A[j]*B[k]
\]</span> 这正是<span class="math inline">\(FWT_{A*B}\)</span>！</p>
<p>但是不能直接这么求，像FFT，我们是否可以把原序列分为两半，通过子问题的解合并出问题的解呢？是可以的，下面给出式子 <span class="math display">\[
FWT_A=
\begin{cases}
A &amp;     &amp;|A|=1\\
merge(FWT_{A_0},FWT_{A_0}+FWT_{A_1})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span></p>
<p>其中，<span class="math inline">\(merge\)</span>为把两个序列拼接起来（左面的序列拼合完成后下标较小），<span class="math inline">\(A_0\)</span>，<span class="math inline">\(A_1\)</span>分别为序列的前半部分（下标较小的部分）和后半部分，<span class="math inline">\(+\)</span>为对应下标的值相加。</p>
<p>考虑正确性，当<span class="math inline">\(|A|=1\)</span>时，显然只有这一个元素，当<span class="math inline">\(|A|\not =1\)</span>时，我们按下标的最高位分为<span class="math inline">\(0\)</span>与<span class="math inline">\(1\)</span>两部分，递归处理左右两边，再考虑这一位的影响，因为只有<span class="math inline">\(0|0=0\)</span>，所以<span class="math inline">\(0\)</span>只有自己的贡献，而<span class="math inline">\(0|1=1,1|1=1\)</span>，所以<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>都有贡献。</p>
<p>或者换种想法，最初定义<span class="math inline">\(FWT\)</span>的式子，如果我们把下标看作集合的状压表示，那么<span class="math inline">\(FWT_A[i]\)</span>实际上是<span class="math inline">\(i\)</span>所有子集对应值的和，我们按位相加时，保证除了最高位，其他低位都是相等的（低位的子集已经递归算过），所以我们只关注最高位，而这一位下标为0或者为1都是这一位为1的子集，所以右边是左右相加，而左边只有0是0的子集，所以只有左边一半。</p>
<p>接下来考虑逆变换，也就是把<span class="math inline">\(FWT\)</span>序列还原为原序列。其实很简单，就是解方程，下面直接给出式子，不做解释 <span class="math display">\[
IFWT_A=
\begin{cases}
FWT_A &amp;     &amp;|A|=1\\
merge(IFWT{A_0},IFWT{A_1}-IFWT{A_0})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span> 然后对于整个序列，<span class="math inline">\(IFWT_A\)</span>就是它自己了</p>
<p>下面是<span class="math inline">\(or\)</span>的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">1</span>)f[j+(len&gt;&gt;<span class="number">1</span>)]+=f[j],f[j+(len&gt;&gt;<span class="number">1</span>)]%=p;</span><br><span class="line">                <span class="keyword">else</span> f[j+(len&gt;&gt;<span class="number">1</span>)]+=(p-f[j]),f[j+(len&gt;&gt;<span class="number">1</span>)]%=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(p\)</span>是板子题的模数，op==1时是正变换，其它时为逆变换，采用像FFT一样的迭代实现</p>
<h4 id="and">AND</h4>
<p>and操作和or操作类似，下面只给出式子和代码 <span class="math display">\[
FWT_A[i]=\sum\limits_{i\&amp;j=i}A[j]
\]</span> <span class="math display">\[
FWT_A=
\begin{cases}
A &amp;     &amp;|A|=1\\
merge(FWT_{A_0+A_1},FWT_{A_0})&amp;    &amp;\text{otherwise}
\end{cases}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtand</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(len&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">1</span>)f[j]+=f[j+(len&gt;&gt;<span class="number">1</span>)],f[j]%=p;</span><br><span class="line">                <span class="keyword">else</span> f[j]+=(p-f[j+(len&gt;&gt;<span class="number">1</span>)]),f[j]%=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xor">XOR</h4>
]]></content>
      <tags>
        <tag>polynomial</tag>
        <tag>bitmasks</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2015」地震后的幻想乡</title>
    <url>/2020/01/21/%E3%80%8CZJOI2015%E3%80%8D%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
    <content><![CDATA[<p>给定一张无向图，边权在<span class="math inline">\([0,1]\)</span>之间随机均匀分布，求这张图的最小生成树边权最大值的期望。</p>
<a id="more"></a>
<p><span class="math inline">\(1\leqslant n\leqslant 10\)</span>，<span class="math inline">\(1\leqslant m\leqslant \frac{n(n-1)}{2}\)</span>（分别是点数与边数）</p>
<p>提示：对于<span class="math inline">\(n\)</span>个<span class="math inline">\([0,1]\)</span>之间的随机变量<span class="math inline">\(x1\)</span>,<span class="math inline">\(x2\)</span>,...,<span class="math inline">\(xn\)</span>，第<span class="math inline">\(k\)</span>小的那个的期望值是<span class="math inline">\(\frac{k}{n+1}\)</span>。</p>
<p>如果我们按照边权从小到大加入边，那么最下生成树边权的最大值也就是加入某一条边使得图恰好联通的那条边的权值。于是我们只需计算这张图是从小到大加了第<span class="math inline">\(i\)</span>条边后恰好联通的概率，记为<span class="math inline">\(P[i]\)</span>，则 <span class="math display">\[
ans=\sum\limits_{i=1}^{m}P[i]E[i]
\]</span> 其中<span class="math inline">\(E[i]\)</span>是这条边的边权期望，由提示我们知道<span class="math inline">\(E[i]=\frac{i}{m+1}\)</span>，那么 <span class="math display">\[
ans=\frac{1}{m+1}\sum\limits_{i=1}^m iP[i]\\
=\frac{1}{m+1}\sum\limits_{i=1}^m\sum\limits_{j=i}^mP[j]
\]</span> 我们设<span class="math inline">\(p[i]=\sum\limits_{j=i}^mP[j]\)</span>那么<span class="math inline">\(ans=\frac{1}{m+1}\sum\limits_{i=1}^m p[i]\)</span>，而<span class="math inline">\(p[i]\)</span>的意义是加入至少<span class="math inline">\(i\)</span>条边才联通的概率，这显然比<span class="math inline">\(P\)</span> 要好计算！</p>
<p>我们考虑如何计算<span class="math inline">\(p\)</span>，不难发现这等价于加了<span class="math inline">\(i-1\)</span>条边还没有联通的概率，可以用不连通方案数除以总方案数来计算概率。于是我们成功的把一个期望问题转化为了计数问题！</p>
<p>考虑状压计算方案，设<span class="math inline">\(f[i][s]\)</span>和<span class="math inline">\(g[i][s]\)</span>为当前点集为<span class="math inline">\(s\)</span>，内部连了<span class="math inline">\(i\)</span>条边，联通/不连通的方案数，那么有 <span class="math display">\[
f[i][s]+g[i][s]=\binom{size[s]}{i}\\
f[i][s]=\sum\limits_{j=0}^{i-1}\sum\limits_{t\subsetneqq s且r\in t}g[j][t]*\binom{size[s-t]}{i-j}
\]</span> 第一条，不连通+联通=总方案数，其中<span class="math inline">\(size[s]\)</span>为子图<span class="math inline">\(s\)</span>中的边数</p>
<p>第二条，<span class="math inline">\(r\)</span>是<span class="math inline">\(s\)</span>中的第一个点（其实可以是任何一个但是在枚举<span class="math inline">\(j\)</span>和<span class="math inline">\(t\)</span>中不能变），这样的话通过枚举这个点所在的连通块大小，可以不重不漏计算出所有不连通图的数量（连通图计数貌似有很多类似的trick，可惜我并没做过）</p>
<p>最后答案式子就不列了，直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">int</span> ss[<span class="number">46</span>],tt[<span class="number">46</span>],cnt[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line">ll f[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">46</span>],g[<span class="number">1</span>+<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">46</span>],c[<span class="number">46</span>][<span class="number">46</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ss[i],&amp;tt[i]),ss[i]--,tt[i]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;ss[j]))&amp;&amp;(i&amp;(<span class="number">1</span>&lt;&lt;tt[j])))cnt[i]++;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">45</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==(s&amp;(-s)))&#123;g[s][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> lowbit=(s&amp;(-s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=s&amp;(s<span class="number">-1</span>);t;t=s&amp;(t<span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(t&amp;lowbit))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[t];i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt[s^t];j++)</span><br><span class="line">                    f[s][i+j]+=g[t][i]*c[cnt[s^t]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[s];i++)g[s][i]=c[cnt[s]][i]-f[s][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)ans+=<span class="number">1.0</span>*f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]/c[cnt[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6Lf"</span>,ans/(m+<span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里更新方式和上面长得不太一样，但实际上是一个东西。复杂度为<span class="math inline">\(O(3^nm)\)</span></p>
]]></content>
      <tags>
        <tag>probablities</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>K-Dtree学习笔记</title>
    <url>/2020/01/17/KDtree/</url>
    <content><![CDATA[<h3 id="什么是k-dtree">什么是K-Dtree</h3>
<blockquote>
<p>在计算机科学里，<strong>k-d树</strong>（ <strong>k-维树</strong>的缩写）是在<strong>k</strong>维欧几里德空间组织点的数据1结构。<strong>k-d</strong>树可以使用在多种应用场合，如多维键值搜索（例：范围搜寻及最邻近搜索）。<strong>k-d树</strong>是空间二分树（Binary space partitioning ）的一种特殊情况。</p>
</blockquote>
<a id="more"></a>
<hr />
<h3 id="如何构造k-dtree">如何构造K-Dtree</h3>
<h4 id="节点存储">节点存储</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,minx,miny,maxx,maxy;</span><br><span class="line">    node *ch[<span class="number">2</span>];</span><br><span class="line">    node (point a)</span><br><span class="line">    &#123;</span><br><span class="line">        x=minx=maxx=a.x;</span><br><span class="line">        y=miny=maxy=a.y;</span><br><span class="line">        ch[<span class="number">0</span>]=ch[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br></pre></td></tr></table></figure>
<p>可以看到代码是<strong>2-Dtree</strong>，没有使用一个数组存放每个维度的位置而是直接开了<strong>x</strong>和<strong>y</strong>两个变量。<strong>minx</strong>,<strong>miny</strong>,<strong>maxx</strong>,<strong>maxy</strong>存放了以这个节点为根的树中的点的覆盖范围，当维数增大时依然可以使用数组存放更加方便。<strong>ch[2]</strong>是儿子，这里使用了指针，也可使用数组。</p>
<h4 id="build函数">build函数</h4>
<p>参考当<span class="math inline">\(k=2\)</span>时的特殊数据结构——二叉查找树的构造方法，确定一个当前要排序的维度，对所有的数据以这一维排序，并递归到两边的数据继续这样的操作，直到只有一个点直接 return 。</p>
<p>如何确定当前划分维度？有三种方法：按顺序一维一维划分，rand()和按每维度方差。三种方法各有各的好处。</p>
<p>以下是一个rand划分的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dim)</span><span class="comment">//l和r为划分的点在序列中的位置，dim为当前划分的维度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        node* t=<span class="keyword">new</span> node(p[l]);<span class="comment">//这个点自己的信息</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    nth_element(p+l,p+mid,p+r,dim?cmpy:cmpx);<span class="comment">//找到区间内这一维的中位数，小于中位数的在左边，大于的在右边</span></span><br><span class="line">    node *t=<span class="keyword">new</span> node(p[mid]);</span><br><span class="line">    <span class="keyword">int</span> nxt=rand()%<span class="number">2</span>;<span class="comment">//rand划分</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;mid)t-&gt;ch[<span class="number">0</span>]=build(l,mid<span class="number">-1</span>,nxt);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)t-&gt;ch[<span class="number">1</span>]=build(mid+<span class="number">1</span>,r,nxt);</span><br><span class="line">    pushup(t);<span class="comment">//更新minx等数据</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造好的<strong>K-Dtree</strong>大概长这个样子：</p>
<p>待更新qwq</p>
]]></content>
      <tags>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1318 最大公约数与最小公倍数方程组</title>
    <url>/2020/01/17/qwq/</url>
    <content><![CDATA[<p>求解一个有趣的方程组，方程组有 <span class="math inline">\(N\)</span> 个未知正整数 <span class="math inline">\(x_0,x_1,x_2,...,x_{N-1}\)</span></p>
<p>方程组由 <span class="math inline">\(M\)</span> 个方程组成，方程只有两种类型：</p>
<p>1）<span class="math inline">\(\text{gcd}(x[i],x[j]) = G\)</span> ；其中， <span class="math inline">\(i\not= j\)</span> ，且 <span class="math inline">\(\text{gcd}(a,b)\)</span> 为正整数 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 的最大公约数的值</p>
<p>2）<span class="math inline">\(\text{lcm}(x[i],x[j]) = L\)</span> ；其中， <span class="math inline">\(i \not= j\)</span> ，且 <span class="math inline">\(\text{lcm}(c,d)\)</span> 为正整数 <span class="math inline">\(c\)</span> 与 <span class="math inline">\(d\)</span> 的最小公倍数的值</p>
<p>你需要判断这样一个方程组是否存在解，且 <span class="math inline">\(N\)</span> 个未知数都是正整数。</p>
<p>例如， <span class="math inline">\(N=4\)</span> ，有8个方程构成的方程组： $$ { <span class="math display">\[\begin{align}
&amp;\text{gcd}(x_0,x_1)=6\\

&amp;\text{lcm}(x_0,x_1)=12\\

&amp;\text{gcd}(x_1,x_2)=6\\

&amp;\text{lcm}(x_1,x_2)=12\\

&amp;\text{gcd}(x_2,x_3)=6\\

&amp;\text{lcm}(x_2,x_3)=12\\

&amp;\text{gcd}(x_3,x_0)=6\\

&amp;\text{lcm}(x_3,x_0)=12\\
\end{align}\]</span> . $$ 这个方程组是有解的，因为 <span class="math inline">\(x_0=x_2=6\)</span> 且 <span class="math inline">\(x_1=x_3=12\)</span> 就是它的一组解。</p>
<p>多组询问， <span class="math inline">\(T\leqslant10,n,m\leqslant200,L_i,G_i\leqslant10^9\)</span>。只需要回答解是否存在。</p>
<p>根据唯一分解定理，我们可以把 <span class="math inline">\(\text{gcd}(x,y)=G\)</span> 或者 <span class="math inline">\(\text{lcm}(x,y)=L\)</span> 这样的方程化为一些指数的 <span class="math inline">\(\min\max\)</span> 方程，我们对每个未知数的每个质因子的指数视作新的未知数，则方程就被划为了 <span class="math inline">\(\max(x,y)=a,\min(x&#39;,y&#39;)=b\)</span> 这样的形式，对每个新的未知数，我们开30个变量（因为指数最大是29） <span class="math inline">\(f[x][i],g[x][i]\)</span> 表示 <span class="math inline">\(x=i\)</span> 是否成立（网上也有题解表示的是 <span class="math inline">\(x\leqslant i\)</span> 是否成立，都可以做）这样的话对于每个方程我们就转化为了01变量的满足性问题，可以使用2-SAT求解。</p>
]]></content>
      <tags>
        <tag>graphs</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2014」力</title>
    <url>/2019/12/29/%E3%80%8CZJOI2014%E3%80%8D%E5%8A%9B/</url>
    <content><![CDATA[<p>给出n个数<span class="math inline">\(q_i\)</span>，给出<span class="math inline">\(F_j\)</span>的定义如下： <span class="math display">\[
F_j = \sum_{i&lt;j}\frac{q_i q_j}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i q_j}{(i-j)^2 }
\]</span></p>
<p>令<span class="math inline">\(E_i=\frac{F_i}{q_i}\)</span>，求<span class="math inline">\(E_i\)</span></p>
<a id="more"></a>
<p><span class="math display">\[
E_j=\sum_{i&lt;j}\frac{q_i}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i}{(i-j)^2 }
\]</span></p>
<p>设<span class="math inline">\(f[i]=q[i],g[i]=\frac{1}{i^2}\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i&lt;j}f[i]g[j-i]-\sum\limits_{i&gt;j}f[i]g[i-j]\\
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=j+1}^nf[i]g[i-j]
\]</span> 设<span class="math inline">\(f&#39;[i]=f[n-i+1]\)</span></p>
<p>则 <span class="math display">\[
E_j=\sum\limits_{i=1}^{j-1}f[i]g[j-i]-\sum\limits_{i=1}^{n-j}f&#39;[i]g[j-i]
\]</span> 直接卷积就好</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> +(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r+y.r,x.i+y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> -(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r-y.r,x.i-y.i&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> comp <span class="keyword">operator</span> *(<span class="keyword">const</span> comp &amp;x,<span class="keyword">const</span> comp &amp;y)&#123;<span class="keyword">return</span> (comp)&#123;x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r&#125;;&#125;</span><br><span class="line">&#125;q[<span class="number">400005</span>],qq[<span class="number">400005</span>],f[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp* f,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(f[i],f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        comp wn=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*pi/len),op*<span class="built_in">sin</span>(<span class="number">2</span>*pi/len)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            comp w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+q;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                comp d=f[j+q]*w;</span><br><span class="line">                f[j+q]=f[j]-d;</span><br><span class="line">                f[j]=f[j]+d;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;q[i].r),qq[n-i+<span class="number">1</span>].r=q[i].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i].r=(((<span class="keyword">double</span>)<span class="number">1.0</span>)/(<span class="keyword">double</span>)i/(<span class="keyword">double</span>)i);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;(n&lt;&lt;<span class="number">1</span>))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    getrev(len);</span><br><span class="line">    fft(q,len,<span class="number">1</span>),fft(qq,len,<span class="number">1</span>),fft(f,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)q[i]=q[i]*f[i],qq[i]=qq[i]*f[i];</span><br><span class="line">    fft(q,len,<span class="number">-1</span>),fft(qq,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>,(q[i].r-qq[n-i+<span class="number">1</span>].r)/len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>polynomials</tag>
      </tags>
  </entry>
  <entry>
    <title>csp2019游记</title>
    <url>/2019/12/29/csp2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>咕咕咕了一个多月的游记qwq</p>
<a id="more"></a>
<h3 id="day-8">Day-8</h3>
<p>期中考完了开始快乐的停课生活qwq</p>
<h3 id="day0">Day0</h3>
<p>如果没有记错的话下午到了秦皇岛，试完机后就去酒店放行李（其实就两个包），晚上和同机房的同学们一起去吃了酸菜鱼（味道还不错qwq），本来还想吃冰激淋的可是想到去年noip的惨痛经历就忍住了没吃。回到酒店开始颓Terraria。晚上本来和我一个房间的AlanSP去找家长住了，第一次一个人睡双人间。自我感觉良好。</p>
<h3 id="day1">Day1</h3>
<p>不喜欢吃酒店的早餐，简单吃了点找别人借了本李煜东看了会exgcd和exbsgs，然后就去燕大了。</p>
<p>到考场上丝毫不慌，反正我退役稳了，然后就一直盯着前面的表看时间。</p>
<p>终于开考了，一遍输对了密码（据说有人输了三遍才对）。先看一遍题，感觉不是很难的样子，于是就以正常顺序开题。T1不是**题嘛，花5分钟写好结果大样例过不去，调了10分钟才发现写的是1而不是1ull，在此之前还发现输出锅了，还好我记得 <code>unsigned long long</code> 输出是 <code>%llu</code> （其实也可以用cout的）。大概在开考后30分钟过了大样例然后造了一下64 2^64-1没有问题就封题了。</p>
<p>T2第一眼看眼前一亮，前两天模拟赛不是考过合法括号序列嘛，所以”很快“的码完了，但中间 windows 下爆栈了，不慌不忙开了虚拟机，果然在 linux 下就没啥问题，顺便也把T1又测了一下，过了114514后就封题了（我考场上竟然没看出来114514）。</p>
<p>还有将近两个小时，我过不了T3，这个T3长得这么水，我要是过不了，我当场！就把这个电脑屏幕吃掉！</p>
<p>1 hour left：woc我觉得不行，先把10分暴力打了，看看能不能把链和菊花图做了</p>
<p>45 mins left：我想到链怎么做了！开始码！</p>
<p>20 mins left： woc怎么一直RE，dev的调试功能是什么毒瘤（我之前看了gdb怎么用但是考场上一慌就忘了）。</p>
<p>10 mins left： 标准结局，自闭了。封题检查文件。</p>
<p>出考场问了问其他人，大概都是100+100+10？感觉是个大众分鸭，今年说不定能上400呢。</p>
<p>颓了一下午和一晚上，我昨天跟AlanSP说要打过亵渎天神，晚上又是我一个人睡的，不知道为什么感觉走廊有人走路，有点吓人。</p>
<h3 id="day2">Day2</h3>
<p>自闭日。</p>
<p>先看了一遍题，感觉T1最不可做？？？（出考场后发现读题出锅了）然后T3 送了40分就先码完了40。接着自闭了一个小时来回看三道题都觉得不可做。大概还剩1个小时10分钟想了下并码了T2的 <span class="math inline">\(n^3\)</span>，发现可以二分转移就优化到了<span class="math inline">\(n^2\log n\)</span>，这个时候大概还剩25分钟，赶紧码了T1爆搜结果样例2过不去？？？调了10分钟没出来，然后就彻底自闭了。最后还剩下5分钟只得放弃，开始建文件夹。</p>
<p>出了考场发现其他人都比我高（，自闭了，Eta估分100+64+55，jiqimao神仙切了两道，然后就在遗憾中回了学校。</p>
<p>估分100+100+10+0+64+40</p>
<p>最后得分100+80+10+8+64+40，D1T2没来longlong见祖宗/(ㄒoㄒ)/~~，差了8分进WC，还好我这种菜鸡进了也是爆零，也没有太大遗憾。jiqimao神仙HE rank2 orz。</p>
<p>感觉这次败在了D2T1上，要多做做DP了（</p>
]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>bsgs</title>
    <url>/2019/12/26/bsgs-exbsgs/</url>
    <content><![CDATA[<h3 id="bsgs">BSGS</h3>
<p>求<span class="math inline">\(a^x\equiv b\space( \mod p)\)</span> 的解，保证<span class="math inline">\(gcd(a,p)=1\)</span>。</p>
<a id="more"></a>
<p>我们设<span class="math inline">\(x=i*m-j\)</span> ，其中<span class="math inline">\(0\leqslant j &lt;m\)</span> 。那么原式可转化为<span class="math inline">\(a^{im}\equiv b*a^j\pmod p\)</span>的解。我们预处理出<span class="math inline">\(b*a^0,b*a^1,...,b*a^{m-1}\)</span>的值，将它们存入哈希表中，枚举<span class="math inline">\(i\)</span>的值，每次查看<span class="math inline">\(a^{im}\)</span>在表中是否出现。</p>
<p>由费马小定理可知，等号左边是有循环节<span class="math inline">\(p-1\)</span>的，所以只需要从<span class="math inline">\(1\)</span>到<span class="math inline">\(\frac{p}{m}\)</span>枚举<span class="math inline">\(i\)</span> ，则不包含哈希表的时间复杂度在当<span class="math inline">\(m=\lceil\sqrt{n}\rceil\)</span>时最优，为<span class="math inline">\(O(\sqrt{p})\)</span>，在实际中常使用<code>std::map</code>作为哈希表，时间复杂度为<span class="math inline">\(O(\sqrt p\log_2p)\)</span></p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(ll a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>((<span class="keyword">double</span>)p));</span><br><span class="line">    mp.clear();</span><br><span class="line">    ll now=<span class="number">1</span>,t=pw(a,m,p);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++)mp[b*now%p]=i,now*=a,now%=p;</span><br><span class="line">    now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now*=t,now%=p;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(now))&#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,i*m-mp[now]);<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exbsgs">EXBSGS</h3>
]]></content>
      <tags>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/2019/12/22/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<h4 id="多项式求逆乘法逆">多项式求逆（乘法逆）</h4>
<p>给定 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> ，求出 <span class="math inline">\(G(x)\)</span> 使得 <span class="math inline">\(F(x)G(x)\equiv1\pmod{x^n}\)</span></p>
<p>首先， <span class="math inline">\(F(x)\)</span> 在系数模质数有逆元的充要条件是 <span class="math inline">\(F(0)\not=0\)</span> ，即常数项 <span class="math inline">\([x^0]F(x)\)</span> 不为 <span class="math inline">\(0\)</span> 。必要性显然因为常数项怎么乘都是 <span class="math inline">\(0\)</span> ，接下来的构造方式证明了这也是充分条件。</p>
<p>我们先考虑朴素的构造方式，假设我们已知 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的值，那么我们算出其与 <span class="math inline">\(F(x)\)</span> 的乘积，设此时 <span class="math inline">\(m+1\)</span> 次项的系数为 <span class="math inline">\(a\)</span> ，那么 <span class="math inline">\(F(0)[x^{m+1}]G(x)=a\)</span> ，因为 <span class="math inline">\(F(0)\not=0\)</span> ，所以 <span class="math inline">\(F(0)\)</span> 在模 <span class="math inline">\(p\)</span> 意义下存在逆元，所以 <span class="math inline">\([x^{m+1}]G(x)=a*(F(0))^{-1}\)</span> ，这样我们每一次可以计算出一项直到 <span class="math inline">\(n\)</span> 项，利用 NTT 复杂度为 <span class="math inline">\(O(n^2\log n)\)</span> 。</p>
<p>我们考虑已知 <span class="math inline">\(m\)</span> 项的情况下是否能得到更多项的系数，而不是只推出了后一项。我们考虑倍增，设 <span class="math inline">\(H(x)\)</span> 为 <span class="math inline">\(G(x)\mod x^m\)</span> ，即只含有 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的多项式。 <span class="math display">\[
F(x)G(x)\equiv 1\pmod{x^m}\\
F(x)H(x)\equiv 1\pmod{x^m}\\
F(x)(G(x)-H(x))\equiv 0\pmod{x^m}
\]</span> 由于 <span class="math inline">\(F(x)\not\equiv 0\)</span>，故 <span class="math display">\[
G(x)-H(x)\equiv 0\pmod{x^m}
\]</span></p>
<p>两边同时平方 <span class="math display">\[
(G(x)-H(x))^2\equiv0\pmod{x^{2m}}
\]</span> 平方使得这里的精度（即模的指数）提升了一倍 （ 因为 <span class="math inline">\(x^m\)</span> 以下的项都为 <span class="math inline">\(0\)</span> ， <span class="math inline">\(x^m\)</span> 以上的项只能和 <span class="math inline">\(x^m\)</span> 以上的项相乘，这样指数是大于等于 <span class="math inline">\(2m\)</span> 的） ，这也是能倍增的原因。</p>
<p>接下来将括号展开 <span class="math display">\[
G^2(x)-2G(x)H(x)+H^2(x)\equiv 0\pmod{x^{2m}}
\]</span> 两边同乘 <span class="math inline">\(F(x)\)</span> <span class="math display">\[
F(x)G^2(x)-2F(x)G(x)H(x)+F(x)H^2(x)\equiv 0\pmod{x^{2m}}
\]</span> 由于 <span class="math inline">\(2m&lt;n\)</span> （大于的时候就不用求了），故 <span class="math inline">\(F(x)G(x)\equiv 1\pmod{x^{2m}}\)</span> <span class="math display">\[
G(x)-2H(x)+F(x)H^2(x)\equiv 0\pmod{x^{2m}}\\
G(x)\equiv 2H(x)-F(x)H^2(x)\pmod{x^{2m}}
\]</span> 所以我们只需要用三次 NTT 就可以把项数提高一倍，实际操作一般从上到下求，具体见代码。</p>
<h4 id="分治fft">分治FFT</h4>
<p>给定数组<span class="math inline">\(g[1],...,g[n-1]\)</span>，求<span class="math inline">\(f[0],...,f[n-1]\)</span>，其中 <span class="math display">\[
f[i]=\sum\limits_{j=1}^i{f[i-j]g[j]}\\f[0]=1
\]</span> 在模<span class="math inline">\(998244353\)</span>意义下进行</p>
<p>考虑分治，先计算左半边，再计算左对右贡献，最后计算右半边，复杂度<span class="math inline">\(O(Nlog^2N)\)</span></p>
<p>也可以求逆解决，设 <span class="math display">\[
F(x)=\sum\limits_{i=0}^{n-1}f[i]x^i\\G(x)=\sum\limits_{i=0}^{n-1}g[i]x^i
\]</span> 其中，<span class="math inline">\(g[0]=0\)</span></p>
<p>对其卷积（在<span class="math inline">\(\mod x^n\)</span>意义下进行） <span class="math display">\[
F(x)G(x)\sum\limits_{k=0}^{n-1}\sum\limits_{i+j=k}f[i]g[j]x^k\\
F(x)G(x)=\sum\limits_{k=0}^{n-1}f[k]x^k-f[0]\\
F(x)G(x)=F(x)-f[0]\\
F(x)(G(x)-1)=-f[0]\\
F(x)=\frac{f[0]}{1-G(x)}
\]</span> （第二行是因为<span class="math inline">\(g[0]=0\)</span>,所以<span class="math inline">\(f[0]g[0]=0\)</span>）由于<span class="math inline">\(f[0]=1\)</span>，求逆就好了，复杂度<span class="math inline">\(O(NlogN)\)</span></p>
<h4 id="多项式-ln">多项式 <span class="math inline">\(\ln\)</span></h4>
<p>求<span class="math inline">\(B(x)\)</span>使得 <span class="math display">\[
B(x)\equiv \ln A(x) \pmod {x^n}
\]</span> 设 <span class="math display">\[
G(x)=\ln(x)
\]</span></p>
<p><span class="math display">\[
B(x)\equiv G(A(x))\pmod {x^n}
\]</span></p>
<p>两边同时求导得 <span class="math display">\[
B&#39;(x)\equiv G&#39;(A(x))A&#39;(x)\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B&#39;(x)\equiv \frac{A&#39;(x)}{A(x)}\pmod {x^n}
\]</span></p>
<p><span class="math display">\[
B(x) \equiv \int \frac{A&#39;(x)}{A(x)}dx\pmod {x^n}
\]</span></p>
<p>多项式求导，求逆，积分即可</p>
<p>注：</p>
<p><span class="math display">\[
A&#39;(x)=\sum\limits_{i=1}^{n-1}ia_ix^{i-1}
\]</span></p>
<p><span class="math display">\[
\int A(x)dx=\sum\limits_{i=0}^{n-1}\frac{a_{i}}{i+1}x^{i+1}
\]</span></p>
<h4 id="多项式除法和取模">多项式除法和取模</h4>
<p>首先，已知 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)=\sum\limits_{i=0}^nf_ix^i\)</span> ，则 <span class="math inline">\(x^nF(\frac{1}{x})=F_r(x)\)</span> ，其中 <span class="math inline">\(F_r(x)=\sum\limits_{i=0}^nf_{n-i}x^i\)</span> ，即将 <span class="math inline">\(F(x)\)</span> 系数翻转后的多项式。</p>
<p>现在，给定 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(m\)</span> 次多项式 <span class="math inline">\(G(x)\)</span> <span class="math inline">\((n&gt;m)\)</span> ，求出 <span class="math inline">\(n-m\)</span> 次多项式 <span class="math inline">\(Q(x)\)</span> 和次数小于 <span class="math inline">\(m\)</span> 的多项式 <span class="math inline">\(R(x)\)</span> 使得 <span class="math inline">\(F(x)=G(x)Q(x)+R(x)\)</span></p>
<p>首先两边同乘 <span class="math inline">\(x^n\)</span></p>
<p>则有 <span class="math display">\[
x^nF(x)=x^mG(x)x^{n-m}Q(x)+x^{n-m}x^mR(x)
\]</span> 将 <span class="math inline">\(x\)</span> 替换为 <span class="math inline">\(\frac{1}{x}\)</span> <span class="math display">\[
x^nF(\frac{1}{x})=x^mG(\frac{1}{x})x^{n-m}Q(\frac{1}{x})+x^{n-m}x^mR(\frac{1}{x})
\]</span> 套用上面的公式 <span class="math display">\[
F_r(x)=G_r(x)Q_r(x)+x^{n-m}R_r(x)
\]</span> 我们发现 <span class="math inline">\(Q_r(x)\)</span> 刚好是 <span class="math inline">\(n-m\)</span> 次多项式所以两边对 <span class="math inline">\(x^{n-m}\)</span> 取模以消掉 <span class="math inline">\(R_r(x)\)</span> 这一项 <span class="math display">\[
F_r(x)\equiv G_r(x)Q_r(x)\pmod{x^{n-m}}
\]</span> 所以我们只需要求出 <span class="math inline">\(G_r(x)\)</span> 的逆元，再与 <span class="math inline">\(F_r(x)\)</span> 相乘就得到了 <span class="math inline">\(Q_r(x)\)</span> ，在利用定义计算出 <span class="math inline">\(R(x)\)</span></p>
]]></content>
      <tags>
        <tag>polynomials</tag>
        <tag>combinatorics</tag>
      </tags>
  </entry>
</search>
